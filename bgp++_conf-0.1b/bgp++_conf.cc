
// Xenofontas Dimitropoulos Georgia Tech
// Patrick Verkaik CAIDA

// Creates configurations for BGP++ used for the atoms 
// project.
//
// It parses a number of files with the following format:

// router info: router-level topology
// --------------------------------------

// Header: r1 r2 rel-type

// r1 r2   : link between the routers identified by these router names
// rel-type: type of relationship between r1 and r2

// Relationship types:
//   peer    : ebgp policy peer
//   cust    : ebgp provider-customer (r1 is provider; r2 is customer)
//   custfull: ebgp provider-customer. Provider r1 announces all carried routes
//             to customer r2.
//   custproxy: ebgp provider-customer. Provider r1 announces no routes to
//              customer r2. r2 announces routes on behalf of r1.
//   ibgp    : ibgp
//   membpeer: atom membership policy peer
//   membcust: atom membership provider-customer
//   membndfz: atom membership dfz-ndfz (r1 is DFZ-edge; r2 is origin AS router
//             in NDFZ)

// Router names are encoded with the AS number and type of router:
//   A router in DFZ AS 'A' is named:
//     Ae1 - edge router, e.g. 701e1
//     At1 - transit router 1, e.g. 701t1
//     ...
//     Atn - transit router n
//
//   The (only) router in non-DFZ AS 'A' is named:
//     A   - otherwise
//     Ao1 - origin AS router
//
//   One specially designated NDFZ AS 'A' consists of multiple, internally
//   disconnected 'proxy' origin AS routers named:
//     ApB - e.g. 999p701
//   where 'B' is another AS that ApB originates atoms for.
//
// Only origin AS routers are capapble of originating atoms.

// prefix info: atoms and prefixes declered/originated by each router
// ------------------------------------------------------------------
//
//   For independent prefixes:
//     column 1         : router ID
//     column 2         : keyword 'prefixes'
//     remaining columns: prefix:attr:routed
//       attr  :  assigns a numeric 'route attribute' to the prefix
//       routed: indicates if the prefix is routed ('true') or not ('false')
//
//     Example:
//       # two routed independent prefixes with the same route attribute:
//       701e1 prefixes 5.6.7.8/24:50:true 6.7.8.9:50:true
//
//   For atoms and atomised prefixes (one line per atom):
//     column 1         : router ID (must be origin AS router)
//     column 2         : keyword 'atom'
//     column 3         : atom-id:attr:routed
//       atom ID: takes the form of a prefix
//       attr   : see above
//       routed : see above
//     remaining columns: prefix:attr:routed (see above)
//       
//     Examples:
//       # routed atom with three configured prefixes, one of which not routed,
//       # the other two have different route attributes:
//       1o701 atom 1.2.3.4/24:40:true 2.3.4.5/24:50:false 3.4.5.6:50:true 4.5.6.7:60:true 
//
//       # routed empty atom
//       1o701 atom 5.6.7.8/24:50:true
//
//
// bgpconf: additional router-level BGP configuration
// --------------------------------------------------
//
// This file contains per-router BGP configuration text to be included as part
// of the BGP configuration generated by bgp++_atomconf.
//
// Each entry is formatted as:
//
//   'head' list of routers
//   tab-indented BGP configuration text
//
// or:
//
//   'tail' list of routers
//   tab-indented BGP configuration text
//
// Example:
//   head 701e1 701t1 701t2
//       ! switch on debugging for updates
//       debug bgp updates
//
// Depending on whether 'head' or 'tail' is specified the text is inserted near
// the beginning or end of the configuration. A router can appear in at most
// one head entry and one tail entry.

// ping_pairs: list of ping pairs that will be created
// --------------------------------------------------
//
// This file contains a list of ping pairs that define ping sessions 
// that will be established.
// 
// Header: source sink time

// Each entry is formatted as:
//
//   'source_id' source ping agent 
//    should be a valid router id.   
//
//   'sink_id' router that will be pinged 
//    should be a valid router id.   
//
//   'dst_ip' ip address of the destination
//    this ip address will be assigned at the 
//    sink_id router and will be used for routing
//
//   'time' time(s) in sec 
//    to ping destination.

// Example:
//  #source_id sink_id dst_ip  time(s)
//  701e1 101 12.12.12.12 12 100 200 
//  #leave a new line at the end

#include <string>
#include <iostream>
#include <stdio.h>
#include <fstream>
#include <vector>
#include <map>
#include <cstdlib>
#include <unistd.h>
#include "stringtok.h"
#include "getopt.h"
#include <assert.h>

class AS;
class Peer;
class Router;
class Atom;

typedef vector<unsigned> uvec_t;
typedef vector<double> timevec_t;
typedef vector<string> text_t;
typedef vector<string> stringvec_t;
typedef vector<Peer> peervec_t;
typedef vector<Router*> routervec_t;
typedef multimap<unsigned,unsigned> pcmap_t;
typedef map<string, Router> routermap_t;
typedef vector<pair<pair<Router*,pair < Router*, string > >,timevec_t> > sessionlist_t;
typedef map<unsigned, AS> asmap_t;
typedef stringvec_t plist_t;
typedef map<unsigned, plist_t> attr2plist_t;
typedef map<string, Atom> atommap_t;
typedef map<string, int> string_set_t;

/* Relationship types specified in the router info file. */
typedef enum {   
  REL_PEER,
  REL_CUST,
  REL_CUSTFULL,
  REL_CUSTPROXY,
  REL_IBGP,
  REL_MEMBPEER,
  REL_MEMBCUST,
  REL_MEMBNDFZ
} rel_t;

/* BGP relationship that the peer of a router has with the router */
typedef enum {   
  BGP_NONE,
  BGP_PROVIDER,
  BGP_PROVIDER_FULL,
  BGP_PROVIDER_PROXY,
  BGP_PEER,
  BGP_CUSTOMER,
  BGP_CUSTOMER_FULL,
  BGP_CUSTOMER_PROXY,
  BGP_IBGP
} bgp_rel_t;

/* Atom membership relationship that the peer of a router has with the router */
typedef enum {   
  MEMB_NONE,
  MEMB_PROVIDER,
  MEMB_PEER,
  MEMB_CUSTOMER,
  MEMB_NDFZ,
  MEMB_DFZ
} memb_rel_t;

// router role. numeric value is used in the router ip address
typedef enum {   
  NO_ROLE = -1,
  NDFZ = 0,      // NDFZ router that does not originate atoms
  DFZ_TRANSIT = 1,
  DFZ_EDGE = 2,
  OAS = 3,       // NDFZ router that originates atoms
  PROXY_OAS = 4  // NDFZ router that originates atoms on behalf of DFZ AS
} router_role_t;

/* Flag manipulation macros. */
#define CHECK_FLAG(V,F)      ((V) & (F))
#define SET_FLAG(V,F)        (V) = (V) | (F)
#define UNSET_FLAG(V,F)      (V) = (V) & ~(F)

#define NO_LOAD      0
#define UNIFORM_LOAD 1
#define TIME_LOAD    2
#define UNIFORM_UPDATE_LOAD 3

#define BUG_ADDRESS "fontas@ece.gatech.edu"

/*Prototypes */

void print_args();
void parse_router_id (Router& r, string id);
void add_peer (Router& r1, Router& r2, rel_t rel, bool flip);
bool parse_annotated_prefix(const string str,
                            string& prefix, unsigned& attr, bool& is_routed);
void print_globals();
void print_bgp_head(FILE* file,Router& r);
void print_bgp_tail(FILE* file,Router& r);
void print_debug(FILE*,Router&);
rel_t extract_rel(string& s);
void usage (int status);
void neighbour_configuration(FILE* f, Router& r, Peer& p, bool& have_rmap_prov,
                          bool& have_rmap_peer, bool& have_rmap_cust,
			  bool& have_rmap_custfull, bool& have_rmap_custproxy, 
                          bool&have_rmap_ibgp);
void print_routemaps(FILE* f,Router r, bool have_rmap_prov,
                            bool have_rmap_peer, bool have_rmap_cust, 
			    bool have_rmap_custfull, bool have_rmap_custproxy,
			    bool have_rmap_ibgp);
void print_router_list ();
void print_finish_check ();

class AS { 
public:
  AS(){};
  routervec_t routers;
};

class Atom {
public:
  Atom() : prefixes() {};
  plist_t prefixes;  // List of atomised prefixes
};

class Router {
public:
  Router() { 
    id = "";
    role = NO_ROLE;
    bgp_head_text = NULL;
    bgp_tail_text = NULL;
    session = 0;
  }

  //public:

  string id;               //router identifier

  // the following fields are derived from 'id'
  unsigned asnum;          //AS #
  router_role_t role;
  unsigned sequence;	   //sequence number of router with given role
  string ip;               //ip address

  peervec_t   peers;       //List of peers

  attr2plist_t plists;     // Maps a numeric route attribute to a list of
                           // prefixes that have that route attribute

  atommap_t   atoms;       // Maps an atom ID to an atom

  static u_char flags;            //debug options
#define DEBUG_NORMAL      (1 << 0) 
#define DEBUG_FSM         (1 << 1) 
#define DEBUG_KEEPALIVES  (1 << 2)
#define DEBUG_FILTERS     (1 << 3)
#define DEBUG_EVENTS      (1 << 4)
#define DEBUG_UPDATES     (1 << 5)
#define LOG_TABLE         (1 << 6)
#define LOG_MSG_COUNT     (1 << 7)

  text_t *bgp_head_text;  // lines to insert near head of bgp conf file
  text_t *bgp_tail_text;  // lines to insert near tail of bgp conf file

  bool session;       //session flag, the router has to originate a block
                      //globally routed
};
u_char Router::flags = 0 ;

class Peer { 
public:
  Peer():r(NULL), bgp_rel (BGP_NONE), memb_rel (MEMB_NONE) {};
  Peer(Router* rt):r(rt), bgp_rel (BGP_NONE), memb_rel (MEMB_NONE) {};  
  Router* r;              
  bgp_rel_t bgp_rel;
  memb_rel_t memb_rel;
};

// see '-P' option
typedef enum {
  ATOMS_ENABLED = 0,         // atoms not disabled at all
  ALLOW_ATOM_PREFIXES = 1,   // atoms disabled but allow atom IDs to be routed
  SUPPRESS_ATOM_PREFIXES = 2 // atoms fully disabled
} atoms_disable_t;


/*Globals */

routermap_t RouterList;
asmap_t ASList;
pcmap_t PCM; // Peer count map
atoms_disable_t atoms_disabled = SUPPRESS_ATOM_PREFIXES; // see '-P' option

struct option longopts[] = 
{
  { "file",     required_argument, NULL, 'f'},
  { "File",     required_argument, NULL, 'F'},
  { "bgpconf",  required_argument, NULL, 'b'},
  { "prefbased",required_argument, NULL, 'P'},
  { "mrai",     required_argument, NULL, 'm'},
  { "withdraw", required_argument, NULL, 'd'},
  { "workload", required_argument, NULL, 'w'},
  { "trace",    no_argument,       NULL, 't'},
  { "memory",   no_argument,       NULL, 'M'},
  { "show-mem", no_argument,       NULL, 's'},
  { "help",     no_argument,       NULL, 'h'},  
  { "Log",      required_argument, NULL, 'L'},
  { "log_table", required_argument, NULL, 'T'},
  { "log_cnt",   required_argument, NULL, 'c'}, 
  { "log_comm",   required_argument, NULL, 'O'}, 
  { "ping_pairs",required_argument, NULL, 'C'}, 
  { "dont_reuse",no_argument, NULL, 'u'}, 
  { "use_nix",no_argument, NULL, 'x'}, 
  { "log_file",required_argument, NULL, 'l'}, 
  { 0 }
};

int main(int argc, char** argv)
{
  int opt;
  int mrai = -1; //DEFAULT IS 30
  string withdraw_as, withdraw_prefix, withdraw_time;  //no originating as by default.
  bool down = false;//withdraw prefix?
  int load_type = NO_LOAD;
  bool trace_all = false;
  bool enable_logging = false;
  double load_min ;
  double load_max ;
  ifstream fr;	    
  ifstream fp;	    
  ifstream *fb = NULL;
  ifstream *fC = NULL;
  string fb_name, fp_name;
  string fC_name;
  size_t lineno;
  bool enable_memory_log = false;
  vector<string> tokens1, tokens_d, table_log_time, msg_cnt_log_time, comm_log_time;
  bool enable_show_memory = false ;
  bool have_router1 = false;
  bool have_router2 = false;
  int debug_level;
  sessionlist_t  PingPairList;
  string global_log_file_name;
  bool dont_reuse = false;
  bool use_nix = false;

  if(argc == 1) usage(1);
  
  while (1) 
    {

      opt = getopt_long (argc, argv, "f:F:b:p:P:m:o:d:w:tshMxL:T:c:O:C:l:u",
                         longopts, 0);
      if (opt == EOF)
	break;
      
      switch (opt) 
	{
	case 0:
	  break;
	case 'f':
	  fr.open (optarg, ifstream::in);
	  if (!fr)
	    {
	      cerr << "Can't open router info file " << string(optarg) << endl;
	      exit(2);
	    }	  
	  break;
	case 'F':
	  fp.open (optarg, ifstream::in);
	  if (!fp)
	    {
	      cerr << "Can't open prefix info file " << string(optarg) << endl;
	      exit(2);
	    }	  
	  fp_name = string(optarg);
	  break;

	case 'b':
          fb = new ifstream;
	  fb->open (optarg, ifstream::in);
	  if (!*fb)
	    {
	      cerr << "Can't open bgpconf file " << string(optarg) << endl;
	      exit(2);
	    }	  
	  fb_name = string(optarg);
	  break;

	case 'P':
	  cerr << "Option -P is not supported in this release " << endl;
	  exit(2);

	  if (strcmp(optarg, "full") == 0)
	    atoms_disabled = SUPPRESS_ATOM_PREFIXES;
	  else if (strcmp(optarg, "hybrid") == 0)
	    atoms_disabled = ALLOW_ATOM_PREFIXES;
	  else {
	    cerr << "Option 'P' must be followed by 'full' or 'hybrid'" << endl;
	    usage(1);
          }
	  break;
	case 'm':
	  mrai = atoi (optarg);
	  if(mrai < 0 || mrai > 600) { 
	    cerr << "Error bad mrai value: "<<mrai<<endl;
	    exit(2);
	  }
	  break;
	case 'd':
	  stringtok(tokens_d, string(optarg));
	  if (tokens_d.size() == 3) {	   
	    withdraw_as     = tokens_d[0];
	    withdraw_prefix = tokens_d[1];
	    withdraw_time   = tokens_d[2];
	    down = true;
	  } else { 
	    cerr << "-d option bad value: "<<string(optarg)<<endl;
	    exit(2);
	  }

	  break;
	case 'w':
	  stringtok(tokens1, string(optarg));

	  if (tokens1.size() >= 1) {	   
	    if (strcmp(tokens1[0].c_str(),"uniform")==0) {
	      if (tokens1.size() == 3) {
		load_min = atof(tokens1[1].c_str());
		load_max = atof(tokens1[2].c_str());
		load_type = UNIFORM_LOAD;
		break;
	      }
	    } else if (strcmp(tokens1[0].c_str(),"uniform-update")==0) {
	      if (tokens1.size() == 3) {
		load_min = atof(tokens1[1].c_str());
		load_max = atof(tokens1[2].c_str());
		load_type = UNIFORM_UPDATE_LOAD;
		break;
	      }
	    } else if (strcmp(tokens1[0].c_str(),"time")==0) {
	      load_type = TIME_LOAD ;
	      break;
	    }
	  }
	    
	  cerr<< "Error malformed workload option "<<optarg<< endl;
	  exit(1);
	  
	case 't':
	  trace_all = true;
	  break;
	case 'M':
	  enable_memory_log = true;
	  break;
	case 's':
	  enable_show_memory = true;
	  break;
	case 'h':
	  usage (0);
	  break;
	case 'L':
	  debug_level = atoi(optarg);
	  if (debug_level<0||debug_level>5)
	    {
	      cerr << "Wrong debug level: " <<string(optarg)<<endl<<
		"Please choose a debug level between 0 and 5"<<endl;
	      exit(2);
	    }	  
	  enable_logging = true;		  
	  switch (debug_level) { 
	  case 0: 
	    SET_FLAG(Router::flags,DEBUG_NORMAL);          
 	    break;
	  case 1:
	    SET_FLAG(Router::flags,DEBUG_FSM);
 	    break;
	  case 2:
	    SET_FLAG(Router::flags,DEBUG_KEEPALIVES);
	    break;
	  case 3:
	    SET_FLAG(Router::flags,DEBUG_FILTERS);
	    break;
	  case 4:
	    SET_FLAG(Router::flags,DEBUG_EVENTS);
	    break;
	  case 5:
	    SET_FLAG(Router::flags,DEBUG_UPDATES);
	    break;
	  }
	  break;

        case 'T':
          stringtok(table_log_time, string(optarg));
          break;
  
        case 'c':
          stringtok(msg_cnt_log_time, string(optarg));
          break;
          
        case 'O':
          stringtok(comm_log_time, string(optarg));
          break;
          
        case 'l':
          global_log_file_name = string(optarg);
          break;

        case 'u':
          dont_reuse = true;
          break;

        case 'x':
          use_nix = true;
          break;
          
        case 'C':
          fC = new ifstream;
          fC->open (optarg, ifstream::in);
          if (!*fC)
            {
              cerr << "Can't open ping pair file " << string(optarg) << endl;
              exit(2);
            }     
          fC_name = string(optarg);
          break;

	default:
	  usage (1);
	  break;
	}
    }

  if (!fr)
    {
      cerr << "No router info file specified"<< endl;
      exit(2);
    }
  while(fr)
    {
      string s;
      getline(fr, s);
      vector<string> tokens;
      stringtok(tokens, s);
      if(tokens.size()==3 && tokens[0][0] != '#')
        {
          // cerr<<"1"<<tokens[0]<<endl<<
	  // 	    "2"<<tokens[1]<<endl<<
	  // 	    "3"<<tokens[2]<<endl<<
	  //	    "4"<<tokens[3]<<endl;
	  
	  string router1 = tokens[0];
	  string router2 = tokens[1];	  
	  if (router1!=router2) {

	    Router& r1 = RouterList[router1];
	    if (r1.id == "") {
	      parse_router_id(r1, router1);
	    }

	    AS& a1 = ASList[r1.asnum];
	    have_router1 = false;
	    
	    routervec_t::iterator itr1;
	    for (itr1 = a1.routers.begin();itr1 != a1.routers.end(); ++itr1) {
	      if (memcmp(*itr1,&r1,sizeof(Router*))) {
		have_router1 = true;
		break;
	      }
	    }
	    if(!have_router1) a1.routers.push_back(&r1);
	    
	    //Repeat for second router 

	    Router& r2 = RouterList[router2];
	    if (r2.id == "") {
	      parse_router_id(r2, router2);
	    }
	    
	    AS& a2 = ASList[r2.asnum];
	    have_router2 = false;

	    routervec_t::iterator itr2;
	    for (itr2 = a2.routers.begin();itr2 != a2.routers.end(); ++itr2) {
	      if (memcmp(*itr2,&r2,sizeof(Router*))) {
		have_router2 = true;
		break;
	      }
	    }
	    if(!have_router2) a2.routers.push_back(&r2);

            string s = tokens[2].substr(0,tokens[2].length());
	    rel_t rel = extract_rel(s);
            if(0)cerr<< "Router1:"<<router1<<"\nas: "<<r1.id<<
                   "\nRouter2 :"<<router2<<"\nas: "<<r2.id<<
                   "Policy: "<<rel<<endl;

	    
	    add_peer (r1, r2, rel, 0);
	    add_peer (r2, r1, rel, 1);
	  }
        }
    }
  fr.close();




  /* READ PREFIXES*/
  if (!fp)
    {
      cerr << "No prefix info file specified"<< endl;
      exit(2);
    }

  lineno = 0;
  while(fp)
    {
      string s;
      getline(fp, s);
      lineno++;
      vector<string> tokens;
      stringtok(tokens, s);
      if(tokens.size()>0 && tokens[0][0] != '#')
        {
	  if (tokens.size() < 3) { // router-id 'atom'|'prefixes' prefix
	    cerr << fp_name << ":" << lineno << ": not enough tokens" << endl;
	    exit(2);
          }

	  string router = tokens[0];

	  routermap_t::iterator it = RouterList.find(router);
	  if (it == RouterList.end()) {
	    cerr << fp_name << ":" << lineno << ": unknown router '" <<
	            router << "'" << endl;
	    exit(2);
          }
	  Router& r = it->second;

	  if (strcmp(tokens[1].c_str(), "atom") == 0) {

	    if (r.role != OAS && r.role != PROXY_OAS) {
	      cerr << fp_name << ":" << lineno << ": router '" <<
	            router << "' cannot declare atom" << endl;
	      exit(2);
	    }

	    // declare atom

	    string prefix;
	    unsigned attr;
	    bool is_routed;

	    // parse atom ID
	    if (! parse_annotated_prefix(tokens[2], prefix, attr, is_routed)) {
	      cerr << fp_name << ":" << lineno << ": error reading '" <<
	              tokens[2] << "'" << endl;
	      exit(2);
	    }
	    Atom& atom = r.atoms [prefix];

	    if (is_routed && atoms_disabled != SUPPRESS_ATOM_PREFIXES) {
	      // add to list of originated prefixes
	      plist_t& plist = r.plists [attr];
	      plist.push_back(prefix);
	    }
	     
	    // parse atomised prefixes
	    for (unsigned tok_index = 3; tok_index < tokens.size(); tok_index++)
            {
	      if (! parse_annotated_prefix(tokens[tok_index], prefix, attr,
	                                   is_routed))
	      {
	        cerr << fp_name << ":" << lineno << ": error reading '" <<
	                tokens[tok_index] << "'" << endl;
	        exit(2);
	      }

	      // add to atom's list of prefixes
	      atom.prefixes.push_back(prefix);

	      if (is_routed) {
	        // add to list of originated prefixes
	        plist_t& plist = r.plists [attr];
	        plist.push_back(prefix);
	      }
	    }
          }
          else if (strcmp(tokens[1].c_str(), "prefixes") == 0) {

	    string prefix;
	    unsigned attr;
	    bool is_routed;

	    // originate prefixes
	    for (unsigned tok_index = 2; tok_index < tokens.size(); tok_index++)
            {
	      if (! parse_annotated_prefix(tokens[tok_index], prefix, attr,
	                                   is_routed))
	      {
	        cerr << fp_name << ":" << lineno << ": error reading '" <<
	                tokens[tok_index] << "'" << endl;
	        exit(2);
	      }

	      if (is_routed) {
	        // add to list of originated prefixes
	        plist_t& plist = r.plists [attr];
	        plist.push_back(prefix);
	      }
	      else {
	        cerr << fp_name << ":" << lineno << ": warning: unrouted " <<
                        "prefix '" << prefix << "'" << endl;
	      }
	    }
	  }
          else {
	    cerr << fp_name << ":" << lineno << ": " << "unexpected '" <<
	            tokens[1] << "'" << endl;
            exit(2);
          }
	}
    }		    
  fp.close();

  /* READ BGP CONF*/

  if (fb != NULL) {
    lineno = 0;
    text_t *lines;
    routervec_t routers;
    int head;      // boolean: are we reading a head or tail spec?
    int first = 1; // boolean: are we the reading first entry?
    while(*fb)
      {
        string s;
        getline(*fb, s);
	lineno++;
	if (s.size() == 0 || s[0] == '#')
	  continue;
	int leading_tab = (s[0] == '\t');

	if (first && leading_tab) {
	  cerr << fb_name << ":" << lineno << ": " <<
	      "unexpected leading tab" << endl;
	  exit(2);
        }
	if (leading_tab)  {
	  // bgp conf line. skip tab
	  string *tabless = new string (&(s.c_str()[1]));
	  lines->push_back(*tabless);
	}
	else {
	  // new entry. store previous entry
	  if (! first) {
	    for (size_t i = 0; i < routers.size(); i++) {
	      Router* r = routers[i];
	      if (head) {
		if (r->bgp_head_text) {
	          cerr << fb_name << ":" << lineno << ": " <<
	               "head section of router " << r->id <<
		       " specified more than once"<< endl;
	          exit(2);
                }
	        r->bgp_head_text = lines;
              }
	      else { // tail
	        if (r->bgp_tail_text) {
	          cerr << fb_name << ":" << lineno << ": " <<
	           "tail section of router " << r->id <<
		       " specified more than once in " <<endl;
	          exit(2);
                }
		r->bgp_tail_text = lines;
	      }
	    }
	  } // if (! first)

	  // expect head or tail followed by list of routers

          lines = new text_t;
	  routers.clear();

          vector<string> tokens;
          stringtok(tokens, s);
          if(tokens.size() < 2) {
	    cerr << fb_name << ":" << lineno << ": " <<
	      "not enough tokens on line " << endl;
	    exit(2);
          }

          if (strcmp(tokens[0].c_str(), "head") == 0)
	    head = true;
          else if (strcmp(tokens[0].c_str(), "tail") == 0)
	    head = false;
          else {
	    cerr << fb_name << ":" << lineno << ": " <<
	    "unexpected '" << tokens[0] << "'" << endl;
	    exit(2);
          }

	  for (size_t i = 1; i < tokens.size(); i++) {
	    string router = tokens[i];
	    routermap_t::iterator it = RouterList.find(router);
	    if (it == RouterList.end()) {
	      cerr << fb_name << ":" << lineno << ": " <<
	        "unknown router '" << router << "'" << endl;
	      exit(2);
            }
	    routers.push_back(&it->second);
          }
          first = 0;
        } // else
      } // while
      

      // store last entry
      if (! first) {
        for (size_t i = 0; i < routers.size(); i++) {
          Router* r = routers[i];
          if (head) { 
            if (r->bgp_head_text) {
	      cerr << fb_name << ":" << lineno << ": " <<
              "head section of router " << r->id <<
                   " specified more than once"<< endl;
              exit(2);
            } 
            r->bgp_head_text = lines;
          } 
          else { // tail
            if (r->bgp_tail_text) {
	      cerr << fb_name << ":" << lineno << ": " <<
                "tail section of router " << r->id <<
                   " specified more than once in " << endl;
              exit(2);
            } 
            r->bgp_tail_text = lines;
          } 
        } 
      } // if (! first)
    fb->close();
  }		    

  /*READ Ping pair file */

  if (fC != NULL) {
    size_t lineno = 0;
    string s;
    timevec_t ping_times;
    while(*fC)
      {
        getline(*fC, s);
        vector<string> tokens;
        stringtok(tokens, s);
        lineno++;
        
        if(tokens.size() == 0 || tokens[0][0] == '#') 
          continue ;

        if(tokens.size() < 3)
          cerr << fC_name << ":" << lineno << ": " <<
            "too few columns" << endl;
        
        string src_router = tokens[0];
        string dst_router = tokens[1];    
	string ip         = tokens[2];
        
        /*Check the validity of the router ids*/
        routermap_t::iterator it = RouterList.find(src_router);
        if (it == RouterList.end()) {
          cerr << fC_name << ":" << lineno << ": " <<
            "unknown source router '" << src_router << "'" << endl;
          exit(2);
        }
        
        it = RouterList.find(dst_router);
        if (it == RouterList.end()) {
          cerr << fC_name << ":" << lineno << ": " <<
            "unknown destination router '" << dst_router << "'" << endl;
          exit(2);
        }
        Router& rt1 = RouterList[src_router];
        rt1.session = true;
        Router& rt2 = RouterList[dst_router];
        rt2.session = true;
        
        if(0)cerr<<"Router:"<<rt1.id<<" has "<<rt1.peers.size()<<" peers"<<endl;
        if(0)cerr<<"Router:"<<rt2.id<<" has "<<rt2.peers.size()<<" peers"<<endl;

	pair < Router*, string > dst(&rt2,ip);
	pair <Router*, pair < Router*, string > > src2dst(&rt1,dst);
        
        for (unsigned i = 3; i < tokens.size(); ++i) { 
          double time = atof(tokens[i].c_str());
          if (time<=0) { 
            cerr<<fC_name << ":" << lineno << ": "
                <<"bad time '" << tokens[i] << "'" << endl;
            exit(2);
          }
          ping_times.push_back(time);
        }       
        PingPairList.push_back( pair < pair <Router*, pair < Router*, string > > , 
                                timevec_t> (src2dst,ping_times));       
        ping_times.clear();     
      }
    fC->close();
  }

  
#ifdef VERBOSE
  // Print the list and create the sorted list by peer count
  cout << "Found " << ASList.size() << " ASes" << endl;
  
  
  for (asmap_t::const_iterator i = ASList.begin(); i != ASList.end(); ++i)
    {
      AS const & a = i->second;
      cout << "AS " << a.m_asnum << " peers " << a.m_peers.size() << endl;
      for (uvec_t::size_type j = 0; j < a.m_peers.size(); ++j)
        {
          cout << "    " << a.m_peers[j] << endl;
        }
      // Maintain the list sorted by peer count
      PCM.insert(pcmap_t::value_type(a.m_peers.size(), a.m_asnum));
    }
  for (pcmap_t::reverse_iterator i = PCM.rbegin(); i != PCM.rend(); ++i)
    {
      cout << "Peer Count " << i->first << " for AS " << i->second << endl;
    }
#endif


  // Create the tcl script
  cout << "# ns2 model" << endl;
  cout << "# Created by BGP++ config utility" << endl;
  print_globals();
  print_finish_check();
  cout << "proc finish { }  {\n\tglobal tf ns\n\tif [info exists tf] {\n\t\tclose $tf\n\t}\n\t$ns halt\n" 
       <<"  #puts \"Time of last update: [Application/Route/Bgp last_update_time]\"\n}"<< endl;

  print_args();
  cout << "set stime [clock seconds]" << endl;
  cout << "puts \"Starting simulation at $stime\"" << endl;
  cout << "set ns [new Simulator]" << endl;
  if (use_nix) {
    cout << "$ns set-nix-routing" <<endl;
  }
  //cout << "$ns use-scheduler RTI"<<endl;
  //cout << "# Use bgp classifier in all nodes"<<endl;
  //cout << "Node set module_list_ { BGP }"<<endl;  
  cout << "puts \"Creating the nodes and BGP Routers\"" << endl;
  cout << "set r [new BgpRegistry]"<< endl;  
  cout << "# Create the Router nodes and BGP applications" << endl;

  //Enable logging to one file by all instances!!
  if(!global_log_file_name.empty()) { 
    cout << "Application/Route/Bgp use-log-file "<<global_log_file_name<< endl;
  }

  if(dont_reuse) {
    cout <<"Application/Route/Bgp dont-reuse"<<endl;
  }

  if (trace_all) {
    cout << "set tf [ open bgplog.tr w ]" << endl;
    cout << "$ns trace-all $tf" <<endl;
  }

  /*Enable logging of community info for routes */

  /* XXX only the keys of the map are used; too lazy to use set<> */
  string_set_t communities;

  if (comm_log_time.size() > 0) {
    /* XXX I'm sure 'string' has a more elegant way to do this */
    char comm_str [20];

    communities[string("100:20")] = 0;
    communities[string("100:30")] = 0;

    for (routermap_t::const_iterator i = RouterList.begin();
         i != RouterList.end(); ++i)
    {
      Router const & router = i->second;

      for (attr2plist_t::const_iterator it = router.plists.begin();
           it != router.plists.end(); it++) {
        unsigned attr = it->first;
        sprintf (comm_str, "200:%u", attr);
        communities[string(comm_str)] = 0;
      }
    }
  }

  for (routermap_t::const_iterator i = RouterList.begin(); i != RouterList.end(); ++i)
    {
      Router const & router = i->second;
      cout <<endl;
      cout << "puts \"Creating Router " << router.id << "\"" << endl;
      cout << "set node("  << router.id << ") [$ns node]" << endl;
      cout << "set BGP" << router.id << " [new Application/Route/Bgp]" << endl;
      cout << "$BGP" << router.id << " register  $r" << endl;
      cout << "$BGP" << router.id << " finish-time  $opt(stop)" << endl;
      cout << "$BGP" << router.id << " config-file "  <<"$opt(dir)/bgpd" 
	   << router.id  << ".conf" << endl;
      cout << "$BGP" << router.id << " attach-node "
           << "$node(" << router.id <<")"<<endl;
      
      if (load_type ==UNIFORM_LOAD) {
	cout << "$BGP" << router.id << " cpu-load-model uniform "
	     << load_min  <<" " << load_max << endl;
      }
      else if (load_type ==UNIFORM_UPDATE_LOAD) {
	cout << "$BGP" << router.id << " cpu-load-model uniform-update "
	     << load_min  <<" " << load_max << endl;
      } else if (load_type==TIME_LOAD) {
	cout << "$BGP" << router.id << " cpu-load-model time-sample" << endl;
      }

      /* Bind BGP table to FIB*/
      //cout << "[ $node(" << router.id << ") entry ] bind-bgp $BGP"<<router.id<<endl;            

      /*Enable table size logging */
      for(u_int32_t s = 0; s < table_log_time.size();++s ){
        double time = atof(table_log_time[s].c_str());
        if (time<=0) { 
          cerr<<"Error: malformed argument: "<<table_log_time[s]
              <<"for time to dump table"<<endl;
          exit(2);
        }
        
        cout << "$ns at "<<time<<" \"$BGP" <<router.id
             << " command \\\"show ip bgp\\\"\"" << endl;   
      } 

      /*Enable msg count logging */     
      for(u_int32_t s = 0; s < msg_cnt_log_time.size();++s ){
        double time = atof(msg_cnt_log_time[s].c_str());
        if (time<=0) { 
          cerr<<"Error: malformed argument: "<<msg_cnt_log_time[s]
              <<"for time to log msg count"<<endl;
          exit(2);
        }
        cout << "$ns at "<<time<<" \"$BGP" <<router.id
             << " command \\\"show ip bgp summary\\\"\"" << endl;   

      } 

      /*Enable logging of community info for routes */

      for(u_int32_t s = 0; s < comm_log_time.size();++s ){
        double time = atof(comm_log_time[s].c_str());
        if (time<=0) { 
          cerr<<"Error: malformed argument: "<<comm_log_time[s]
              <<"for time to print community info "<<endl;
          exit(2);
        }
        for (string_set_t::iterator it = communities.begin();
             it != communities.end(); it++) {
          cout << "$ns at "<<time<<" \"$BGP" <<router.id
               << " command \\\"show ip bgp community " << it->first
	       << "\\\"\"" << endl;   
        }

      }   
    }
  
  cout << "set ctime [clock seconds]" << endl;
  cout << "puts \"nodecreation elapsed seconds [expr $ctime - $stime]\"" << endl<<endl<<endl;
  cout << "# Create the Router Links" << endl;
  cout << "puts \"Creating the links and BGP connectivity\"" << endl;

  size_t npeers = 0;
  for (routermap_t::const_iterator i = RouterList.begin(); i != RouterList.end(); ++i)
    {
      Router const & router = i->second;
      cout << "puts \"Connecting Router " << router.id << "\"" << endl;
      
      for (peervec_t::size_type j = 0; j < router.peers.size(); ++j)
        {
	  if (router.peers[j].r->id < router.id)
            { // Only create connections to routers with lower id
              // otherwise we get duplicate pairs
	      
              cout << "$ns duplex-link $node(" << router.id
                   << ") $node(" << router.peers[j].r->id
                   << ") 1.5Mb 10ms DropTail" << endl;
              npeers++;
	
	    }
        }
    }
  cout << "puts \"created " << npeers << " peering agreements\"" << endl;
  cout << "set ltime [clock seconds]" << endl;
  cout << "puts \"linkcreation elapsed seconds [expr $ltime - $ctime]\"" << endl;

  for (routermap_t::const_iterator i = RouterList.begin(); i != RouterList.end(); ++i)
    {
      Router const & router = i->second;
        /* Set default route */
      if (router.role == NDFZ) /* If outside the FDZ */
        for (peervec_t::size_type j = 0; j < router.peers.size(); ++j)
          {
            if (router.peers[j].bgp_rel == BGP_PROVIDER) { 
              cout << "[ $node(" << router.id << ") entry ] defaulttarget [$ns get-link-head [ $node("
                   <<router.id<<") id] [ $node("<<router.peers[j].r->id<<") id]]"<< endl;
              break;
            }
            
          }
    }
  
  
  if (down) cout << "$ns at "<<withdraw_time<<" \""<< "$BGP" << withdraw_as 
		 << " command \\\"no network "<<withdraw_prefix<<"\\\"\"" << endl;   


  //Enable memory usage logging
  
  if(enable_memory_log) { 
    routermap_t::const_iterator it = RouterList.begin();
    cout <<"set step [  expr $opt(stop) / 10 ] "<<endl;
    cout <<"for { set mlog_counter $step } { $mlog_counter < $opt(stop) } { set  mlog_counter [ expr $mlog_counter + $step] } {\n"<<  
      "\t$ns at $mlog_counter \"$BGP" <<it->second.id.c_str()<< " show-memory\"" <<
      "\n}"<<endl;
  }
  
      
  if(enable_show_memory) { 
    for (routermap_t::const_iterator i = RouterList.begin(); i != RouterList.end(); ++i)
      {
	cout << "$ns at [ expr $opt(stop) - 1 ]  \"$BGP"<<i->second.id.c_str()<<" command \\\"show memory all\\\" \"" << endl;
      }
  }


  if(0) { 
    for (routermap_t::const_iterator i = RouterList.begin(); i != RouterList.end(); ++i)
      {
	cout << "$ns at [ expr $opt(stop) - 1 ]  \"$BGP"<<i->second.id.c_str()<<" command \\\"show ip bgp\\\" \"" << endl;
      }
  }

  /*Create TCP connections */
  for (sessionlist_t::size_type i = 0; i < PingPairList.size(); ++i) {         
    
    cout<<"#Assign ip addresses to destination router"<<endl;
    cout<<"[$ns link $node("<<PingPairList[i].first.first->id
	<<") $node("<<PingPairList[i].first.first->peers.begin()->r->id
	<<") ]   set-ipaddr "<<PingPairList[i].first.first->ip
	<<" 255.255.255.255"<<endl;   
    cout<<"[$ns link $node("<<PingPairList[i].first.second.first->id
        <<") $node("<<PingPairList[i].first.second.first->peers[0].r->id
        <<") ]   set-ipaddr "<<PingPairList[i].first.second.second
        <<" 255.255.255.255"<<endl;   
    cout<<"#Create the agent(s)"<<endl;
    cout<<"set src_"<<PingPairList[i].first.first->id<<"_"
        <<i<<"  [new Agent/UDP]"<<endl;
    cout<<"$ns attach-agent $node("<<PingPairList[i].first.first->id
        <<") $src_"<<PingPairList[i].first.first->id<<"_"<<i<<endl;
    cout<<"$node("<<PingPairList[i].first.first->id<<") bind $src_"
        <<PingPairList[i].first.first->id<<"_"<<i<<" "<<i+1<<endl;

    for (timevec_t::size_type l = 0; l < PingPairList[i].second.size(); ++l) {  
       
      cout<<"$ns at "<<PingPairList[i].second[l]<<" \"$src_"
          <<PingPairList[i].first.first->id<<"_"<<i <<" send 100 bla\""<<endl;
    }

    cout<<"#Create server agent"<<endl;
    cout<<"set sink_"<<PingPairList[i].first.second.first->id<<"_"
        <<i<<" [new Agent/Null]"<<endl;
//     cout<<"$sink_"<<PingPairList[i].first.second.first->id<<"_"
//         <<i<<" set-dst-ipaddr "<<PingPairList[i].first.first->ip<<endl;
    
//     cout<<"$sink_"<<PingPairList[i].first.second.first->id<<"_"
//         <<i<<" set-dst-port "<<i<<endl;    
    cout<<"$ns attach-agent $node("<<PingPairList[i].first.second.first->id
        <<") $sink_"<<PingPairList[i].first.second.first->id<<"_"
        <<i<<endl;
    cout<<"$node("<<PingPairList[i].first.second.first->id<<") bind $sink_"
        <<PingPairList[i].first.second.first->id<<"_"<<i<<" "<<i+1<<endl;   

    cout<<"#Connect tcp agent to dst"<<endl;
    cout<<"$ns ip-connect $src_"<<PingPairList[i].first.first->id<<"_"<<i
        <<" "<<PingPairList[i].first.second.second<<" "<<i+1<<endl<<endl;     
  }

  cout <<"if { $opt(check-fin) } {"<<endl;
  cout<<"\t$ns at $opt(check-start)  \"finish-check $opt(check-time)\""<<endl;
  cout<<"} else {"<<endl;
  cout << "\t$ns at $opt(stop)  \"finish\"" << endl;
  cout << "}"<<endl;


  cout << "puts \"Starting the run\"" << endl;
  cout << "$ns run" << endl;
  cout << "set etime [clock seconds]" << endl;
  cout << "puts \"simulation elapsed seconds [expr $etime - $ltime]\"" << endl;

  //Create configuration files for routers
  FILE* conf ;
  char file_name[1024];   //The size of the arrays is arbitrary choosen
  char id[512];

  for (routermap_t::const_iterator i = RouterList.begin(); i != RouterList.end(); ++i)
    {
      Router& router = (Router&) i->second;
      strcpy(file_name,"bgpd");
      sprintf(id,"%s",router.id.c_str());
      strcat(file_name,id);
      strcat(file_name,".conf");
      conf = fopen(file_name,"w");

      fprintf(conf,"! router %s\n", router.id.c_str());
      print_debug(conf,router);
      if(enable_logging) fprintf(conf,"\n\nlog file bgpd%s.log\n",router.id.c_str());

      print_bgp_head(conf,router);

      fprintf(conf,"\nrouter bgp %d\n",router.asnum);
      fprintf(conf,"bgp router-id %s\n", router.ip.c_str());

      if (! atoms_disabled) {
        switch(router.role) {
          case DFZ_EDGE:
            fprintf(conf,"bgp atom-edge\n");
            fprintf(conf,"atom divert\n");
            break;
          case DFZ_TRANSIT:
	    // empty
            break;
          case OAS:
          case PROXY_OAS:
            fprintf(conf,"bgp atom-originator\n");
            fprintf(conf,"atom divert\n");
            break;
          case NDFZ:
            break;
          default:
	    assert(0);
	  }
        }

      fprintf(conf,"\n!Neighbor List\n\n");
      
      bool have_rmap_prov = false;
      bool have_rmap_peer = false;
      bool have_rmap_cust = false;
      bool have_rmap_custfull = false;
      bool have_rmap_custproxy = false;
      bool have_rmap_ibgp = false;

      for (peervec_t::size_type j = 0; j < router.peers.size(); ++j)
        {
	  Peer& peer = router.peers[j];
	  // disable membership-only relationships
	  if (atoms_disabled && peer.bgp_rel == BGP_NONE) {
            continue;
	  }

	  fprintf(conf,"!neighbor %s\n", peer.r->id.c_str());
	  fprintf(conf,"neighbor %s\tremote-as %d\n",
		  peer.r->ip.c_str(),peer.r->asnum);


	  if(mrai>=0)fprintf(conf,"neighbor %s\t advertisement-interval %d\n",
			     peer.r->ip.c_str(),mrai);

	  neighbour_configuration(conf,router, peer, have_rmap_prov,
	                    have_rmap_peer, have_rmap_cust, have_rmap_custfull,
                            have_rmap_custproxy,
			    have_rmap_ibgp);
	  fprintf(conf,"\n");
	}
      
      if (router.atoms.size() > 0 && ! atoms_disabled)
          fprintf(conf,"!List of Declared Atoms\n");

      for (atommap_t::iterator atom_it = router.atoms.begin();
           ! atoms_disabled && atom_it != router.atoms.end(); ++atom_it)
      {
	const string& atom_id = atom_it->first;
	Atom& atom = atom_it->second;

	// ip prefix-list <prefix-list-name> permit <prefix1>
	// ..
	// ip prefix-list <prefix-list-name> permit <prefixn>
	//
        // atom declare <atom-id> <prefix-list-name>
	// OR:
        // atom declare empty <atom-id>


	// base the prefix-list name on the atom ID

	const char *part1 = "ATOM-";
	const char *part2 = atom_id.c_str();
	char *plist = new char [strlen(part1) + strlen(part2) + 1];
	strcpy(plist, part1);
	strcat(plist, part2);

	// replace: '.' -> '-'
	char *search = plist;
	while ((search = strchr(search, '.')) != NULL) {
	  *search = '-';
	}

	// replace once: '/' -> '-'
	search = strrchr(plist, '/');
	if (search != NULL)
	  *search = '-';

        for (plist_t::iterator net = atom.prefixes.begin();
	     net != atom.prefixes.end(); ++net)  
	  fprintf(conf,"ip prefix-list %s permit %s\n", plist, net->c_str());

	if (atom.prefixes.size() > 0)
          fprintf(conf, "atom declare %s %s\n",atom_id.c_str(), plist);
        else
          fprintf(conf, "atom declare empty %s\n",atom_id.c_str());
        delete[] plist;
      }

      if (router.plists.size() > 0)
        fprintf(conf,"\n!List of Advertised Networks\n");
    
      for (attr2plist_t::iterator it = router.plists.begin();
           it != router.plists.end(); it++) {
	plist_t& plist = it->second;
        
        for (plist_t::iterator it2 = plist.begin(); it2 != plist.end(); it2++) {
	  // command 'network ... route-map ...' not supported
	  // instead we set the attributes when exporting to neighbours
	  fprintf(conf,"network %s\n", it2->c_str());
	}
      }

      print_routemaps(conf,router, have_rmap_prov, have_rmap_peer,
                      have_rmap_cust, have_rmap_custfull, have_rmap_custproxy,
                      have_rmap_ibgp);

      print_bgp_tail(conf,router);
      fclose(conf);
    }
}


void print_args() { 
  cout << 
"proc process_args {} {\n\
global argc argv opt\n\
for {set i 0} {$i < $argc} {incr i} {\n\
set arg [lindex $argv $i]\n\
\nswitch x$arg {\n\
	    x-stop {\n\
		incr i\n\
		set opt(stop) [lindex $argv $i]\n\
	    }\
	    x-dir {\n\
		incr i\n\
		set opt(dir)  [lindex $argv $i]\n\
	    }\n\
	    x-ckpt {\n\
		incr i\n\
		set opt(ckpt-file) [lindex $argv $i]\n\
		if { ! [ string compare $opt(ckpt-file) \"\" ] } {\n\
		    puts \"Error while parsing -ckpt switch, specify a file name\"\n\
		    exit\n\
		}\n\
		\n\
		Application/Route/Bgp checkpoint $opt(ckpt-file)\n\
	    }\n\
	    x-check {\n\
		incr i \n\
		set opt(check-fin)  1\n\
		set opt(check-time)  [lindex $argv $i]\n\
		incr i\n\
		set opt(check-halt)  [lindex $argv $i]\n\
		incr i\n\
               	set opt(check-start) [lindex $argv $i]\n\
	    }\n\
	    default {\n\
		puts [format \"unrecognized argument: %s\" [lindex $argv $i]]\n\
		puts \"Usage:\"\n\
		puts \"  -stop   <time>\"\n\
		puts \"          Time to stop the simulation (sec), default 100.\"\n\
		puts \"  -dir    <path>\"\n\
		puts \"          Router configuration files directory, default cwd.\"\n\
		puts \"  -check  <int> <1/0> <start>\"\n\
		puts \"          This option enables to dynamically stop/pause the simulation when the system has\"\n\
                puts \"          converged. This works as follows: every <int> simulation secs, starting at the <start>\"\n\
                puts \"          sec, the time (denoted as <last>) of the last update in the system is checked. If\"\n\
                puts \"          <current sim time> - <last> greater than <int> the simulation ends (1) or pauses (0)\"\n\
                puts \"          based on the <1/0> argument. For example -check 50 1 200, will stop a simulation if for\"\n\
                puts \"          at a period of 50 secs no updates are exchanged, and will start checking at the 200th sec.\"\n\
                puts \"          Pausing a simulation is designed for use with CONDOR, i.e. to take a checkpoint when the sim\"\n\
                puts \"          is paused. After resuming the simulation, the simulator will attempt to parse a restart.tcl\"\n\
                puts \"          which should be in the same dir with the original .tcl file. The restart.tcl file may include\"\n\
                puts \"          commands to reconfigure the simulation, for example ns-2 at commands. If the restart.tcl file\"\n\
                puts \"          is not found the simulation will proceed according to the initial configuration. This feature\"\n\
                puts \"          enables to change the configuration of a simulation after it has started.\"\n\
		puts \"  -ckpt   <file>\"\n\
		puts \"          This option will take a checkpoint of the process as soon as\"\n\
		puts \"          all BGP initializations have completed. The checkpoint will be\"\n\
		puts \"          written in the <file>. ns-2 must be compiled with CONDOR to work.\"\n\
		exit 1\n\
	    }\n\
	}\n\
    }\n\
}\n\
\nprocess_args" << endl;

  
}

/*
  Sets the fields in r that are derived from r's router id.
*/
void parse_router_id (Router& r, string id)
{
  char *e;

  if(0) cerr<<"Parse id:"<<id<<endl;
  r.id = id; 
  r.asnum = strtol(id.c_str(),&e,0);
  switch (*e) {
  case 't':
    r.role = DFZ_TRANSIT;
    e++;
    break;
  case 'e':
    r.role = DFZ_EDGE;
    e++;
    break;
  case 'o':
    r.role = OAS;
    e++;
    break;
  case 'p':
    r.role = PROXY_OAS;
    e++;
    break;
  case '\0':
    r.role = NDFZ;
    break;
  default:
    cerr<<"Error reading role in node id "<< id << endl;
    exit(2);
  }
  if (*e != '\0') {
    char *seqstr = e;
    r.sequence = strtol(seqstr,&e,0);
    if (*e != '\0') {
      cerr<<"Error reading sequence number in node id "<< id << endl;
      exit(2);
    }
  }
  else
    r.sequence = 1;

  // set router IP address a.b.c.d

  unsigned char a, b, c, d;
  if (r.role == PROXY_OAS) {
    a = (r.sequence >> 8) & 0xff;
    b = r.sequence & 0xff;
    c = r.role;
    // there *should* be only one proxy_oas router with this r.sequence
    // XXX ought to verify
    d = 1;
  }
  else {
    a = (r.asnum >> 8) & 0xff;
    b = r.asnum & 0xff;
    c = r.role;
    d = r.sequence;
  }

  // check for AS numbers that will translate to bad router addresses 
  if (a >= 0xe0)  {
      cerr << "AS number " << id << " >= 57344" << endl;
      exit(2);
    }

  char ip[16];
  sprintf(ip,"%d.%d.%d.%d",a,b,c,d);
  r.ip = string(ip);
}

/*
  Adds r2 to the list of peers of r1. 'rel' is the relation specified in the
  router info file. If 'flip' is false the file specified 'r1 rel r2';
  otherwise it specified 'r2 rel r1'.
*/
void add_peer (Router& r1, Router& r2, rel_t rel, bool flip)
{
  bgp_rel_t bgp = BGP_NONE;
  memb_rel_t memb = MEMB_NONE;
  switch (rel) {
    case REL_PEER:
      bgp = BGP_PEER;
      break;
    case REL_CUST:
      bgp = flip ? BGP_PROVIDER : BGP_CUSTOMER;
      break;
    case REL_CUSTFULL:
      bgp = flip ? BGP_PROVIDER_FULL : BGP_CUSTOMER_FULL;
      break;
    case REL_CUSTPROXY:
      bgp = flip ? BGP_PROVIDER_PROXY : BGP_CUSTOMER_PROXY;
      break;
    case REL_IBGP:
      bgp = BGP_IBGP;
      break;
    case REL_MEMBPEER:
      memb = MEMB_PEER;
      break;
    case REL_MEMBCUST:
      memb = flip ? MEMB_PROVIDER : MEMB_CUSTOMER;
      break;
    case REL_MEMBNDFZ:
      memb = flip ? MEMB_DFZ : MEMB_NDFZ;
      break;
    default:
      assert (0);
  }

  // should use a set of some sort
  Peer *r2_peer;
  peervec_t::size_type j;
  for (j = 0; j < r1.peers.size(); ++j)
  {
    if (r1.peers[j].r->id == r2.id) {
      r2_peer = &r1.peers[j];
      break;
    }
  }
  if (j == r1.peers.size()) { // not found
    r1.peers.push_back(Peer(&r2));
    r2_peer = &r1.peers.back();
  }  

  if (memb != MEMB_NONE) {
    if (r2_peer->memb_rel != MEMB_NONE) {
      cerr << "membership relationship specified twice between "
           << r1.id << " and " << r2.id << endl;
      exit (2);
    }
    r2_peer->memb_rel = memb;
  }
  if (bgp != BGP_NONE) {
    if (r2_peer->bgp_rel != BGP_NONE) {
      cerr << "BGP relationship specified twice between "
           << r1.id << " and " << r2.id << endl;
      exit (2);
    }
    r2_peer->bgp_rel = bgp;
  }
}

/*
  Parses 'str' of the form "prefix:number:bool". See the intro about the prefix
  info file. Returns false on error.
*/
bool parse_annotated_prefix(const string str,
                            string& prefix, unsigned& attr, bool& is_routed) {
  vector<string> tokens;
  stringtok(tokens, str, ":");
  if (tokens.size() != 3) {
    cerr << str << " should be 'prefix:attr:routed'" << endl;
    return false;
  }
  prefix = tokens[0];

  char *e;
  attr = strtol(tokens[1].c_str(),&e,0);
  if (*e != '\0') {
    cerr << "'" << tokens[1] << "' in '" << str << "' not numeric" << endl;
    return false;
  }

  if (strcmp (tokens[2].c_str(), "true") == 0)
    is_routed = true;
  else if (strcmp (tokens[2].c_str(), "false") == 0)
    is_routed = false;
  else {
    cerr << "'" << tokens[2] << "' in '" << str <<
           "' should be 'true' or 'false'" << endl;
    return false;
  }
  return true;
}

void print_globals() { 
  cout << "set opt(stop) 100" << endl;
  cout << "set opt(dir)  [pwd]" << endl;
  cout << "set opt(check-fin) 0" << endl;
  cout << "set opt(check-start)  300" << endl;
  cout << "set opt(check-halt) 1" << endl;
  cout << "set opt(ckpt-file) ns.ckpt" << endl;
}

/* Prints the BGP head configuration text of 'r' to 'file'. */
void print_bgp_head(FILE* file,Router& r) { 
  if (r.bgp_head_text) {
    fprintf(file,"\n\n! BGP head configuration\n");

    for (size_t i = 0; i < r.bgp_head_text->size(); i++) {
      fprintf(file,(*r.bgp_head_text)[i].c_str());
      fprintf(file,"\n");
    }

    fprintf(file,"\n! end BGP head configuration\n");
  }
}

/* Prints the BGP tail configuration text of 'r' to 'file'. */
void print_bgp_tail(FILE* file,Router& r) { 
  if (r.bgp_tail_text) {
    fprintf(file,"\n\n! BGP tail configuration\n");

    for (size_t i = 0; i < r.bgp_tail_text->size(); i++) {
      fprintf(file,(*r.bgp_tail_text)[i].c_str());
      fprintf(file,"\n");
    }

    fprintf(file,"\n! end BGP tail configuration\n");
  }
}

void print_debug(FILE* file,Router& r) { 
  fprintf(file,"\n!Debug options\n");
  

  fprintf(file,"%sdebug bgp \n\
%sdebug bgp fsm\n\
%sdebug bgp keepalives\n\
%sdebug bgp filters\n\
%sdebug bgp events\n\
%sdebug bgp updates\n",
  CHECK_FLAG(r.flags, DEBUG_NORMAL)?"":"!",
  CHECK_FLAG(r.flags, DEBUG_FSM)?"":"!",
  CHECK_FLAG(r.flags, DEBUG_KEEPALIVES)?"":"!",
  CHECK_FLAG(r.flags, DEBUG_FILTERS)?"":"!",
  CHECK_FLAG(r.flags, DEBUG_EVENTS)?"":"!",
  CHECK_FLAG(r.flags, DEBUG_UPDATES)?"":"!");
}

rel_t extract_rel(string& s){ 

  //printf("String is : '%s'",s.c_str());
  if (strcmp(s.c_str(), "peer") == 0)   
    return REL_PEER;
 
  if (strcmp(s.c_str(), "cust") == 0)
    return REL_CUST;
  
  if (strcmp(s.c_str(), "custfull") == 0)            
    return REL_CUSTFULL;
  
  if (strcmp(s.c_str(), "custproxy") == 0)            
    return REL_CUSTPROXY;
  
  if (strcmp(s.c_str(), "membcust") == 0)    
    return REL_MEMBCUST;
  
  if (strcmp(s.c_str(), "membpeer") == 0)    
    return REL_MEMBPEER;
  
  if (strcmp(s.c_str(), "membndfz") == 0)    
    return REL_MEMBNDFZ;
  
  if (strcmp(s.c_str(), "ibgp") == 0)
    return REL_IBGP;
  
  cerr <<"Error no matching policy found for '" <<s<<"'"<<endl;
  exit(2);
}

void usage (int status)
{
  if (status != 0)
    fprintf (stderr, "Try `%s --help' for more information.\n", "bgp++_config");
  else
    {    
      fprintf (stdout, "Usage : %s [OPTION...]\n\n\
Configuration utility for BGP++. Reads a desired simulated topology \n\
from a file and outputs tcl code for simulation and configuration files\n\
for simulated BGP routers.\n\n\
-f, --file       route info file\n\
-F. --File       prefix info file\n\
-b. --bgpconf    additional bgp configuration file\n\
-m, --mrai       MRAI timer value (Default is 30, set to 0 to disable)\n\
-d, --withdraw   instruct a router to withdraw a prefix. Format:\n\
                 <router id> <prefix> <time to withdraw>\n\
                 The prefix should be configured from the prefix file\n\
-w, --workload   Worload model to use:\n\
                     \"uniform min max\",specify min and max in seconds\n\
                     \"uniform-update min max\",specify min and max in seconds\n\
                     \"time\"\n\
                 (Default: no workload model used)\n\
-t, --trace      Enable ns-2 tracing (Default is not enabled).\n\
-M, --memory     Enable memory loging. The memory usage is logged every 10th\n\
                 of the simulation.\n\
-s  --show-mem   Call the \"show memory all\" command before the end of the\n\
                 simulation.\n\
-L  --Log        Enables BGP++ logging.\n\
                 Requires argument (0-5) that specifies what to log\n\
                 set 0 to debug NORMAL\n\
                 set 1 to debug FSM\n\
                 set 2 to debug KEEPALIVES\n\
                 set 3 to debug FILTERS\n\
                 set 4 to debug EVENTS\n\
                 set 5 to debug UPDATES\n\
-T, --log_table  Enable bgp table logging.It requires\n\
                 time argument(s) (sec).\n\
-c, --log_cnt    Enable msg count logging.It requires\n\
                 time argument(s) (sec).\n\
-O, --log_comm   Prints community information for routes. It requires\n\
                 time argument(s) (sec).\n\
-C, --ping_pairs File that list the ping source\n\
                 sink pairs and time(s) to ping.\n\
-l, --log_file   If set one file is used for logging by all BGP\n\
                 instances. Requires filename as argument\n\
-u, --dont_reuse If set memory won't be reuse when applicable (no argument)\n\
-x, --use_nix    Set this flag to enable nix vector routing\n\
-h, --help       Display this help and exit\n\
\n\
Report bugs to %s\n", "bgp++_config", BUG_ADDRESS);
    }

  exit (status);
}

/* 
  For peer 'p' of router 'r', takes care of policy between neighbour classes
  and also atom-membership/atom-transit relationships. Sets have_rmap_... if
  the corresponding in/out routemaps were enabled for the peer.
*/
void neighbour_configuration(FILE* f, Router& r, Peer& p, bool& have_rmap_prov,
                          bool& have_rmap_peer, bool& have_rmap_cust,
			  bool& have_rmap_custfull, bool& have_rmap_custproxy, 
                          bool& have_rmap_ibgp)
{
  if (! atoms_disabled && p.r->role == DFZ_TRANSIT && r.role == DFZ_EDGE) {
    fprintf(f,"neighbor %s\tatom-transit\n",p.r->ip.c_str());
  }

  switch (p.bgp_rel){
    /*
      BGP_PROVIDER, BGP_PROVIDER_FULL, BGP_PROVIDER_PROXY, BGP_PEER:
      Tag incoming non-customer routes, prevent advertisements among
      non-customers, and untag outgoing routes.
    */
  case BGP_PROVIDER:
    fprintf(f,"!provider\n");
    fprintf(f,"neighbor %s\troute-map RMAP_PROV_IN in\n",p.r->ip.c_str());
    fprintf(f,"neighbor %s\troute-map RMAP_NONCUST_OUT out\n\n",
            p.r->ip.c_str());
    have_rmap_prov = 1;
   
    break;
  case BGP_PROVIDER_FULL:
    fprintf(f,"!provider (full routes)\n");
    fprintf(f,"neighbor %s\troute-map RMAP_PROV_IN in\n",p.r->ip.c_str());
    fprintf(f,"neighbor %s\troute-map RMAP_NONCUST_OUT out\n\n",
            p.r->ip.c_str());
    have_rmap_prov = 1;
   
    break;
  case BGP_PROVIDER_PROXY:
    fprintf(f,"!provider (no routes)\n");
    fprintf(f,"neighbor %s\troute-map RMAP_PROV_IN in\n",p.r->ip.c_str());
    fprintf(f,"neighbor %s\troute-map RMAP_NONCUST_OUT out\n\n",
            p.r->ip.c_str());
    have_rmap_prov = 1;
   
    break;
  case BGP_PEER:
    fprintf(f,"!peer\n");
    fprintf(f,"neighbor %s\troute-map RMAP_PEER_IN in\n",p.r->ip.c_str());
    fprintf(f,"neighbor %s\troute-map RMAP_NONCUST_OUT out\n\n",
            p.r->ip.c_str());
    have_rmap_peer = 1;
   
    break;
  case BGP_IBGP:
    fprintf(f,"!ibgp\n");
    fprintf(f,"neighbor %s\troute-map RMAP_IBGP_OUT out\n\n",
            p.r->ip.c_str());
    have_rmap_ibgp = 1;
    break;
  case BGP_CUSTOMER:
    /*
      Tag incoming customer routes, advertise only local routes, and untag
      outgoing routes.
    */
    fprintf(f,"!customer\n");
    fprintf(f,"neighbor %s\troute-map RMAP_CUST_IN in\n",p.r->ip.c_str());
    fprintf(f,"neighbor %s\troute-map RMAP_CUST_OUT out\n",p.r->ip.c_str());
    have_rmap_cust = 1;
    break;
  case BGP_CUSTOMER_FULL:
    /*
      Tag incoming customer routes and untag outgoing routes.
    */
    fprintf(f,"!customer (full routes)\n");
    fprintf(f,"neighbor %s\troute-map RMAP_CUSTFULL_IN in\n",p.r->ip.c_str());
    fprintf(f,"neighbor %s\troute-map RMAP_CUSTFULL_OUT out\n",p.r->ip.c_str());
    have_rmap_custfull = 1;
    break;
  case BGP_CUSTOMER_PROXY:
    /*
      Tag incoming customer routes, advertise no routes.
    */
    fprintf(f,"!customer (no routes)\n");
    fprintf(f,"neighbor %s\troute-map RMAP_CUSTPROXY_IN in\n",p.r->ip.c_str());
    fprintf(f,"neighbor %s\troute-map RMAP_CUSTPROXY_OUT out\n",p.r->ip.c_str());
    have_rmap_custproxy = 1;
    break;
  case BGP_NONE:
    assert (p.memb_rel != MEMB_NONE);
    break;
  default:
    assert (0);
  }

  if (! atoms_disabled) {
    switch (p.memb_rel){
    case MEMB_PROVIDER:
      if (p.bgp_rel == BGP_NONE)
        fprintf(f,"neighbor %s\tatom-membership provider\n",p.r->ip.c_str());
      else
        fprintf(f,"neighbor %s\tatom-membership+ provider\n",p.r->ip.c_str());
      break;
    case MEMB_PEER:
      if (p.bgp_rel == BGP_NONE)
        fprintf(f,"neighbor %s\tatom-membership peer\n",p.r->ip.c_str());
      else
        fprintf(f,"neighbor %s\tatom-membership+ peer\n",p.r->ip.c_str());
      break;
    case MEMB_CUSTOMER:
      if (p.bgp_rel == BGP_NONE)
        fprintf(f,"neighbor %s\tatom-membership customer\n",p.r->ip.c_str());
      else
        fprintf(f,"neighbor %s\tatom-membership+ customer\n",p.r->ip.c_str());
      break;
    case MEMB_NDFZ:
      if (p.bgp_rel == BGP_NONE)
        fprintf(f,"neighbor %s\tatom-membership ndfz\n",p.r->ip.c_str());
      else
        fprintf(f,"neighbor %s\tatom-membership+ ndfz\n",p.r->ip.c_str());
      break;
    case MEMB_DFZ:
      if (p.bgp_rel == BGP_NONE)
        fprintf(f,"neighbor %s\tatom-membership dfz\n",p.r->ip.c_str());
      else
        fprintf(f,"neighbor %s\tatom-membership+ dfz\n",p.r->ip.c_str());
      break;
    case MEMB_NONE:
      break;
    default:
      assert(0);
    }
  }
}

/*
  For the have_rmap_... parameters that are true, prints the corresponding
  routemap definitions.
*/

void print_routemaps(FILE* f,Router r, bool have_rmap_prov,
                            bool have_rmap_peer, bool have_rmap_cust,
			    bool have_rmap_custfull, bool have_rmap_custproxy,
                            bool have_rmap_ibgp)
{
  fprintf(f,"\n");
  fprintf(f,"!Policy\n");
  fprintf(f,"!\n");
  fprintf(f,"!community values:  \n");
  fprintf(f,"!  customer    : 100:30\n");
  fprintf(f,"!  non-customer: 100:20\n\n");
  fprintf(f,"!localpref values:  \n");
  fprintf(f,"!  customer: 30\n");
  fprintf(f,"!  peer    : 20\n");
  fprintf(f,"!  provider: 10\n");
  fprintf(f,"\n");
  fprintf(f,"!Route attributes for locally originated prefixes\n");
  fprintf(f,"!community values: 200:<numeric-attr>\n");

  fprintf(f,"\n");

  // zebra strips localpref on ebgp automatically

  if (have_rmap_prov) {
    fprintf(f,"route-map RMAP_PROV_IN permit 10\n");
    fprintf(f,"  set community-additive 100:20\n");
    fprintf(f,"  set local-preference 10\n");
  }

  if (have_rmap_peer) {
    fprintf(f,"route-map RMAP_PEER_IN permit 10\n");
    fprintf(f,"  set community-additive 100:20\n");
    fprintf(f,"  set local-preference 20\n");
  }

  if (have_rmap_prov || have_rmap_peer) {
    unsigned seq = 0;

    fprintf(f,"route-map RMAP_NONCUST_OUT deny %u\n", seq += 10);
    fprintf(f,"  match community NONCUST\n");
    fprintf(f,"route-map RMAP_NONCUST_OUT permit %u\n", seq += 10);
    fprintf(f,"  match community CUST\n");
    fprintf(f,"  set community-delete CUST\n");

    if (r.plists.size() > 0)
      fprintf(f,"\n!add attributes to locally originated prefixes\n");
    for (attr2plist_t::iterator it = r.plists.begin();
         it != r.plists.end(); it++) {
      unsigned attr = it->first;
        
      fprintf(f,"route-map RMAP_NONCUST_OUT permit %u\n", seq += 10);
      fprintf(f,"  match ip address SET%u\n", attr);
      fprintf(f,"  set community 200:%u\n", attr);
    }
    fprintf(f,"! should never reach this actually\n");
    fprintf(f,"route-map RMAP_NONCUST_OUT permit %u\n", seq += 10);
    fprintf(f,"\n");
  }

  if (have_rmap_cust) {

    unsigned seq = 0;

    fprintf(f,"route-map RMAP_CUST_IN permit 10\n");
    fprintf(f,"  set community-additive 100:30\n");
    fprintf(f,"  set local-preference 30\n");
    fprintf(f,"route-map RMAP_CUST_OUT deny %u\n", seq += 10);
    fprintf(f,"  match community NONCUST     \n");
    fprintf(f,"route-map RMAP_CUST_OUT deny %u\n", seq += 10);
    fprintf(f,"  match community CUST        \n");

    if (r.plists.size() > 0)
      fprintf(f,"\n!add attributes to locally originated prefixes\n");
    for (attr2plist_t::iterator it = r.plists.begin();
         it != r.plists.end(); it++) {
      unsigned attr = it->first;
        
      fprintf(f,"route-map RMAP_CUST_OUT permit %u\n", seq += 10);
      fprintf(f,"  match ip address SET%u\n", attr);
      fprintf(f,"  set community 200:%u\n", attr);
    }
    fprintf(f,"! should never reach this actually\n");
    fprintf(f,"route-map RMAP_CUST_OUT permit %u\n", seq += 10);
    fprintf(f,"\n");
  }

  if (have_rmap_custfull) {

    unsigned seq = 0;

    fprintf(f,"route-map RMAP_CUSTFULL_IN permit 10\n");
    fprintf(f,"  set community-additive 100:30\n");
    fprintf(f,"  set local-preference 30\n");

    if (r.plists.size() > 0)
      fprintf(f,"\n!add attributes to locally originated prefixes\n");
    for (attr2plist_t::iterator it = r.plists.begin();
         it != r.plists.end(); it++) {
      unsigned attr = it->first;
        
      fprintf(f,"route-map RMAP_CUSTFULL_OUT permit %u\n", seq += 10);
      fprintf(f,"  match ip address SET%u\n", attr);
      fprintf(f,"  set community 200:%u\n", attr);
    }
    fprintf(f,"\n");
    fprintf(f,"route-map RMAP_CUSTFULL_OUT permit %u\n", seq += 10);
      fprintf(f,"  set community-delete NONLOCAL\n");
    fprintf(f,"\n");
  }
  if (have_rmap_custproxy) {

    unsigned seq = 0;

    // custproxy is proxy for own AS, so do not set CUST community and give
    // high local pref
    fprintf(f,"route-map RMAP_CUSTPROXY_IN permit 10\n");
    fprintf(f,"  set local-preference 100\n");
    fprintf(f,"route-map RMAP_CUSTPROXY_OUT deny %u\n", seq += 10);
    fprintf(f,"\n");
  }


  fprintf(f,"ip community-list CUST permit 100:30\n");
  fprintf(f,"ip community-list NONCUST permit 100:20\n");

  fprintf(f,"ip community-list NONLOCAL permit 100:20\n");
  fprintf(f,"ip community-list NONLOCAL permit 100:30\n");

  if (r.plists.size() > 0)
    fprintf(f,"\n!define prefix lists for locally originated prefixes\n");
  for (attr2plist_t::iterator it = r.plists.begin();
       it != r.plists.end(); it++) {
    unsigned attr = it->first;
    plist_t& plist = it->second;
    for (plist_t::iterator it2 = plist.begin(); it2 != plist.end(); it2++) {
      fprintf(f,"access-list SET%u permit %s\n", attr, it2->c_str());
    }
  }

  if (have_rmap_ibgp) {

    unsigned seq = 0;

    fprintf(f,"route-map RMAP_IBGP_OUT permit %u\n", seq += 10);
    fprintf(f,"  match community NONCUST     \n");
    fprintf(f,"route-map RMAP_IBGP_OUT permit %u\n", seq += 10);
    fprintf(f,"  match community CUST        \n");

    if (r.plists.size() > 0)
      fprintf(f,"\n!add attributes to locally originated prefixes\n");
    for (attr2plist_t::iterator it = r.plists.begin();
         it != r.plists.end(); it++) {
      unsigned attr = it->first;
        
      fprintf(f,"route-map RMAP_IBGP_OUT permit %u\n", seq += 10);
      fprintf(f,"  match ip address SET%u\n", attr);
      fprintf(f,"  set community 200:%u\n", attr);
    }
    fprintf(f,"route-map RMAP_IBGP_OUT permit %u\n", seq += 10);
    fprintf(f,"\n");
  }

  fprintf(f,"\n");
}

void print_router_list () { 
  for (routermap_t::const_iterator i = RouterList.begin();
       i != RouterList.end(); ++i) {
    cerr<<"\nRouter: "<<i->second.id<<" peers :"<<endl;
    for (peervec_t::size_type j = 0; j < i->second.peers.size(); ++j) { 
      cerr<<i->second.peers[j].r->id<<",";
    }       
  }
}


void print_finish_check () { 
  
  cout<<"#"<<endl;
  cout<<"#Checks if the last $time seconds,"<<endl;
  cout<<"#there has been an update. If false"<<endl; 
  cout<<"#it stops/checkpoints the simulation,"<<endl;
  cout<<"#otherwise it issues a call to finish-check"<<endl;
  cout<<"#in $time seconds in the future."<<endl;
  cout<<"#"<<endl;
  cout<<"proc finish-check { time }  {"<<endl;
  cout<<"    global tf opt ns"<<endl;
  cout<<"    puts \"finish-check at [[ Simulator instance ] now], Time of last update: [Application/Route/Bgp last-update-time],\""<<endl;
  cout<<"    if { [ expr [ [ Simulator instance ] now ] - [ Application/Route/Bgp last-update-time ] ]  > $time  }  { "<<endl;
  cout<<"	#"<<endl;
  cout<<"       if {  [ set opt(check-halt) ] } { "<<endl;
  cout<<"           [ Simulator instance ] halt	"<<endl;
  cout<<"	    puts \"End of simulation at [[ Simulator instance ] now]\""<<endl;
  cout<<"           if [info exists tf] {"<<endl;
  cout<<"       	close $tf"<<endl;
  cout<<"           }"<<endl;
  cout<<"       } else { "<<endl;
  cout<<"           [ Simulator instance ]  at [ expr [[ Simulator instance ] now ] + $time ]   \"finish-check $time\""<<endl;
  cout<<"           [ Simulator instance ] checkpoint"<<endl;
  cout<<"           catch { source restart.tcl } "<<endl;
  cout<<"       }"<<endl;
  cout<<"    } else { "<<endl;
  cout<<"	puts \"rescheduling\""<<endl;
  cout<<"	[ Simulator instance ]  at [ expr [[ Simulator instance ] now ] + $time ]   \"finish-check $time\""<<endl;	
  cout<<"    }"<<endl;
  cout<<"}"<<endl;
}
