/****************************************************************************/
/*  File:            bgp.cc                                                 */ 
/*  Author:          Xenofontas Dimitropoulos                               */ 
/*  Email:           fontas@ece.gatech.edu                                  */
/*  Documentation:   at <http://www.ece.gatech.edu/                         */
/*                       research/labs/MANIACS/BGP++>                       */
/*  Version:         1.05 beta with pdns support and Zebra MRAI             */
/*                                                                          */
/*  Copyright (c) 2003 Georgia Institute of Technology                      */
/*  This program is free software; you can redistribute it and/or           */
/*  modify it under the terms of the GNU General Public License             */
/*  as published by the Free Software Foundation; either version 2          */
/*  of the License, or (at your option) any later version.                  */
/*                                                                          */
/*  This program is distributed in the hope that it will be useful,         */
/*  but WITHOUT ANY WARRANTY; without even the implied warranty of          */
/*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           */
/*  GNU General Public License for more details.                            */
/*                                                                          */
/****************************************************************************/

#ifdef HAVE_PDNS_BGP
#include "tcp/tcp-bgplistener.h"
#endif

#include "bgp/bgp.h"
#include <limits.h>
#include <float.h>
#include <unistd.h>    /* standard unix functions, like getpid()       */
#include <sys/types.h> /* various type definitions, like pid_t         */
#include <signal.h>    /* signal name macros, and the kill() prototype */

#ifdef HAVE_PERFCTR
extern "C" {
  #include "perfctr.h"
  struct vperfctr *self;
  struct vperfctr_control control;
}
#endif /* HAVE_PERFCTR */

#ifdef HAVE_CONDOR
extern "C" void init_image_with_file_name( char * ); 
#endif


/* 
   Static variables 
*/

double Bgp::last_update_time_ = 0;
char*  Bgp::use_log_file_ = NULL;
FILE*  Bgp::use_log_fp_ = NULL;

double Bgp::uniform_max = 0;
double Bgp::uniform_min = 0;

BgpRegistry* Bgp::Ip2BgpMap = NULL;

#ifdef HAVE_PERFCTR
int Bgp::perfcnt_init = 0;
struct perfctr_info Bgp::info ;
#endif /*  HAVE_PERFCTR */

int Bgp::rnd = 0;
time_t Bgp::start_time;

bool Bgp::enter_bgp_construct = false;
bool Bgp::enter_bgp_main = false;
int Bgp::instance_cnt = 0;

bool Bgp::dont_reuse = false;
bool Bgp::default_randomize = true;

struct message Bgp::attr_str [] = 
{
  { BGP_ATTR_ORIGIN,           "ORIGIN" }, 
  { BGP_ATTR_AS_PATH,          "AS_PATH" }, 
  { BGP_ATTR_NEXT_HOP,         "NEXT_HOP" }, 
  { BGP_ATTR_MULTI_EXIT_DISC,  "MULTI_EXIT_DISC" }, 
  { BGP_ATTR_LOCAL_PREF,       "LOCAL_PREF" }, 
  { BGP_ATTR_ATOMIC_AGGREGATE, "ATOMIC_AGGREGATE" }, 
  { BGP_ATTR_AGGREGATOR,       "AGGREGATOR" }, 
  { BGP_ATTR_COMMUNITIES,      "COMMUNITY" }, 
  { BGP_ATTR_ORIGINATOR_ID,    "ORIGINATOR_ID" },
  { BGP_ATTR_CLUSTER_LIST,     "CLUSTERLIST" }, 
  { BGP_ATTR_DPA,              "DPA" },
  { BGP_ATTR_ADVERTISER,       "ADVERTISER"} ,
  { BGP_ATTR_RCID_PATH,        "RCID_PATH" },
  { BGP_ATTR_MP_REACH_NLRI,    "MP_REACH_NLRI" },
  { BGP_ATTR_MP_UNREACH_NLRI,  "MP_UNREACH_NLRI" },
  { 0, NULL }
};

/* messages for BGP-4 status */
struct message Bgp::bgp_status_msg[] = 
{
  { 0, "null" },
  { Idle, "Idle" },
  { Connect, "Connect" },
  { Active, "Active" },
  { OpenSent, "OpenSent" },
  { OpenConfirm, "OpenConfirm" },
  { Established, "Established" },
};

int Bgp::bgp_status_msg_max = BGP_STATUS_MAX;

char *Bgp::bgp_type_str[] =
{
  NULL,
  "OPEN",
  "UPDATE",
  "NOTIFICATION",
  "KEEPALIVE",
  "ROUTE-REFRESH"
};

/* message for BGP-4 Notify */
struct message Bgp::bgp_notify_msg[] = 
{
  { 0, "null" },
  { BGP_NOTIFY_HEADER_ERR, "Message Header Error"},
  { BGP_NOTIFY_OPEN_ERR, "OPEN Message Error"},
  { BGP_NOTIFY_UPDATE_ERR, "UPDATE Message Error"},
  { BGP_NOTIFY_HOLD_ERR, "Hold Timer Expired"},
  { BGP_NOTIFY_FSM_ERR, "Finite State Machine Error"},
  { BGP_NOTIFY_CEASE, "Cease"},
};
int Bgp::bgp_notify_msg_max = BGP_NOTIFY_MAX;

struct message Bgp::bgp_notify_head_msg[] = 
{
  { 0, "null"},
  { BGP_NOTIFY_HEADER_NOT_SYNC, "/Connection Not Synchronized."},
  { BGP_NOTIFY_HEADER_BAD_MESLEN, "/Bad Message Length."},
  { BGP_NOTIFY_HEADER_BAD_MESTYPE, "/Bad Message Type."}
};
int Bgp::bgp_notify_head_msg_max = BGP_NOTIFY_HEADER_MAX;

struct message Bgp::bgp_notify_open_msg[] = 
{
  { 0, "null" },
  { BGP_NOTIFY_OPEN_UNSUP_VERSION, "/Unsupported Version Number." },
  { BGP_NOTIFY_OPEN_BAD_PEER_AS, "/Bad Peer AS."},
  { BGP_NOTIFY_OPEN_BAD_BGP_IDENT, "/Bad BGP Identifier."},
  { BGP_NOTIFY_OPEN_UNSUP_PARAM, "/Unsupported Optional Parameter."},
  { BGP_NOTIFY_OPEN_AUTH_FAILURE, "/Authentication Failure."},
  { BGP_NOTIFY_OPEN_UNACEP_HOLDTIME, "/Unacceptable Hold Time."}, 
  { BGP_NOTIFY_OPEN_UNSUP_CAPBL, "/Unsupported Capability."},
};
int Bgp::bgp_notify_open_msg_max = BGP_NOTIFY_OPEN_MAX;

struct message Bgp::bgp_notify_update_msg[] = 
{
  { 0, "null"}, 
  { BGP_NOTIFY_UPDATE_MAL_ATTR, "/Malformed Attribute List."},
  { BGP_NOTIFY_UPDATE_UNREC_ATTR, "/Unrecognized Well-known Attribute."},
  { BGP_NOTIFY_UPDATE_MISS_ATTR, "/Missing Well-known Attribute."},
  { BGP_NOTIFY_UPDATE_ATTR_FLAG_ERR, "/Attribute Flags Error."},
  { BGP_NOTIFY_UPDATE_ATTR_LENG_ERR, "/Attribute Length Error."},
  { BGP_NOTIFY_UPDATE_INVAL_ORIGIN, "/Invalid ORIGIN Attribute."},
  { BGP_NOTIFY_UPDATE_AS_ROUTE_LOOP, "/AS Routing Loop."},
  { BGP_NOTIFY_UPDATE_INVAL_NEXT_HOP, "/Invalid NEXT_HOP Attribute."},
  { BGP_NOTIFY_UPDATE_OPT_ATTR_ERR, "/Optional Attribute Error."},
  { BGP_NOTIFY_UPDATE_INVAL_NETWORK, "/Invalid Network Field."},
  { BGP_NOTIFY_UPDATE_MAL_AS_PATH, "/Malformed AS_PATH."},
};
int Bgp::bgp_notify_update_msg_max = BGP_NOTIFY_UPDATE_MAX;

/* Origin strings. */
char *Bgp::bgp_origin_str[] = {"i","e","?"};
char *Bgp::bgp_origin_long_str[] = {"IGP","EGP","incomplete"};

/* Finite State Machine structure */
struct fsm_struct Bgp::FSM [BGP_STATUS_MAX - 1][BGP_EVENTS_MAX - 1] = 
{
  {
    /* Idle state: In Idle state, all events other than BGP_Start is
       ignored.  With BGP_Start event, finite state machine calls
       bgp_start(). */
    {&Bgp::bgp_start,  Connect},	/* BGP_Start                    */
    {&Bgp::bgp_stop,   Idle},		/* BGP_Stop                     */
    {&Bgp::bgp_stop,   Idle},		/* TCP_connection_open          */
    {&Bgp::bgp_stop,   Idle},		/* TCP_connection_closed        */
    {&Bgp::bgp_ignore, Idle},		/* TCP_connection_open_failed   */
    {&Bgp::bgp_stop,   Idle},		/* TCP_fatal_error              */
    {&Bgp::bgp_ignore, Idle},		/* ConnectRetry_timer_expired   */
    {&Bgp::bgp_ignore, Idle},		/* Hold_Timer_expired           */
    {&Bgp::bgp_ignore, Idle},		/* KeepAlive_timer_expired      */
    {&Bgp::bgp_ignore, Idle},		/* Receive_OPEN_message         */
    {&Bgp::bgp_ignore, Idle},		/* Receive_KEEPALIVE_message    */
    {&Bgp::bgp_ignore, Idle},		/* Receive_UPDATE_message       */
    {&Bgp::bgp_ignore, Idle},		/* Receive_NOTIFICATION_message */
  },
  {
    /* Connect */
    {&Bgp::bgp_ignore,  Connect},	/* BGP_Start                    */
    {&Bgp::bgp_stop,    Idle},	/* BGP_Stop                     */
    {&Bgp::bgp_connect_success, OpenSent}, /* TCP_connection_open          */
    {&Bgp::bgp_stop, Idle},		/* TCP_connection_closed        */
    {&Bgp::bgp_connect_fail, Active}, /* TCP_connection_open_failed   */
    {&Bgp::bgp_connect_fail, Idle},	/* TCP_fatal_error              */
    {&Bgp::bgp_reconnect, Connect},	/* ConnectRetry_timer_expired   */
    {&Bgp::bgp_ignore,  Idle},	/* Hold_Timer_expired           */
    {&Bgp::bgp_ignore,  Idle},	/* KeepAlive_timer_expired      */
    {&Bgp::bgp_ignore,  Idle},	/* Receive_OPEN_message         */
    {&Bgp::bgp_ignore,  Idle},	/* Receive_KEEPALIVE_message    */
    {&Bgp::bgp_ignore,  Idle},	/* Receive_UPDATE_message       */
    {&Bgp::bgp_stop,    Idle},	/* Receive_NOTIFICATION_message */
  },
  {
    /* Active, */
    {&Bgp::bgp_ignore,  Active},	/* BGP_Start                    */
    {&Bgp::bgp_stop,    Idle},	/* BGP_Stop                     */
    {&Bgp::bgp_connect_success, OpenSent}, /* TCP_connection_open          */
    {&Bgp::bgp_stop,    Idle},	/* TCP_connection_closed        */
    {&Bgp::bgp_ignore,  Active},	/* TCP_connection_open_failed   */
    {&Bgp::bgp_ignore,  Idle},	/* TCP_fatal_error              */
    {&Bgp::bgp_start,   Connect},	/* ConnectRetry_timer_expired   */
    {&Bgp::bgp_ignore,  Idle},	/* Hold_Timer_expired           */
    {&Bgp::bgp_ignore,  Idle},	/* KeepAlive_timer_expired      */
    {&Bgp::bgp_ignore,  Idle},	/* Receive_OPEN_message         */
    {&Bgp::bgp_ignore,  Idle},	/* Receive_KEEPALIVE_message    */
    {&Bgp::bgp_ignore,  Idle},	/* Receive_UPDATE_message       */
    {&Bgp::bgp_stop_with_error, Idle}, /* Receive_NOTIFICATION_message */
  },
  {
    /* OpenSent, */
    {&Bgp::bgp_ignore,  OpenSent},	/* BGP_Start                    */
    {&Bgp::bgp_stop,    Idle},	/* BGP_Stop                     */
    {&Bgp::bgp_stop,    Idle},	/* TCP_connection_open          */
    {&Bgp::bgp_stop,    Active},	/* TCP_connection_closed        */
    {&Bgp::bgp_ignore,  Idle},	/* TCP_connection_open_failed   */
    {&Bgp::bgp_stop,    Idle},	/* TCP_fatal_error              */
    {&Bgp::bgp_ignore,  Idle},	/* ConnectRetry_timer_expired   */
    {&Bgp::fsm_holdtime_expire, Idle},	/* Hold_Timer_expired           */
    {&Bgp::bgp_ignore,  Idle},	/* KeepAlive_timer_expired      */
    {&Bgp::fsm_open,    OpenConfirm},	/* Receive_OPEN_message         */
    {&Bgp::bgp_ignore,  Idle},	/* Receive_KEEPALIVE_message    */
    {&Bgp::bgp_ignore,  Idle},	/* Receive_UPDATE_message       */
    {&Bgp::bgp_stop_with_error, Idle}, /* Receive_NOTIFICATION_message */
  },
  {
    /* OpenConfirm, */
    {&Bgp::bgp_ignore,  OpenConfirm},	/* BGP_Start                    */
    {&Bgp::bgp_stop,    Idle},	/* BGP_Stop                     */
    {&Bgp::bgp_stop,    Idle},	/* TCP_connection_open          */
    {&Bgp::bgp_stop,    Idle},	/* TCP_connection_closed        */
    {&Bgp::bgp_stop,    Idle},	/* TCP_connection_open_failed   */
    {&Bgp::bgp_stop,    Idle},	/* TCP_fatal_error              */
    {&Bgp::bgp_ignore,  Idle},	/* ConnectRetry_timer_expired   */
    {&Bgp::fsm_holdtime_expire, Idle},	/* Hold_Timer_expired           */
    {&Bgp::bgp_ignore,  OpenConfirm},	/* KeepAlive_timer_expired      */
    {&Bgp::bgp_ignore,  Idle},	/* Receive_OPEN_message         */
    {&Bgp::bgp_establish, Established}, /* Receive_KEEPALIVE_message    */
    {&Bgp::bgp_ignore,  Idle},	/* Receive_UPDATE_message       */
    {&Bgp::bgp_stop_with_error, Idle}, /* Receive_NOTIFICATION_message */
  },
  {
    /* Established, */
    {&Bgp::bgp_ignore,  Established},	/* BGP_Start                    */
    {&Bgp::bgp_stop,    Idle},	/* BGP_Stop                     */
    {&Bgp::bgp_stop,    Idle},	/* TCP_connection_open          */
    {&Bgp::bgp_stop,    Idle},	/* TCP_connection_closed        */
    {&Bgp::bgp_ignore,  Idle},	/* TCP_connection_open_failed   */
    {&Bgp::bgp_stop,    Idle},	/* TCP_fatal_error              */
    {&Bgp::bgp_ignore,  Idle},	/* ConnectRetry_timer_expired   */
    {&Bgp::fsm_holdtime_expire, Idle}, /* Hold_Timer_expired           */
    {&Bgp::fsm_keepalive_expire, Established}, /* KeepAlive_timer_expired      */
    {&Bgp::bgp_stop, Idle},		/* Receive_OPEN_message         */
    {&Bgp::fsm_keepalive, Established}, /* Receive_KEEPALIVE_message    */
    {&Bgp::fsm_update,   Established}, /* Receive_UPDATE_message       */
    {&Bgp::bgp_stop_with_error, Idle}, /* Receive_NOTIFICATION_message */
  },
};


char *Bgp::bgp_event_str[] =
{
  NULL,
  "BGP_Start",
  "BGP_Stop",
  "TCP_connection_open",
  "TCP_connection_closed",
  "TCP_connection_open_failed",
  "TCP_fatal_error",
  "ConnectRetry_timer_expired",
  "Hold_Timer_expired",
  "KeepAlive_timer_expired",
  "Receive_OPEN_message",
  "Receive_KEEPALIVE_message",
  "Receive_UPDATE_message",
  "Receive_NOTIFICATION_message"
};


/* Route map commands for ip address matching. */
struct route_map_rule_cmd Bgp::route_match_ip_address_cmd =
{
  "ip address",
  &Bgp::route_match_ip_address,
  &Bgp::route_match_ip_address_compile,
  &Bgp::route_match_ip_address_free
};

struct route_map_rule_cmd Bgp::route_match_ip_next_hop_cmd =
{
  "ip next-hop",
  &Bgp::route_match_ip_next_hop,
  &Bgp::route_match_ip_next_hop_compile,
  &Bgp::route_match_ip_next_hop_free
};

struct route_map_rule_cmd Bgp::route_match_ip_address_prefix_list_cmd =
{
  "ip address prefix-list",
  &Bgp::route_match_ip_address_prefix_list,
  &Bgp::route_match_ip_address_prefix_list_compile,
  &Bgp::route_match_ip_address_prefix_list_free
};

struct route_map_rule_cmd Bgp::route_match_ip_next_hop_prefix_list_cmd =
{
  "ip next-hop prefix-list",
  &Bgp::route_match_ip_next_hop_prefix_list,
  &Bgp::route_match_ip_next_hop_prefix_list_compile,
  &Bgp::route_match_ip_next_hop_prefix_list_free
};

/* Route map commands for metric matching. */
struct route_map_rule_cmd Bgp::route_match_metric_cmd =
{
  "metric",
  &Bgp::route_match_metric,
  &Bgp::route_match_metric_compile,
  &Bgp::route_match_metric_free
};

/* Route map commands for community matching. */
struct route_map_rule_cmd Bgp::route_match_community_cmd = 
{
  "community",
  &Bgp::route_match_community,
  &Bgp::route_match_community_compile,
  &Bgp::route_match_community_free
};

/* Route map commands for aspath matching. */
struct route_map_rule_cmd Bgp::route_match_aspath_cmd = 
{
  "as-path",
  &Bgp::route_match_aspath,
  &Bgp::route_match_aspath_compile,
  &Bgp::route_match_aspath_free
};

struct route_map_rule_cmd Bgp::route_set_aggregator_as_cmd = 
{
  "aggregator as",
  &Bgp::route_set_aggregator_as,
  &Bgp::route_set_aggregator_as_compile,
  &Bgp::route_set_aggregator_as_free,
};

/* Set metric rule structure. */
struct route_map_rule_cmd Bgp::route_set_aspath_prepend_cmd = 
{
  "as-path prepend",
  &Bgp::route_set_aspath_prepend,
  &Bgp::route_set_aspath_prepend_compile,
  &Bgp::route_set_aspath_prepend_free,
};

/* Set atomic aggregate rule structure. */
struct route_map_rule_cmd Bgp::route_set_atomic_aggregate_cmd = 
{
  "atomic-aggregate",
  &Bgp::route_set_atomic_aggregate,
  &Bgp::route_set_atomic_aggregate_compile,
  &Bgp::route_set_atomic_aggregate_free,
};


/* Set community rule structure. */
struct route_map_rule_cmd Bgp::route_set_community_additive_cmd = 
{
  "community-additive",
  &Bgp::route_set_community_additive,
  &Bgp::route_set_community_additive_compile,
  &Bgp::route_set_community_additive_free,
};


/* Set community rule structure. */
struct route_map_rule_cmd Bgp::route_set_community_cmd = 
{
  "community",
  &Bgp::route_set_community,
  &Bgp::route_set_community_compile,
  &Bgp::route_set_community_free,
};

/* Set community rule structure. */
struct route_map_rule_cmd Bgp::route_set_community_delete_cmd =
{
  "community-delete",
  &Bgp::route_set_community_delete,
  &Bgp::route_set_community_delete_compile,
  &Bgp::route_set_community_delete_free,
};


/* Set community rule structure. */
struct route_map_rule_cmd Bgp::route_set_ecommunity_rt_cmd = 
{
  "extcommunity rt",
  &Bgp::route_set_ecommunity_rt,
  &Bgp::route_set_ecommunity_rt_compile,
  &Bgp::route_set_ecommunity_rt_free,
};

/* Set community rule structure. */
struct route_map_rule_cmd Bgp::route_set_ecommunity_soo_cmd = 
{
  "extcommunity soo",
  &Bgp::route_set_ecommunity_soo,
  &Bgp::route_set_ecommunity_soo_compile,
  &Bgp::route_set_ecommunity_soo_free,
};


/* Route map commands for ip nexthop set. */
struct route_map_rule_cmd Bgp::route_set_ip_nexthop_cmd =
{
  "ip next-hop",
  &Bgp::route_set_ip_nexthop,
  &Bgp::route_set_ip_nexthop_compile,
  &Bgp::route_set_ip_nexthop_free
};

/* Set local preference rule structure. */
struct route_map_rule_cmd Bgp::route_set_local_pref_cmd = 
{
  "local-preference",
  &Bgp::route_set_local_pref,
  &Bgp::route_set_local_pref_compile,
  &Bgp::route_set_local_pref_free,
};

/* Set metric rule structure. */
struct route_map_rule_cmd Bgp::route_set_metric_cmd = 
{
  "metric",
  &Bgp::route_set_metric,
  &Bgp::route_set_metric_compile,
  &Bgp::route_set_metric_free,
};

/* Set metric rule structure. */
struct route_map_rule_cmd Bgp::route_set_origin_cmd = 
{
  "origin",
  &Bgp::route_set_origin,
  &Bgp::route_set_origin_compile,
  &Bgp::route_set_origin_free,
};

/* Set metric rule structure. */
struct route_map_rule_cmd Bgp::route_set_originator_id_cmd = 
{
  "originator-id",
  &Bgp::route_set_originator_id,
  &Bgp::route_set_originator_id_compile,
  &Bgp::route_set_originator_id_free,
};

/* Set local preference rule structure. */
struct route_map_rule_cmd Bgp::route_set_weight_cmd = 
{
  "weight",
  &Bgp::route_set_weight,
  &Bgp::route_set_weight_compile,
  &Bgp::route_set_weight_free,
};

struct cmd_node Bgp::config_node =
{
  CONFIG_NODE,
  "%s(config)# ",
  1
};

/* Route map node structure. */
struct cmd_node Bgp::rmap_node =
{
  RMAP_NODE,
  "%s(config-route-map)# ",
  1
};

char *Bgp::zlog_proto_names[] = 
{
  "NONE",
  "DEFAULT",
  "ZEBRA",
  "RIP",
  "BGP",
  "OSPF",
  "RIPNG",
  "OSPF6",
  "MASC",
  NULL,
};

char *Bgp::zlog_priority [] =
  {
  "emergencies",
  "alerts",
  "critical",
  "errors",
  "warnings",
  "notifications",
  "informational",
  "debugging",
  NULL
  } ;
  
struct message Bgp::mstr [] =
{
  { MTYPE_THREAD, "thread" },
  { MTYPE_THREAD_MASTER, "thread_master" },
  { MTYPE_VECTOR, "vector" },
  { MTYPE_VECTOR_INDEX, "vector_index" },
  { MTYPE_IF, "interface" },
  { 0, NULL },
};

struct memory_list Bgp::memory_list_lib[] =
{
  { MTYPE_TMP,                "Temporary memory: %ld\n", 0},
  { MTYPE_ROUTE_TABLE,        "Route table     : %ld,%ld bytes\n", sizeof(struct bgp_table)},
  { MTYPE_ROUTE_NODE,         "Route node      : %ld,%ld bytes\n", sizeof(struct bgp_node)},
  { MTYPE_RIB,                "RIB             : %ld\n", 0},
  { MTYPE_NEXTHOP,            "Nexthop         : %ld\n", 0},
  { MTYPE_LINK_LIST,          "Link List       : %ld,%ld bytes\n", sizeof(struct llist)},
  { MTYPE_LINK_NODE,          "Link Node       : %ld,%ld bytes\n", sizeof(struct listnode)},
  { MTYPE_HASH,               "Hash            : %ld,%ld bytes\n", sizeof(struct Hash)},
  { MTYPE_HASH_BACKET,        "Hash Bucket     : %ld,%ld bytes\n", sizeof(struct HashBacket)},
  { MTYPE_ACCESS_LIST,        "Access List     : %ld,%ld bytes\n", sizeof(struct access_list)},
  { MTYPE_ACCESS_LIST_STR,    "Access List Str : %ld\n", 0},
  { MTYPE_ACCESS_FILTER,      "Access Filter   : %ld,%ld bytes\n", sizeof(struct filter)},
  { MTYPE_PREFIX_LIST,        "Prefix List     : %ld,%ld bytes\n", sizeof(struct prefix_list)},
  { MTYPE_PREFIX_LIST_STR,    "Prefix List Str : %ld\n", 0},
  { MTYPE_PREFIX_LIST_ENTRY,  "Prefix List Entry : %ld,%ld bytes\n",sizeof(struct prefix_list_entry)},
  { MTYPE_ROUTE_MAP,          "Route map       : %ld,%ld bytes\n", sizeof(struct route_map)},
  { MTYPE_ROUTE_MAP_NAME,     "Route map name  : %ld\n", 0},
  { MTYPE_ROUTE_MAP_INDEX,    "Route map index : %ld,%ld bytes\n", sizeof(struct route_map_index)},
  { MTYPE_ROUTE_MAP_RULE,     "Route map rule  : %ld,%ld bytes\n", sizeof(struct route_map_rule)},
  { MTYPE_ROUTE_MAP_RULE_STR, "Route map rule str: %ld\n", 0},
  { MTYPE_DESC,               "Command desc    : %ld,%ld bytes\n", sizeof(struct desc)},
  { MTYPE_BUFFER,             "Buffer          : %ld,%ld bytes\n", sizeof(struct buffer)},
  { MTYPE_BUFFER_DATA,        "Buffer data     : %ld,%ld bytes\n", sizeof(struct buffer_data)},
  { MTYPE_STREAM,             "Stream          : %ld,%ld bytes\n", sizeof(struct stream)},
  { MTYPE_KEYCHAIN,           "Key chain       : %ld\n", 0},
  { MTYPE_KEY,                "Key             : %ld\n", 0},
  { MTYPE_VTY,                "VTY             : %ld,%ld bytes\n", sizeof(struct vty)},
  { -1, NULL, 0}
};

struct memory_list Bgp::memory_list_bgp[] =
{

  { MTYPE_BGP,                "BGP route info  : %ld,%ld bytes\n", sizeof(struct bgp)},
  { MTYPE_BGP_PEER,           "BGP peer        : %ld,%ld bytes\n", sizeof(struct peer)},
  { MTYPE_PEER_CONF,          "BGP peer conf   : %ld,%ld bytes\n", sizeof(struct peer_conf)},
  { MTYPE_BGP_ROUTE,          "BGP route info  : %ld,%ld bytes\n", sizeof(struct bgp_info)},
  { MTYPE_ATTR,               "BGP attribute   : %ld,%ld bytes\n", sizeof(struct attr)},
#ifdef HAVE_ZEBRA_93b
  { MTYPE_BGP_ADVERTISE,      "BGP adv info    : %ld,%ld bytes\n", sizeof(struct bgp_advertise_attr)},
  { MTYPE_BGP_ADJ_OUT,        "BGP adj out     : %ld,%ld bytes\n", sizeof(struct bgp_adj_out)},
  { MTYPE_BGP_ADJ_IN,         "BGP adj in      : %ld,%ld bytes\n", sizeof(struct bgp_adj_in)},
#endif
  { MTYPE_AS_PATH,            "BGP aspath      : %ld,%ld bytes\n", sizeof(struct aspath)},
  { MTYPE_AS_SEG,             "BGP aspath seg  : %ld\n", 0},
  { MTYPE_AS_STR,             "BGP aspath str  : %ld\n", 0},
  { 0,                        "---------------------\n", 0},
  { MTYPE_AS_LIST,            "BGP as list     : %ld,%ld bytes\n", sizeof(struct as_list)},
  { MTYPE_AS_FILTER,          "BGP as filter   : %ld,%ld bytes\n", sizeof(struct as_filter)},
  { MTYPE_AS_FILTER_STR,      "BGP as filter str %ld\n", 0},
  { 0,                        "---------------------\n", 0},
  { MTYPE_COMMUNITY,          "Community       : %ld,%ld bytes\n", sizeof(struct community)},
  { MTYPE_COMMUNITY_VAL,      "Community val   : %ld\n", 0},
  { 0,                        "---------------------\n", 0},
  { MTYPE_CLUSTER,            "Cluster list    : %ld,%ld bytes\n", sizeof(struct cluster_list)},
  { MTYPE_CLUSTER_VAL,        "Cluster list val: %ld\n", 0},
  { 0,                        "---------------------\n", 0},
  { MTYPE_TRANSIT,            "BGP transit attr: %ld,%ld bytes\n", sizeof(struct transit)},
  { MTYPE_TRANSIT_VAL,        "BGP transit val : %ld\n", 0},
  { 0,                        "---------------------\n", 0},
  { MTYPE_BGP_DISTANCE,       "BGP distance    : %ld,%ld bytes\n", sizeof(struct bgp_distance)},
  { MTYPE_BGP_NEXTHOP_CACHE,  "BGP nexthop cache:%ld\n", 0},
  { -1, NULL, 0}
};

struct memory_list Bgp::memory_list_separator[] =
{
  { 0,"---------------------\n", 0},
  {-1, NULL, 0}
};

/* Maskbit. */
u_char Bgp::maskbit[] = {0x00, 0x80, 0xc0, 0xe0, 0xf0,
			         0xf8, 0xfc, 0xfe, 0xff};
char* Bgp::progname = "BGP++";  

struct _vector* Bgp::cmdvec;
struct _vector* Bgp::route_match_vec;
struct _vector* Bgp::route_set_vec;
bool Bgp::cmdvec_init=1;
bool Bgp::bgp_attr_initialize = 1;

struct Hash* Bgp::ashash; 
struct Hash* Bgp::cluster_hash;
struct Hash* Bgp::transit_hash;      
struct Hash* Bgp::attrhash;
struct Hash* Bgp::comhash;
struct Hash* Bgp::ecomhash;

/* Structures used for Convergence Detection*/
#define CONV_DET_DEBUG	0
map <string, int> event_map;
int total_events=0;
map<pair<string, int>, int> mrai_map;
struct logical_stamp *ls_array[10];
string event_prefix[10];
struct logical_stamp
{
	map<int, int> process_queue;
	map<int, int> network_queue;
};	

std::vector<struct bgp *> bgp_instances(20,NULL);

DEFUNST (ip_community_list,
	 ip_community_list_cmd,
	 "ip community-list WORD (deny|permit) .AA:NN",
	 IP_STR
	 "Add a community list entry\n"
	 "Community list name\n"
	 "Specify community to reject\n"
	 "Specify community to accept\n"
	 "Community number in aa:nn format or local-AS|no-advertise|no-export\n")
 

DEFUNST (no_ip_community_list,
	   no_ip_community_list_cmd,
	   "no ip community-list WORD (deny|permit) .AA:NN",
	   NO_STR
	   IP_STR
	   "Add a community list entry\n"
	   "Community list name\n"
	   "Specify community to reject\n"
	   "Specify community to accept\n"
	   "Community number in aa:nn format or local-AS|no-advertise|no-export\n")


  DEFUNST (no_ip_community_list_all,
	   no_ip_community_list_all_cmd,
	   "no ip community-list WORD",
	   NO_STR
	   IP_STR
	   "Add a community list entry\n"
	   "Community list name\n")


  DEFUNST (debug_bgp_fsm,
	   debug_bgp_fsm_cmd,
	   "debug bgp fsm",
	   DEBUG_STR
	   BGP_STR
	   "BGP Finite State Machine\n")



  DEFUNST (no_debug_bgp_fsm,
	   no_debug_bgp_fsm_cmd,
	   "no debug bgp fsm",
	   NO_STR
	   DEBUG_STR
	   BGP_STR
	   "Finite State Machine\n")


  DEFUNST (debug_bgp_events,
	   debug_bgp_events_cmd,
	   "debug bgp events",
	   DEBUG_STR
	   BGP_STR
	   "BGP events\n")


  DEFUNST (no_debug_bgp_events,
	   no_debug_bgp_events_cmd,
	   "no debug bgp events",
	   NO_STR
	   DEBUG_STR
	   BGP_STR
	   "BGP events\n")


  DEFUNST (debug_bgp_filter,
	   debug_bgp_filter_cmd,
	   "debug bgp filters",
	   DEBUG_STR
	   BGP_STR
	   "BGP filters\n")


  DEFUNST (no_debug_bgp_filter,
	   no_debug_bgp_filter_cmd,
	   "no debug bgp filters",
	   NO_STR
	   DEBUG_STR
	   BGP_STR
	   "BGP filters\n")

  DEFUNST (debug_bgp_keepalive,
	   debug_bgp_keepalive_cmd,
	   "debug bgp keepalives",
	   DEBUG_STR
	   BGP_STR
	   "BGP keepalives\n")


  DEFUNST (no_debug_bgp_keepalive,
	   no_debug_bgp_keepalive_cmd,
	   "no debug bgp keepalives",
	   NO_STR
	   DEBUG_STR
	   BGP_STR
	   "BGP keepalives\n")


  DEFUNST (debug_bgp_update,
	   debug_bgp_update_cmd,
	   "debug bgp updates",
	   DEBUG_STR
	   BGP_STR
	   "BGP updates\n")

  DEFUNST (debug_bgp_update_direct,
	   debug_bgp_update_direct_cmd,
	   "debug bgp updates (in|out)",
	   DEBUG_STR
	   BGP_STR
	   "BGP updates\n"
	   "Inbound updates\n"
	   "Outbound updates\n")


  DEFUNST (no_debug_bgp_update,
	   no_debug_bgp_update_cmd,
	   "no debug bgp updates",
	   NO_STR
	   DEBUG_STR
	   BGP_STR
	   "BGP updates\n")

  DEFUNST (debug_bgp_normal,
	   debug_bgp_normal_cmd,
	   "debug bgp",
	   DEBUG_STR
	   BGP_STR)


  DEFUNST (no_debug_bgp_normal,
	   no_debug_bgp_normal_cmd,
	   "no debug bgp",
	   NO_STR
	   DEBUG_STR
	   BGP_STR)


  DEFUNST (no_debug_bgp_all,
	   no_debug_bgp_all_cmd,
	   "no debug all bgp",
	   NO_STR
	   DEBUG_STR
	   "Enable all debugging\n"
	   BGP_STR)


  DEFUNST (show_debugging_bgp,
	   show_debugging_bgp_cmd,
	   "show debugging bgp",
	   SHOW_STR
	   DEBUG_STR
	   BGP_STR)


  DEFUNST (dump_bgp_all,
	   dump_bgp_all_cmd,
	   "dump bgp all PATH",
	   "Dump packet\n"
	   "BGP packet dump\n"
	   "Dump all BGP packets\n"
	   "Output filename\n")


  DEFUNST (dump_bgp_all_interval,
	   dump_bgp_all_interval_cmd,
	   "dump bgp all PATH INTERVAL",
	   "Dump packet\n"
	   "BGP packet dump\n"
	   "Dump all BGP packets\n"
	   "Output filename\n"
	   "Interval of output\n")


  DEFUNST (no_dump_bgp_all,
	   no_dump_bgp_all_cmd,
	   "no dump bgp all [PATH] [INTERVAL]",
	   NO_STR
	   "Dump packet\n"
	   "BGP packet dump\n"
	   "Dump all BGP packets\n")


  DEFUNST (dump_bgp_updates,
	   dump_bgp_updates_cmd,
	   "dump bgp updates PATH",
	   "Dump packet\n"
	   "BGP packet dump\n"
	   "Dump BGP updates only\n"
	   "Output filename\n")


  DEFUNST (dump_bgp_updates_interval,
	   dump_bgp_updates_interval_cmd,
	   "dump bgp updates PATH INTERVAL",
	   "Dump packet\n"
	   "BGP packet dump\n"
	   "Dump BGP updates only\n"
	   "Output filename\n"
	   "Interval of output\n")


  DEFUNST (no_dump_bgp_updates,
	   no_dump_bgp_updates_cmd,
	   "no dump bgp updates [PATH] [INTERVAL]",
	   NO_STR
	   "Dump packet\n"
	   "BGP packet dump\n"
	   "Dump BGP updates only\n")


  DEFUNST (dump_bgp_routes_interval,
	   dump_bgp_routes_interval_cmd,
	   "dump bgp routes-mrt PATH INTERVAL",
	   "Dump packet\n"
	   "BGP packet dump\n"
	   "Dump whole BGP routing table\n"
	   "Output filename\n"
	   "Interval of output\n")


  DEFUNST (no_dump_bgp_routes,
	   no_dump_bgp_routes_cmd,
	   "no dump bgp routes-mrt [PATH] [INTERVAL]",
	   NO_STR
	   "Dump packet\n"
	   "BGP packet dump\n"
	   "Dump whole BGP routing table\n")


  DEFUNST (ip_as_path, 
	   ip_as_path_cmd,
	   "ip as-path access-list WORD (deny|permit) .LINE",
	   IP_STR
	   "BGP autonomous system path filter\n"
	   "Specify an access list name\n"
	   "Regular expression access list name\n"
	   "Specify packets to reject\n"
	   "Specify packets to forward\n"
	   "A regular-expression to match the BGP AS paths\n")


  DEFUNST (no_ip_as_path,
	   no_ip_as_path_cmd,
	   "no ip as-path access-list WORD (deny|permit) .LINE",
	   NO_STR
	   IP_STR
	   "BGP autonomous system path filter\n"
	   "Specify an access list name\n"
	   "Regular expression access list name\n"
	   "Specify packets to reject\n"
	   "Specify packets to forward\n"
	   "A regular-expression to match the BGP AS paths\n")

      
  DEFUNST (no_ip_as_path_all,
	   no_ip_as_path_all_cmd,
	   "no ip as-path access-list WORD",
	   NO_STR
	   IP_STR
	   "BGP autonomous system path filter\n"
	   "Specify an access list name\n"
	   "Regular expression access list name\n")

  DEFUNST (bgp_network,
	   bgp_network_cmd,
	   "network A.B.C.D/M",
	   "Specify a network to announce via BGP\n"
	   "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n")


  DEFUNST (bgp_network_mask,
	   bgp_network_mask_cmd,
	   "network A.B.C.D mask A.B.C.D",
	   "Specify a network to announce via BGP\n"
	   "Network number\n"
	   "Network mask\n"
	   "Network mask\n")


  DEFUNST (no_bgp_network,
	   no_bgp_network_cmd,
	   "no network A.B.C.D/M",
	   NO_STR
	   "Specify a network to announce via BGP\n"
	   "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n")


  DEFUNST (no_bgp_network_mask,
	   no_bgp_network_mask_cmd,
	   "no network A.B.C.D mask A.B.C.D",
	   NO_STR
	   "Specify a network to announce via BGP\n"
	   "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n")



  DEFUNST (aggregate_address,
	   aggregate_address_cmd,
	   "aggregate-address A.B.C.D/M",
	   "Configure BGP aggregate entries\n"
	   "Aggregate prefix\n")

  DEFUNST (aggregate_address_mask,
	   aggregate_address_mask_cmd,
	   "aggregate-address A.B.C.D A.B.C.D",
	   "Configure BGP aggregate entries\n"
	   "Aggregate address\n"
	   "Aggregate mask\n")


  DEFUNST (aggregate_address_summary_only,
	   aggregate_address_summary_only_cmd,
	   "aggregate-address A.B.C.D/M summary-only",
	   "Configure BGP aggregate entries\n"
	   "Aggregate prefix\n"
	   "Filter more specific routes from updates\n")


  DEFUNST (aggregate_address_mask_summary_only,
	   aggregate_address_mask_summary_only_cmd,
	   "aggregate-address A.B.C.D A.B.C.D summary-only",
	   "Configure BGP aggregate entries\n"
	   "Aggregate address\n"
	   "Aggregate mask\n"
	   "Filter more specific routes from updates\n")


  DEFUNST (aggregate_address_as_set,
	   aggregate_address_as_set_cmd,
	   "aggregate-address A.B.C.D/M as-set",
	   "Configure BGP aggregate entries\n"
	   "Aggregate prefix\n"
	   "Generate AS set path information\n")


  DEFUNST (aggregate_address_mask_as_set,
	   aggregate_address_mask_as_set_cmd,
	   "aggregate-address A.B.C.D A.B.C.D as-set",
	   "Configure BGP aggregate entries\n"
	   "Aggregate address\n"
	   "Aggregate mask\n"
	   "Generate AS set path information\n")


  DEFUNST (aggregate_address_as_set_summary,
	   aggregate_address_as_set_summary_cmd,
	   "aggregate-address A.B.C.D/M as-set summary-only",
	   "Configure BGP aggregate entries\n"
	   "Aggregate prefix\n"
	   "Generate AS set path information\n"
	   "Filter more specific routes from updates\n")


  DEFUNST (aggregate_address_mask_as_set_summary,
	   aggregate_address_mask_as_set_summary_cmd,
	   "aggregate-address A.B.C.D A.B.C.D as-set summary-only",
	   "Configure BGP aggregate entries\n"
	   "Aggregate address\n"
	   "Aggregate mask\n"
	   "Generate AS set path information\n"
	   "Filter more specific routes from updates\n")


  DEFUNST (no_aggregate_address,
	   no_aggregate_address_cmd,
	   "no aggregate-address A.B.C.D/M",
	   NO_STR
	   "Configure BGP aggregate entries\n"
	   "Aggregate prefix\n")


  DEFUNST (no_aggregate_address_mask,
	   no_aggregate_address_mask_cmd,
	   "no aggregate-address A.B.C.D A.B.C.D",
	   NO_STR
	   "Configure BGP aggregate entries\n"
	   "Aggregate address\n"
	   "Aggregate mask\n")

  DEFUNST (show_ip_bgp,
	   show_ip_bgp_cmd,
	   "show ip bgp",
	   SHOW_STR
	   IP_STR
	   BGP_STR)


  DEFUNST (show_ip_bgp_route,
	   show_ip_bgp_route_cmd,
	   "show ip bgp A.B.C.D",
	   SHOW_STR
	   IP_STR
	   BGP_STR
	   "Network in the BGP routing table to display\n")


  DEFUNST (show_ip_bgp_prefix,
	   show_ip_bgp_prefix_cmd,
	   "show ip bgp A.B.C.D/M",
	   SHOW_STR
	   IP_STR
	   BGP_STR
	   "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n")


  DEFUNST (show_ip_bgp_regexp, 
	   show_ip_bgp_regexp_cmd,
	   "show ip bgp regexp .LINE",
	   SHOW_STR
	   IP_STR
	   BGP_STR
	   "Display routes matching the AS path regular expression\n"
	   "A regular-expression to match the BGP AS paths\n")


  DEFUNST (show_ip_bgp_prefix_list, 
	   show_ip_bgp_prefix_list_cmd,
	   "show ip bgp prefix-list WORD",
	   SHOW_STR
	   IP_STR
	   BGP_STR
	   "Display routes matching the prefix-list\n"
	   "IP prefix-list name\n")


  DEFUNST (show_ip_bgp_filter_list, 
	   show_ip_bgp_filter_list_cmd,
	   "show ip bgp filter-list WORD",
	   SHOW_STR
	   IP_STR
	   BGP_STR
	   "Display routes conforming to the filter-list\n"
	   "Regular expression access list name\n")


  DEFUNST (show_ip_bgp_cidr_only,
	   show_ip_bgp_cidr_only_cmd,
	   "show ip bgp cidr-only",
	   SHOW_STR
	   IP_STR
	   BGP_STR
	   "Display only routes with non-natural netmasks\n")


  DEFUNST (show_ip_bgp_community_all,
	   show_ip_bgp_community_all_cmd,
	   "show ip bgp community",
	   SHOW_STR
	   IP_STR
	   BGP_STR
	   "Display routes matching the communities\n")


  DEFUNST (show_ip_bgp_community,
	   show_ip_bgp_community_cmd,
	   "show ip bgp community (AA:NN|local-AS|no-advertise|no-export)",
	   SHOW_STR
	   IP_STR
	   BGP_STR
	   "Display routes matching the communities\n"
	   "community number\n"
	   "Do not send outside local AS (well-known community)\n"
	   "Do not advertise to any peer (well-known community)\n"
	   "Do not export to next AS (well-known community)\n")


  DEFUNST (show_ip_bgp_community_exact,
	   show_ip_bgp_community_exact_cmd,
	   "show ip bgp community (AA:NN|local-AS|no-advertise|no-export) exact-match",
	   SHOW_STR
	   IP_STR
	   BGP_STR
	   "Display routes matching the communities\n"
	   "community number\n"
	   "Do not send outside local AS (well-known community)\n"
	   "Do not advertise to any peer (well-known community)\n"
	   "Do not export to next AS (well-known community)\n"
	   "Exact match of the communities")


  DEFUNST (show_ip_bgp_community_list,
	   show_ip_bgp_community_list_cmd,
	   "show ip bgp community-list WORD",
	   SHOW_STR
	   IP_STR
	   BGP_STR
	   "Display routes matching the community-list\n"
	   "community-list name\n")

  DEFUNST (show_ip_bgp_community_list_exact,
	   show_ip_bgp_community_list_exact_cmd,
	   "show ip bgp community-list WORD exact-match",
	   SHOW_STR
	   IP_STR
	   BGP_STR
	   "Display routes matching the community-list\n"
	   "community-list name\n"
	   "Exact match of the communities\n")

  DEFUNST (show_ip_bgp_prefix_longer,
	   show_ip_bgp_prefix_longer_cmd,
	   "show ip bgp A.B.C.D/M longer-prefixes",
	   SHOW_STR
	   IP_STR
	   BGP_STR
	   "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
	   "Display route and more specific routes\n")


  DEFUNST (show_ip_bgp_neighbor_advertised_route,
	   show_ip_bgp_neighbor_advertised_route_cmd,
	   "show ip bgp neighbors (A.B.C.D|X:X::X:X) advertised-routes",
	   SHOW_STR
	   IP_STR
	   BGP_STR
	   "Detailed information on TCP and BGP neighbor connections\n"
	   "Neighbor to display information about\n"
	   "Neighbor to display information about\n"
	   "Display the routes advertised to a BGP neighbor\n")


  DEFUNST (show_ip_bgp_neighbor_received_routes,
	   show_ip_bgp_neighbor_received_routes_cmd,
	   "show ip bgp neighbors (A.B.C.D|X:X::X:X) received-routes",
	   SHOW_STR
	   IP_STR
	   BGP_STR
	   "Detailed information on TCP and BGP neighbor connections\n"
	   "Neighbor to display information about\n"
	   "Neighbor to display information about\n"
	   "Display the received routes from neighbor\n")


  DEFUNST (show_ip_bgp_neighbor_routes,
	   show_ip_bgp_neighbor_routes_cmd,
	   "show ip bgp neighbors (A.B.C.D|X:X::X:X) routes",
	   SHOW_STR
	   IP_STR
	   BGP_STR
	   "Detailed information on TCP and BGP neighbor connections\n"
	   "Neighbor to display information about\n"
	   "Neighbor to display information about\n"
	   "Display routes learned from neighbor\n")



  DEFUNST (bgp_distance,
	   bgp_distance_cmd,
	   "distance bgp <1-255> <1-255> <1-255>",
	   "Define an administrative distance\n"
	   "BGP distance\n"
	   "Distance for routes external to the AS\n"
	   "Distance for routes internal to the AS\n"
	   "Distance for local routes\n")


  DEFUNST (no_bgp_distance,
	   no_bgp_distance_cmd,
	   "no distance bgp <1-255> <1-255> <1-255>",
	   NO_STR
	   "Define an administrative distance\n"
	   "BGP distance\n"
	   "Distance for routes external to the AS\n"
	   "Distance for routes internal to the AS\n"
	   "Distance for local routes\n")



  DEFUNST (bgp_distance_source,
	   bgp_distance_source_cmd,
	   "distance <1-255> A.B.C.D/M",
	   "Define an administrative distance\n"
	   "Administrative distance\n"
	   "IP source prefix\n")



  DEFUNST (no_bgp_distance_source,
	   no_bgp_distance_source_cmd,
	   "no distance <1-255> A.B.C.D/M",
	   NO_STR
	   "Define an administrative distance\n"
	   "Administrative distance\n"
	   "IP source prefix\n")

  DEFUNST (bgp_distance_source_access_list,
	   bgp_distance_source_access_list_cmd,
	   "distance <1-255> A.B.C.D/M WORD",
	   "Define an administrative distance\n"
	   "Administrative distance\n"
	   "IP source prefix\n"
	   "Access list name\n")

  DEFUNST (no_bgp_distance_source_access_list,
	   no_bgp_distance_source_access_list_cmd,
	   "no distance <1-255> A.B.C.D/M WORD",
	   NO_STR
	   "Define an administrative distance\n"
	   "Administrative distance\n"
	   "IP source prefix\n"
	   "Access list name\n")


  DEFUNST (bgp_damp_set,
	   bgp_damp_set_cmd,
	   "bgp dampening <1-45> <1-20000> <1-20000> <1-255>",
	   "BGP Specific commands\n"
	   "Enable route-flap dampening\n"
	   "Half-lifedetime for the penalty\n"
	   "Value to start reusing a route\n"
	   "Value to start suppressing a route\n"
	   "Maximum duration to suppress a stable route\n")


  DEFUNST (bgp_damp_unset,
	   bgp_damp_unset_cmd,
	   "no bgp dampening",
	   NO_STR
	   "BGP Specific commands\n"
	   "Enable route-flap dampening\n")


  DEFUNST (match_ip_address, 
	   match_ip_address_cmd,
	   "match ip address WORD",
	   MATCH_STR
	   IP_STR
	   "Match address of route\n"
	   "IP access-list name\n")


  DEFUNST (no_match_ip_address, 
	   no_match_ip_address_cmd,
	   "no match ip address",
	   NO_STR
	   MATCH_STR
	   IP_STR
	   "Match address of route\n")


  DEFUNST (match_ip_next_hop, 
	   match_ip_next_hop_cmd,
	   "match ip next-hop WORD",
	   MATCH_STR
	   IP_STR
	   "Match next-hop address of route\n"
	   "IP access-list name\n")


  DEFUNST (no_match_ip_next_hop,
	   no_match_ip_next_hop_cmd,
	   "no match ip next-hop",
	   NO_STR
	   MATCH_STR
	   IP_STR
	   "Match next-hop address of route\n")


  DEFUNST (match_ip_address_prefix_list, 
	   match_ip_address_prefix_list_cmd,
	   "match ip address prefix-list WORD",
	   MATCH_STR
	   IP_STR
	   "Match address of route\n"
	   "Match entries of prefix-lists\n"
	   "IP prefix-list name\n")



  DEFUNST (no_match_ip_address_prefix_list,
	   no_match_ip_address_prefix_list_cmd,
	   "no match ip address prefix-list",
	   NO_STR
	   MATCH_STR
	   IP_STR
	   "Match address of route\n"
	   "Match entries of prefix-lists\n")


  DEFUNST (match_ip_next_hop_prefix_list, 
	   match_ip_next_hop_prefix_list_cmd,
	   "match ip next-hop prefix-list WORD",
	   MATCH_STR
	   IP_STR
	   "Match next-hop address of route\n"
	   "Match entries of prefix-lists\n"
	   "IP prefix-list name\n")


  DEFUNST (no_match_ip_next_hop_prefix_list,
	   no_match_ip_next_hop_prefix_list_cmd,
	   "no match ip next-hop prefix-list",
	   NO_STR
	   MATCH_STR
	   IP_STR
	   "Match next-hop address of route\n"
	   "Match entries of prefix-lists\n")


  DEFUNST (match_metric, 
	   match_metric_cmd,
	   "match metric <0-4294967295>",
	   MATCH_STR
	   "Match metric of route\n"
	   "Metric value\n")


  DEFUNST (no_match_metric,
	   no_match_metric_cmd,
	   "no match metric",
	   NO_STR
	   MATCH_STR
	   "Match metric of route\n")


  DEFUNST (match_community, 
	   match_community_cmd,
	   "match community WORD",
	   MATCH_STR
	   "Match BGP community list\n"
	   "Community-list name (not community value itself)\n")

  DEFUNST (no_match_community,
	   no_match_community_cmd,
	   "no match community",
	   NO_STR
	   MATCH_STR
	   "Match BGP community list\n")


  DEFUNST (match_aspath,
	   match_aspath_cmd,
	   "match as-path WORD",
	   MATCH_STR
	   "Match BGP AS path list\n"
	   "AS path access-list name\n")


  DEFUNST (no_match_aspath,
	   no_match_aspath_cmd,
	   "no match as-path",
	   NO_STR
	   MATCH_STR
	   "Match BGP AS path list\n")

  DEFUNST (set_ip_nexthop,
	   set_ip_nexthop_cmd,
	   "set ip next-hop A.B.C.D",
	   SET_STR
	   IP_STR
	   "Next hop address\n"
	   "IP address of next hop\n")


  DEFUNST (no_set_ip_nexthop,
	   no_set_ip_nexthop_cmd,
	   "no set ip next-hop",
	   NO_STR
	   SET_STR
	   IP_STR
	   "Next hop address\n")


  DEFUNST (set_metric,
	   set_metric_cmd,
	   "set metric (<0-4294967295>|<+/-metric>)",
	   SET_STR
	   "Metric value for destination routing protocol\n"
	   "Metric value\n"
	   "Add or subtract metric\n")


  DEFUNST (no_set_metric,
	   no_set_metric_cmd,
	   "no set metric",
	   NO_STR
	   SET_STR
	   "Metric value for destination routing protocol\n")


  DEFUNST (set_local_pref,
	   set_local_pref_cmd,
	   "set local-preference <0-4294967295>",
	   SET_STR
	   "BGP local preference path attribute\n"
	   "Preference value\n")


  DEFUNST (no_set_local_pref,
	   no_set_local_pref_cmd,
	   "no set local-preference",
	   NO_STR
	   SET_STR
	   "BGP local preference path attribute\n")


  DEFUNST (set_weight,
	   set_weight_cmd,
	   "set weight <0-4294967295>",
	   SET_STR
	   "BGP weight for routing table\n"
	   "Weight value\n")


  DEFUNST (no_set_weight,
	   no_set_weight_cmd,
	   "no set weight",
	   NO_STR
	   SET_STR
	   "BGP weight for routing table\n")


  DEFUNST (set_aspath_prepend,
	   set_aspath_prepend_cmd,
	   "set as-path prepend .<1-65535>",
	   SET_STR
	   "Prepend string for a BGP AS-path attribute\n"
	   "Prepend to the as-path\n"
	   "AS number\n")


  DEFUNST (no_set_aspath_prepend,
	   no_set_aspath_prepend_cmd,
	   "no set as-path prepend",
	   NO_STR
	   SET_STR
	   "Prepend string for a BGP AS-path attribute\n"
	   "Prepend to the as-path\n")

  DEFUNST (set_community,
	   set_community_cmd,
	   "set community .AA:NN",
	   SET_STR
	   "BGP community attribute\n"
	   "Community number in aa:nn format or local-AS|no-advertise|no-export\n")


  DEFUNST (no_set_community,
	   no_set_community_cmd,
	   "no set community",
	   NO_STR
	   SET_STR
	   "BGP community attribute\n")


  DEFUNST (set_community_additive,
	   set_community_additive_cmd,
	   "set community-additive .AA:NN",
	   SET_STR
	   "BGP community attribute (Add to the existing community)\n"
	   "Community number in aa:nn format or local-AS|no-advertise|no-export\n")


  DEFUNST (no_set_community_additive,
	   no_set_community_additive_cmd,
	   "no set community-additive",
	   NO_STR
	   SET_STR
	   "BGP community attribute (Add to the existing community)\n")


  DEFUNST (set_community_delete,
	   set_community_delete_cmd,
	   "set community-delete WORD",
	   SET_STR
	   "BGP community attribute (Delete from the existing community)\n"
	   "Community list (Permitted communities are deleted)\n")


  DEFUNST (no_set_community_delete,
	   no_set_community_delete_cmd,
	   "no set community-delete",
	   NO_STR
	   SET_STR
	   "BGP community attribute (Delete from existing community)\n")


  DEFUNST (set_ecommunity_rt,
	   set_ecommunity_rt_cmd,
	   "set extcommunity rt .ASN:nn_or_IP-address:nn",
	   SET_STR
	   "BGP extended community attribute\n"
	   "Route Target extened communityt\n"
	   "VPN extended community\n")


  DEFUNST (no_set_ecommunity_rt,
	   no_set_ecommunity_rt_cmd,
	   "no set extcommunity rt",
	   NO_STR
	   SET_STR
	   "BGP extended community attribute\n"
	   "Route Target extened communityt\n")


  DEFUNST (set_ecommunity_soo,
	   set_ecommunity_soo_cmd,
	   "set extcommunity soo .ASN:nn_or_IP-address:nn",
	   SET_STR
	   "BGP extended community attribute\n"
	   "Site-of-Origin extended community\n"
	   "VPN extended community\n")


  DEFUNST (no_set_ecommunity_soo,
	   no_set_ecommunity_soo_cmd,
	   "no set extcommunity soo",
	   NO_STR
	   SET_STR
	   "BGP extended community attribute\n"
	   "Site-of-Origin extended community\n")


  DEFUNST (set_origin,
	   set_origin_cmd,
	   "set origin (egp|igp|incomplete)",
	   SET_STR
	   "BGP origin code\n"
	   "remote EGP\n"
	   "local IGP\n"
	   "unknown heritage\n")


  DEFUNST (no_set_origin,
	   no_set_origin_cmd,
	   "no set origin",
	   NO_STR
	   SET_STR
	   "BGP origin code\n")



  DEFUNST (set_atomic_aggregate,
	   set_atomic_aggregate_cmd,
	   "set atomic-aggregate",
	   SET_STR
	   "BGP atomic aggregate attribute\n" )


  DEFUNST (no_set_atomic_aggregate,
	   no_set_atomic_aggregate_cmd,
	   "no set atomic-aggregate",
	   NO_STR
	   SET_STR
	   "BGP atomic aggregate attribute\n" )


  DEFUNST (set_aggregator_as,
	   set_aggregator_as_cmd,
	   "set aggregator as <1-65535> A.B.C.D",
	   SET_STR
	   "BGP aggregator attribute\n"
	   "AS number of aggregator\n"
	   "AS number\n"
	   "IP address of aggregator\n")


  DEFUNST (no_set_aggregator_as,
	   no_set_aggregator_as_cmd,
	   "no set aggregator as",
	   NO_STR
	   SET_STR
	   "BGP aggregator attribute\n"
	   "AS number of aggregator\n")


  DEFUNST (set_originator_id,
	   set_originator_id_cmd,
	   "set originator-id A.B.C.D",
	   SET_STR
	   "BGP originator ID attribute\n"
	   "IP address of originator\n")


  DEFUNST (no_set_originator_id,
	   no_set_originator_id_cmd,
	   "no set originator-id",
	   NO_STR
	   SET_STR
	   "BGP originator ID attribute\n")

  DEFUNST (bgp_router_id, 
	   bgp_router_id_cmd,
	   "bgp router-id A.B.C.D",
	   "BGP specific commands\n"
	   "Override configured router identifier\n"
	   "Manually configured router identifier\n")



  DEFUNST (no_bgp_router_id, 
	   no_bgp_router_id_cmd,
	   "no bgp router-id",
	   NO_STR
	   "BGP specific commands\n"
	   "Override configured router identifier\n")


  DEFUNST (bgp_timers, 
	   bgp_timers_cmd,
	   "timers bgp <0-65535> <0-65535>",
	   "Adjust routing timers\n"
	   "BGP timers\n"
	   "Keepalive interval\n"
	   "Holdtime\n")


  DEFUNST (no_bgp_timers, 
	   no_bgp_timers_cmd,
	   "no timers bgp",
	   NO_STR
	   "Adjust routing timers\n"
	   "BGP timers\n")


  DEFUNST (bgp_cluster_id, 
	   bgp_cluster_id_cmd,
	   "bgp cluster-id A.B.C.D",
	   "BGP specific commands\n"
	   "Configure Route-Reflector Cluster-id\n"
	   "Route-Reflector Cluster-id in IP address format\n")


  DEFUNST (no_bgp_cluster_id, 
	   no_bgp_cluster_id_cmd,
	   "no bgp cluster-id",
	   NO_STR
	   "BGP specific commands\n"
	   "Configure Route-Reflector Cluster-id\n")


  DEFUNST (bgp_confederation_peers, 
	   bgp_confederation_peers_cmd,
	   "bgp confederation peers .<1-65535>",
	   "BGP specific commands\n"
	   "AS confederation parameters\n"
	   "Peer ASs in BGP confederation\n"
	   AS_STR)


  DEFUNST (bgp_confederation_identifier, 
	   bgp_confederation_identifier_cmd,
	   "bgp confederation identifier <1-65535>",
	   "BGP specific commands\n"
	   "AS confederation parameters\n"
	   "AS number\n"
	   "Set routing domain confederation AS\n")


  DEFUNST (no_bgp_confederation_peers, 
	   no_bgp_confederation_peers_cmd,
	   "no bgp confederation peers .<1-65535>",
	   NO_STR
	   "BGP specific commands\n"
	   "AS confederation parameters\n"
	   "Peer ASs in BGP confederation\n"
	   AS_STR)


  DEFUNST (no_bgp_confederation_identifier, 
	   no_bgp_confederation_identifier_cmd,
	   "no bgp confederation identifier <1-65535>",
	   NO_STR
	   "BGP specific commands\n"
	   "AS confederation parameters\n"
	   "AS number\n"
	   "Set routing domain confederation AS\n")



  DEFUNST (no_bgp_client_to_client_reflection,
	   no_bgp_client_to_client_reflection_cmd,
	   "no bgp client-to-client reflection",
	   NO_STR
	   "BGP specific commands\n"
	   "Configure client to client route reflection\n"
	   "reflection of routes allowed\n")


  DEFUNST (bgp_client_to_client_reflection,
	   bgp_client_to_client_reflection_cmd,
	   "bgp client-to-client reflection",
	   "BGP specific commands\n"
	   "Configure client to client route reflection\n"
	   "reflection of routes allowed\n")


  DEFUNST (bgp_always_compare_med,
	   bgp_always_compare_med_cmd,
	   "bgp always-compare-med",
	   "BGP specific commands\n"
	   "Allow comparing MED from different neighbors\n")



  DEFUNST (no_bgp_always_compare_med,
	   no_bgp_always_compare_med_cmd,
	   "no bgp always-compare-med",
	   NO_STR
	   "BGP specific commands\n"
	   "Allow comparing MED from different neighbors\n")


  DEFUNST (bgp_deterministic_med,
	   bgp_deterministic_med_cmd,
	   "bgp deterministic-med",
	   "BGP specific commands\n"
	   "Pick the best-MED path among paths advertised from the neighboring AS\n")


  DEFUNST (no_bgp_deterministic_med,
	   no_bgp_deterministic_med_cmd,
	   "no bgp deterministic-med",
	   NO_STR
	   "BGP specific commands\n"
	   "Pick the best-MED path among paths advertised from the neighboring AS\n")


  DEFUNST (bgp_enforce_first_as,
	   bgp_enforce_first_as_cmd,
	   "bgp enforce-first-as",
	   BGP_STR
	   "Enforce the first AS for EBGP routes\n")

  DEFUNST (no_bgp_enforce_first_as,
	   no_bgp_enforce_first_as_cmd,
	   "no bgp enforce-first-as",
	   NO_STR
	   BGP_STR
	   "Enforce the first AS for EBGP routes\n")


  DEFUNST (bgp_bestpath_compare_router_id,
	   bgp_bestpath_compare_router_id_cmd,
	   "bgp bestpath compare-routerid",
	   "BGP specific commands\n"
	   "Change the default bestpath selection\n"
	   "Compare router-id for identical EBGP paths\n")


  DEFUNST (no_bgp_bestpath_compare_router_id,
	   no_bgp_bestpath_compare_router_id_cmd,
	   "no bgp bestpath compare-routerid",
	   NO_STR
	   "BGP specific commands\n"
	   "Change the default bestpath selection\n"
	   "Compare router-id for identical EBGP paths\n")


  DEFUNST (bgp_bestpath_aspath_ignore,
	   bgp_bestpath_aspath_ignore_cmd,
	   "bgp bestpath as-path ignore",
	   "BGP specific commands\n"
	   "Change the default bestpath selection\n"
	   "AS-path attribute\n"
	   "Ignore as-path length in selecting a route\n")


  DEFUNST (no_bgp_bestpath_aspath_ignore,
	   no_bgp_bestpath_aspath_ignore_cmd,
	   "no bgp bestpath as-path ignore",
	   NO_STR
	   "BGP specific commands\n"
	   "Change the default bestpath selection\n"
	   "AS-path attribute\n"
	   "Ignore as-path length in selecting a route\n")


  DEFUNST (bgp_bestpath_med,
	   bgp_bestpath_med_cmd,
	   "bgp bestpath med (confed|missing-as-worst)",
	   "BGP specific commands\n"
	   "Change the default bestpath selection\n"
	   "MED attribute\n"
	   "Compare MED among confederation paths\n"
	   "Treat missing MED as the least preferred one\n")


  DEFUNST (bgp_bestpath_med2,
	   bgp_bestpath_med2_cmd,
	   "bgp bestpath med confed missing-as-worst",
	   "BGP specific commands\n"
	   "Change the default bestpath selection\n"
	   "MED attribute\n"
	   "Compare MED among confederation paths\n"
	   "Treat missing MED as the least preferred one\n")

  DEFUNST (no_bgp_bestpath_med,
	   no_bgp_bestpath_med_cmd,
	   "no bgp bestpath med (confed|missing-as-worst)",
	   NO_STR
	   "BGP specific commands\n"
	   "Change the default bestpath selection\n"
	   "MED attribute\n"
	   "Compare MED among confederation paths\n"
	   "Treat missing MED as the least preferred one\n")


  DEFUNST (no_bgp_bestpath_med2,
	   no_bgp_bestpath_med2_cmd,
	   "no bgp bestpath med confed missing-as-worst",
	   NO_STR
	   "BGP specific commands\n"
	   "Change the default bestpath selection\n"
	   "MED attribute\n"
	   "Compare MED among confederation paths\n"
	   "Treat missing MED as the least preferred one\n")


  DEFUNST (bgp_default_local_preference,
	   bgp_default_local_preference_cmd,
	   "bgp default local-preference <0-4294967295>",
	   "BGP specific commands\n"
	   "Configure BGP defaults\n"
	   "local preference (higher=more preferred)\n"
	   "Configure default local preference value\n")


  DEFUNST (no_bgp_default_local_preference,
	   no_bgp_default_local_preference_cmd,
	   "no bgp default local-preference",
	   NO_STR
	   "BGP specific commands\n"
	   "Configure BGP defaults\n"
	   "local preference (higher=more preferred)\n")

  DEFUNST (router_bgp, 
	   router_bgp_cmd, 
	   "router bgp <1-65535>",
	   ROUTER_STR
	   BGP_STR
	   AS_STR)

  DEFUNST (show_startup_config,
	   show_startup_config_cmd,
	   "show startup-config",
	   SHOW_STR
	   "Contentes of startup configuration\n")

  DEFUNST (config_log_file,
	   config_log_file_cmd,
	   "log file FILENAME",
	   "Logging control\n"
	   "Logging to file\n"
	   "Logging filename\n")
  DEFUNST (no_config_log_file,
	   no_config_log_file_cmd,
	   "no log file [FILENAME]",
	   NO_STR
	   "Logging control\n"
	   "Cancel logging to file\n"
	   "Logging file name\n")

  DEFUNST (neighbor_advertise_interval,
	   neighbor_advertise_interval_cmd,
	   NEIGHBOR_CMD "advertisement-interval <0-600>",
	   NEIGHBOR_STR
	   NEIGHBOR_ADDR_STR
	   "Minimum interval between sending BGP routing updates\n"
	   "time in seconds\n")


  DEFUNST (no_neighbor_advertise_interval,
	   no_neighbor_advertise_interval_cmd,
	   NO_NEIGHBOR_CMD "advertisement-interval",
	   NO_STR
	   NEIGHBOR_STR
	   NEIGHBOR_ADDR_STR
	   "Minimum interval between sending BGP routing updates\n")

  ALIAS (no_debug_bgp_fsm,
	 undebug_bgp_fsm_cmd,
	 "undebug bgp fsm",
	 UNDEBUG_STR
	 DEBUG_STR
	 BGP_STR
	 "Finite State Machine\n")

  ALIAS (no_debug_bgp_events,
	 undebug_bgp_events_cmd,
	 "undebug bgp events",
	 UNDEBUG_STR
	 BGP_STR
	 "BGP events\n")

  ALIAS (no_debug_bgp_filter,
	 undebug_bgp_filter_cmd,
	 "undebug bgp filters",
	 UNDEBUG_STR
	 BGP_STR
	 "BGP filters\n")

  ALIAS (no_debug_bgp_keepalive,
	 undebug_bgp_keepalive_cmd,
	 "undebug bgp keepalives",
	 UNDEBUG_STR
	 BGP_STR
	 "BGP keepalives\n")

  ALIAS (no_debug_bgp_update,
	 undebug_bgp_update_cmd,
	 "undebug bgp updates",
	 UNDEBUG_STR
	 BGP_STR
	 "BGP updates\n")

  ALIAS (no_debug_bgp_normal,
	 undebug_bgp_normal_cmd,
	 "undebug bgp",
	 UNDEBUG_STR
	 BGP_STR)

  ALIAS (no_debug_bgp_all,
	 undebug_bgp_all_cmd,
	 "undebug all bgp",
	 UNDEBUG_STR
	 "Enable all debugging\n"
	 BGP_STR)

  ALIAS (bgp_network_mask,
	 bgp_network_mask_natural_cmd,
	 "network A.B.C.D",
	 "Specify a network to announce via BGP\n"
	 "Network number\n")

  ALIAS (no_bgp_network_mask,
	 no_bgp_network_mask_natural_cmd,
	 "no network A.B.C.D",
	 "Specify a network to announce via BGP\n"
	 "Network number\n")

  ALIAS (aggregate_address_as_set_summary,
	 aggregate_address_summary_as_set_cmd,
	 "aggregate-address A.B.C.D/M summary-only as-set",
	 "Configure BGP aggregate entries\n"
	 "Aggregate prefix\n"
	 "Filter more specific routes from updates\n"
	 "Generate AS set path information\n")


  ALIAS (aggregate_address_mask_as_set_summary,
	 aggregate_address_mask_summary_as_set_cmd,
	 "aggregate-address A.B.C.D A.B.C.D summary-only as-set",
	 "Configure BGP aggregate entries\n"
	 "Aggregate address\n"
	 "Aggregate mask\n"
	 "Filter more specific routes from updates\n"
	 "Generate AS set path information\n")


  ALIAS (no_aggregate_address,
	 no_aggregate_address_summary_only_cmd,
	 "no aggregate-address A.B.C.D/M summary-only",
	 NO_STR
	 "Configure BGP aggregate entries\n"
	 "Aggregate prefix\n"
	 "Filter more specific routes from updates\n")

  ALIAS (no_aggregate_address,
	 no_aggregate_address_as_set_cmd,
	 "no aggregate-address A.B.C.D/M as-set",
	 NO_STR
	 "Configure BGP aggregate entries\n"
	 "Aggregate prefix\n"
	 "Generate AS set path information\n")

  ALIAS (no_aggregate_address,
	 no_aggregate_address_as_set_summary_cmd,
	 "no aggregate-address A.B.C.D/M as-set summary-only",
	 NO_STR
	 "Configure BGP aggregate entries\n"
	 "Aggregate prefix\n"
	 "Generate AS set path information\n"
	 "Filter more specific routes from updates\n")

  ALIAS (no_aggregate_address,
	 no_aggregate_address_summary_as_set_cmd,
	 "no aggregate-address A.B.C.D/M summary-only as-set",
	 NO_STR
	 "Configure BGP aggregate entries\n"
	 "Aggregate prefix\n"
	 "Filter more specific routes from updates\n"
	 "Generate AS set path information\n")


  ALIAS (no_aggregate_address_mask,
	 no_aggregate_address_mask_summary_only_cmd,
	 "no aggregate-address A.B.C.D A.B.C.D summary-only",
	 NO_STR
	 "Configure BGP aggregate entries\n"
	 "Aggregate address\n"
	 "Aggregate mask\n"
	 "Filter more specific routes from updates\n")

  ALIAS (no_aggregate_address_mask,
	 no_aggregate_address_mask_as_set_cmd,
	 "no aggregate-address A.B.C.D A.B.C.D as-set",
	 NO_STR
	 "Configure BGP aggregate entries\n"
	 "Aggregate address\n"
	 "Aggregate mask\n"
	 "Generate AS set path information\n")

  ALIAS (no_aggregate_address_mask,
	 no_aggregate_address_mask_as_set_summary_cmd,
	 "no aggregate-address A.B.C.D A.B.C.D as-set summary-only",
	 NO_STR
	 "Configure BGP aggregate entries\n"
	 "Aggregate address\n"
	 "Aggregate mask\n"
	 "Generate AS set path information\n"
	 "Filter more specific routes from updates\n")

  ALIAS (no_aggregate_address_mask,
	 no_aggregate_address_mask_summary_as_set_cmd,
	 "no aggregate-address A.B.C.D A.B.C.D summary-only as-set",
	 NO_STR
	 "Configure BGP aggregate entries\n"
	 "Aggregate address\n"
	 "Aggregate mask\n"
	 "Filter more specific routes from updates\n"
	 "Generate AS set path information\n")

  ALIAS (show_ip_bgp_community,
	 show_ip_bgp_community2_cmd,
	 "show ip bgp community (AA:NN|local-AS|no-advertise|no-export) (AA:NN|local-AS|no-advertise|no-export)",
	 SHOW_STR
	 IP_STR
	 BGP_STR
	 "Display routes matching the communities\n"
	 "community number\n"
	 "Do not send outside local AS (well-known community)\n"
	 "Do not advertise to any peer (well-known community)\n"
	 "Do not export to next AS (well-known community)\n"
	 "community number\n"
	 "Do not send outside local AS (well-known community)\n"
	 "Do not advertise to any peer (well-known community)\n"
	 "Do not export to next AS (well-known community)\n")

  ALIAS (show_ip_bgp_community,
	 show_ip_bgp_community3_cmd,
	 "show ip bgp community (AA:NN|local-AS|no-advertise|no-export) (AA:NN|local-AS|no-advertise|no-export) (AA:NN|local-AS|no-advertise|no-export)",
	 SHOW_STR
	 IP_STR
	 BGP_STR
	 "Display routes matching the communities\n"
	 "community number\n"
	 "Do not send outside local AS (well-known community)\n"
	 "Do not advertise to any peer (well-known community)\n"
	 "Do not export to next AS (well-known community)\n"
	 "community number\n"
	 "Do not send outside local AS (well-known community)\n"
	 "Do not advertise to any peer (well-known community)\n"
	 "Do not export to next AS (well-known community)\n"
	 "community number\n"
	 "Do not send outside local AS (well-known community)\n"
	 "Do not advertise to any peer (well-known community)\n"
	 "Do not export to next AS (well-known community)\n")

  ALIAS (show_ip_bgp_community,
	 show_ip_bgp_community4_cmd,
	 "show ip bgp community (AA:NN|local-AS|no-advertise|no-export) (AA:NN|local-AS|no-advertise|no-export) (AA:NN|local-AS|no-advertise|no-export) (AA:NN|local-AS|no-advertise|no-export)",
	 SHOW_STR
	 IP_STR
	 BGP_STR
	 "Display routes matching the communities\n"
	 "community number\n"
	 "Do not send outside local AS (well-known community)\n"
	 "Do not advertise to any peer (well-known community)\n"
	 "Do not export to next AS (well-known community)\n"
	 "community number\n"
	 "Do not send outside local AS (well-known community)\n"
	 "Do not advertise to any peer (well-known community)\n"
	 "Do not export to next AS (well-known community)\n"
	 "community number\n"
	 "Do not send outside local AS (well-known community)\n"
	 "Do not advertise to any peer (well-known community)\n"
	 "Do not export to next AS (well-known community)\n"
	 "community number\n"
	 "Do not send outside local AS (well-known community)\n"
	 "Do not advertise to any peer (well-known community)\n"
	 "Do not export to next AS (well-known community)\n")


  ALIAS (show_ip_bgp_community_exact,
	 show_ip_bgp_community2_exact_cmd,
	 "show ip bgp community (AA:NN|local-AS|no-advertise|no-export) (AA:NN|local-AS|no-advertise|no-export) exact-match",
	 SHOW_STR
	 IP_STR
	 BGP_STR
	 "Display routes matching the communities\n"
	 "community number\n"
	 "Do not send outside local AS (well-known community)\n"
	 "Do not advertise to any peer (well-known community)\n"
	 "Do not export to next AS (well-known community)\n"
	 "community number\n"
	 "Do not send outside local AS (well-known community)\n"
	 "Do not advertise to any peer (well-known community)\n"
	 "Do not export to next AS (well-known community)\n"
	 "Exact match of the communities")

  ALIAS (show_ip_bgp_community_exact,
	 show_ip_bgp_community3_exact_cmd,
	 "show ip bgp community (AA:NN|local-AS|no-advertise|no-export) (AA:NN|local-AS|no-advertise|no-export) (AA:NN|local-AS|no-advertise|no-export) exact-match",
	 SHOW_STR
	 IP_STR
	 BGP_STR
	 "Display routes matching the communities\n"
	 "community number\n"
	 "Do not send outside local AS (well-known community)\n"
	 "Do not advertise to any peer (well-known community)\n"
	 "Do not export to next AS (well-known community)\n"
	 "community number\n"
	 "Do not send outside local AS (well-known community)\n"
	 "Do not advertise to any peer (well-known community)\n"
	 "Do not export to next AS (well-known community)\n"
	 "community number\n"
	 "Do not send outside local AS (well-known community)\n"
	 "Do not advertise to any peer (well-known community)\n"
	 "Do not export to next AS (well-known community)\n"
	 "Exact match of the communities")

  ALIAS (show_ip_bgp_community_exact,
	 show_ip_bgp_community4_exact_cmd,
	 "show ip bgp community (AA:NN|local-AS|no-advertise|no-export) (AA:NN|local-AS|no-advertise|no-export) "
         "(AA:NN|local-AS|no-advertise|no-export) (AA:NN|local-AS|no-advertise|no-export) exact-match",
	 SHOW_STR
	 IP_STR
	 BGP_STR
	 "Display routes matching the communities\n"
	 "community number\n"
	 "Do not send outside local AS (well-known community)\n"
	 "Do not advertise to any peer (well-known community)\n"
	 "Do not export to next AS (well-known community)\n"
	 "community number\n"
	 "Do not send outside local AS (well-known community)\n"
	 "Do not advertise to any peer (well-known community)\n"
	 "Do not export to next AS (well-known community)\n"
	 "community number\n"
	 "Do not send outside local AS (well-known community)\n"
	 "Do not advertise to any peer (well-known community)\n"
	 "Do not export to next AS (well-known community)\n"
	 "community number\n"
	 "Do not send outside local AS (well-known community)\n"
	 "Do not advertise to any peer (well-known community)\n"
	 "Do not export to next AS (well-known community)\n"
	 "Exact match of the communities")


  ALIAS (no_bgp_distance,
	 no_bgp_distance2_cmd,
	 "no distance bgp",
	 NO_STR
	 "Define an administrative distance\n"
	 "BGP distance\n")


  ALIAS (bgp_damp_set,
	 bgp_damp_set2_cmd,
	 "bgp dampening <1-45>",
	 "BGP Specific commands\n"
	 "Enable route-flap dampening\n"
	 "Half-life time for the penalty\n")

  ALIAS (bgp_damp_set,
	 bgp_damp_set3_cmd,
	 "bgp dampening",
	 "BGP Specific commands\n"
	 "Enable route-flap dampening\n")


  ALIAS (bgp_damp_unset,
	 bgp_damp_unset2_cmd,
	 "no bgp dampening <1-45> <1-20000> <1-20000> <1-255>",
	 NO_STR
	 "BGP Specific commands\n"
	 "Enable route-flap dampening\n"
	 "Half-life time for the penalty\n"
	 "Value to start reusing a route\n"
	 "Value to start suppressing a route\n"
	 "Maximum duration to suppress a stable route\n")

#ifdef HAVE_ZEBRA_93b
  DEFUNST (clear_ip_bgp_dampening,
	 clear_ip_bgp_dampening_cmd,
	 "clear ip bgp dampening",
	 CLEAR_STR
	 IP_STR
	 BGP_STR
	 "Clear route flap dampening information\n")

  DEFUNST (clear_ip_bgp_dampening_prefix,
	 clear_ip_bgp_dampening_prefix_cmd,
	 "clear ip bgp dampening A.B.C.D/M",
	 CLEAR_STR
	 IP_STR
	 BGP_STR
	 "Clear route flap dampening information\n"
	 "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n")

  DEFUNST (clear_ip_bgp_dampening_address,
         clear_ip_bgp_dampening_address_cmd,
         "clear ip bgp dampening A.B.C.D",
         CLEAR_STR
         IP_STR
         BGP_STR
         "Clear route flap dampening information\n"
         "Network to clear damping information\n")

  DEFUNST (clear_ip_bgp_dampening_address_mask,
         clear_ip_bgp_dampening_address_mask_cmd,
         "clear ip bgp dampening A.B.C.D A.B.C.D",
         CLEAR_STR
         IP_STR
         BGP_STR
         "Clear route flap dampening information\n"
         "Network to clear damping information\n"
         "Network mask\n")

#endif  /*HAVE_ZEBRA_93b*/


  ALIAS (no_match_ip_address, 
	 no_match_ip_address_val_cmd,
	 "no match ip address WORD",
	 NO_STR
	 MATCH_STR
	 IP_STR
	 "Match address of route\n"
	 "IP access-list name\n")


  ALIAS (no_match_ip_next_hop,
	 no_match_ip_next_hop_val_cmd,
	 "no match ip next-hop WORD",
	 NO_STR
	 MATCH_STR
	 IP_STR
	 "Match next-hop address of route\n"
	 "IP access-list name\n")

  ALIAS (no_match_ip_address_prefix_list,
	 no_match_ip_address_prefix_list_val_cmd,
	 "no match ip address prefix-list WORD",
	 NO_STR
	 MATCH_STR
	 IP_STR
	 "Match address of route\n"
	 "Match entries of prefix-lists\n"
	 "IP prefix-list name\n")

  ALIAS (no_match_ip_next_hop_prefix_list,
	 no_match_ip_next_hop_prefix_list_val_cmd,
	 "no match ip next-hop prefix-list WORD",
	 NO_STR
	 MATCH_STR
	 IP_STR
	 "Match next-hop address of route\n"
	 "Match entries of prefix-lists\n"
	 "IP prefix-list name\n")

  ALIAS (no_match_metric,
	 no_match_metric_val_cmd,
	 "no match metric <0-4294967295>",
	 NO_STR
	 MATCH_STR
	 "Match metric of route\n"
	 "Metric value\n")

  ALIAS (no_match_community,
	 no_match_community_val_cmd,
	 "no match community WORD",
	 NO_STR
	 MATCH_STR
	 "Match BGP community list\n"
	 "Community-list name (not community value itself)\n")

  ALIAS (no_match_aspath,
	 no_match_aspath_val_cmd,
	 "no match as-path WORD",
	 NO_STR
	 MATCH_STR
	 "Match BGP AS path list\n"
	 "AS path access-list name\n")

  ALIAS (no_set_ip_nexthop,
	 no_set_ip_nexthop_val_cmd,
	 "no set ip next-hop A.B.C.D",
	 NO_STR
	 SET_STR
	 IP_STR
	 "Next hop address\n"
	 "IP address of next hop\n")

  ALIAS (no_set_metric,
	 no_set_metric_val_cmd,
	 "no set metric <0-4294967295>",
	 NO_STR
	 SET_STR
	 "Metric value for destination routing protocol\n"
	 "Metric value\n")


  ALIAS (no_set_local_pref,
	 no_set_local_pref_val_cmd,
	 "no set local-preference <0-4294967295>",
	 NO_STR
	 SET_STR
	 "BGP local preference path attribute\n"
	 "Preference value\n")

  ALIAS (no_set_weight,
	 no_set_weight_val_cmd,
	 "no set weight <0-4294967295>",
	 NO_STR
	 SET_STR
	 "BGP weight for routing table\n"
	 "Weight value\n")


  ALIAS (no_set_aspath_prepend,
	 no_set_aspath_prepend_val_cmd,
	 "no set as-path prepend .<1-65535>",
	 NO_STR
	 SET_STR
	 "Prepend string for a BGP AS-path attribute\n"
	 "Prepend to the as-path\n"
	 "AS number\n")

  ALIAS (set_community,
	 set_community_none_cmd,
	 "set community none",
	 SET_STR
	 "BGP community attribute\n"
	 "No community attribute\n")


  ALIAS (no_set_community,
	 no_set_community_val_cmd,
	 "no set community .AA:NN",
	 NO_STR
	 SET_STR
	 "BGP community attribute\n"
	 "Community number in aa:nn format or local-AS|no-advertise|no-export\n")

  ALIAS (no_set_community,
	 no_set_community_none_cmd,
	 "no set community none",
	 NO_STR
	 SET_STR
	 "BGP community attribute\n"
	 "No community attribute\n")


  ALIAS (no_set_community_additive,
	 no_set_community_additive_val_cmd,
	 "no set community-additive .AA:NN",
	 NO_STR
	 SET_STR
	 "BGP community attribute (Add to the existing community)\n"
	 "Community number in aa:nn format or local-AS|no-advertise|no-export\n")

  ALIAS (no_set_community_delete,
	 no_set_community_delete_val_cmd,
	 "no set community-delete WORD",
	 NO_STR
	 SET_STR
	 "BGP community attribute (Delete from the existing community)\n"
	 "Community list\n")

  ALIAS (no_set_ecommunity_rt,
	 no_set_ecommunity_rt_val_cmd,
	 "no set extcommunity rt .ASN:nn_or_IP-address:nn",
	 NO_STR
	 SET_STR
	 "BGP extended community attribute\n"
	 "Route Target extened communityt\n"
	 "VPN extended community\n")

  ALIAS (no_set_ecommunity_soo,
	 no_set_ecommunity_soo_val_cmd,
	 "no set extcommunity soo .ASN:nn_or_IP-address:nn",
	 NO_STR
	 SET_STR
	 "BGP extended community attribute\n"
	 "Site-of-Origin extended community\n"
	 "VPN extended community\n")

  ALIAS (no_set_origin,
	 no_set_origin_val_cmd,
	 "no set origin (egp|igp|incomplete)",
	 NO_STR
	 SET_STR
	 "BGP origin code\n"
	 "remote EGP\n"
	 "local IGP\n"
	 "unknown heritage\n")

  ALIAS (no_set_aggregator_as,
	 no_set_aggregator_as_val_cmd,
	 "no set aggregator as <1-65535> A.B.C.D",
	 NO_STR
	 SET_STR
	 "BGP aggregator attribute\n"
	 "AS number of aggregator\n"
	 "AS number\n"
	 "IP address of aggregator\n")


  ALIAS (no_set_originator_id,
	 no_set_originator_id_val_cmd,
	 "no set originator-id A.B.C.D",
	 NO_STR
	 SET_STR
	 "BGP originator ID attribute\n"
	 "IP address of originator\n")


  ALIAS (no_bgp_router_id, 
	 no_bgp_router_id_val_cmd,
	 "no bgp router-id A.B.C.D",
	 NO_STR
	 "BGP specific commands\n"
	 "Override configured router identifier\n"
	 "Manually configured router identifier\n")

  ALIAS (bgp_cluster_id, 
	 bgp_cluster_id32_cmd,
	 "bgp cluster-id <1-4294967295>",
	 "BGP specific commands\n"
	 "Configure Route-Reflector Cluster-id\n"
	 "Route-Reflector Cluster-id as 32 bit quantity\n")

  ALIAS (no_bgp_cluster_id, 
	 no_bgp_cluster_id_val_cmd,
	 "no bgp cluster-id A.B.C.D",
	 NO_STR
	 "BGP specific commands\n"
	 "Configure Route-Reflector Cluster-id\n"
	 "Route-Reflector Cluster-id in IP address format\n")

  ALIAS (bgp_bestpath_med2,
	 bgp_bestpath_med3_cmd,
	 "bgp bestpath med missing-as-worst confed",
	 "BGP specific commands\n"
	 "Change the default bestpath selection\n"
	 "MED attribute\n"
	 "Treat missing MED as the least preferred one\n"
	 "Compare MED among confederation paths\n")


  ALIAS (no_bgp_bestpath_med2,
	 no_bgp_bestpath_med3_cmd,
	 "no bgp bestpath med missing-as-worst confed",
	 NO_STR
	 "BGP specific commands\n"
	 "Change the default bestpath selection\n"
	 "MED attribute\n"
	 "Treat missing MED as the least preferred one\n"
	 "Compare MED among confederation paths\n")

  ALIAS (no_bgp_default_local_preference,
	 no_bgp_default_local_preference_val_cmd,
	 "no bgp default local-preference <0-4294967295>",
	 NO_STR
	 "BGP specific commands\n"
	 "Configure BGP defaults\n"
	 "local preference (higher=more preferred)\n"
	 "Configure default local preference value\n")

  ALIAS (no_neighbor_description,
	 no_neighbor_description_val_cmd,
	 NO_NEIGHBOR_CMD "description .LINE",
	 NO_STR
	 NEIGHBOR_STR
	 NEIGHBOR_ADDR_STR
	 "Neighbor specific description\n"
	 "Up to 80 characters describing this neighbor\n")

  ALIAS (no_neighbor_weight,
	 no_neighbor_weight_val_cmd,
	 NO_NEIGHBOR_CMD "weight <0-65535>",
	 NO_STR
	 NEIGHBOR_STR
	 NEIGHBOR_ADDR_STR
	 "Set default weight for routes from this neighbor\n"
	 "default weight\n")



  ALIAS (no_neighbor_maximum_prefix,
	 no_neighbor_maximum_prefix_val_cmd,
	 NO_NEIGHBOR_CMD "maximum-prefix <1-4294967295>",
	 NO_STR
	 NEIGHBOR_STR
	 NEIGHBOR_ADDR_STR
	 "Maximum number of prefix accept from this peer\n"
	 "maximum no. of prefix limit\n")

  ALIAS (clear_ip_bgp_peer_soft_out,
	 clear_ip_bgp_peer_out_cmd,
	 "clear ip bgp A.B.C.D out",
	 CLEAR_STR
	 IP_STR
	 BGP_STR
	 "BGP neighbor address to clear\n"
	 "Soft reconfig outbound update\n")


  ALIAS (clear_ip_bgp_as_soft_out,
	 clear_ip_bgp_as_out_cmd,
	 "clear ip bgp <1-65535> out",
	 CLEAR_STR
	 IP_STR
	 BGP_STR
	 "Clear peers with the AS number\n"
	 "Soft reconfig outbound update\n")


  ALIAS (clear_ip_bgp_all_soft_out,
	 clear_ip_bgp_all_out_cmd,
	 "clear ip bgp * out",
	 CLEAR_STR
	 IP_STR
	 BGP_STR
	 "Clear all peers\n"
	 "Soft reconfig outbound update\n")

  ALIAS (access_list, 
	 access_list_exact_cmd,
	 "access-list WORD (deny|permit) A.B.C.D/M (exact-match|)",
	 "Add an access list entry\n"
	 "Access-list name\n"
	 "Specify packets to reject\n"
	 "Specify packets to forward\n"
	 "Prefix to match. e.g. 10.0.0.0/8\n"
	 "Exact match of the prefixes\n")


  ALIAS (no_access_list,
	 no_access_list_exact_cmd,
	 "no access-list WORD (deny|permit) A.B.C.D/M (exact-match|)",
	 NO_STR 
	 "Add an access list entry\n"
	 "Access-list name\n"
	 "Specify packets to reject\n"
	 "Specify packets to forward\n"
	 "Prefix to match. e.g. 10.0.0.0/8\n"
	 "Exact match of the prefixes\n")

  ALIAS (no_access_list_remark,
	 no_access_list_remark_arg_cmd,
	 "no access-list WORD remark .LINE",
	 NO_STR
	 "Add an access list entry\n"
	 "Access-list name\n"
	 "Access list entry comment\n"
	 "Comment up to 100 characters\n")

  ALIAS (show_memory_all,
	 show_memory_cmd,
	 "show memory",
	 "Show running system information\n"
	 "Memory statistics\n")

  ALIAS (no_ip_prefix_list_description,
	 no_ip_prefix_list_description_arg_cmd,
	 "no ip prefix-list WORD description .LINE",
	 NO_STR
	 IP_STR
	 PREFIX_LIST_STR
	 "Name of a prefix list\n"
	 "Prefix-list specific description\n"
	 "Up to 80 characters describing this prefix-list\n")



  DEFUNST (show_memory_all,
	   show_memory_all_cmd,
	   "show memory all",
	   "Show running system information\n"
	   "Memory statistics\n"
	   "All memory statistics\n")
  DEFUNST (show_memory_lib,
	   show_memory_lib_cmd,
	   "show memory lib",
	   SHOW_STR
	   "Memory statistics\n"
	   "Library memory\n")

  DEFUNST (show_memory_bgp,
	   show_memory_bgp_cmd,
	   "show memory bgp",
	   SHOW_STR
	   "Memory statistics\n"
	   "BGP memory\n")

  DEFUNST (no_router_bgp,
	  no_router_bgp_cmd,
	  "no router bgp <1-65535>",
	  NO_STR
	  ROUTER_STR
	  BGP_STR
	  AS_STR)

  DEFUNST (neighbor_remote_as,
	   neighbor_remote_as_cmd,
	   NEIGHBOR_CMD "remote-as <1-65535>",
	   NEIGHBOR_STR
	   NEIGHBOR_ADDR_STR
	   "Specify a BGP neighbor\n"
	   AS_STR)

  DEFUNST (no_neighbor_remote_as,
	   no_neighbor_remote_as_cmd,
	   NO_NEIGHBOR_CMD "remote-as <1-65535>",
	   NO_STR
	   NEIGHBOR_STR
	   NEIGHBOR_ADDR_STR
	   "Specify a BGP neighbor\n"
	   AS_STR)

  DEFUNST (neighbor_activate,
	   neighbor_activate_cmd,
	   NEIGHBOR_CMD "activate",
	   NEIGHBOR_STR
	   NEIGHBOR_ADDR_STR
	   "Enable the Address Family for this Neighbor\n")

  DEFUNST (no_neighbor_activate,
	   no_neighbor_activate_cmd,
	   NO_NEIGHBOR_CMD "activate",
	   NO_STR
	   NEIGHBOR_STR
	   NEIGHBOR_ADDR_STR
	   "Enable the Address Family for this Neighbor\n")

  DEFUNST (no_neighbor,
	   no_neighbor_cmd,
	   NO_NEIGHBOR_CMD,
	   NO_STR
	   NEIGHBOR_STR
	   NEIGHBOR_ADDR_STR)

  DEFUNST (neighbor_passive,
	   neighbor_passive_cmd,
	   NEIGHBOR_CMD "passive",
	   NEIGHBOR_STR
	   NEIGHBOR_ADDR_STR
	   "Don't send open messages to this neighbor\n")

  DEFUNST (no_neighbor_passive,
	   no_neighbor_passive_cmd,
	   NO_NEIGHBOR_CMD "passive",
	   NO_STR
	   NEIGHBOR_STR
	   NEIGHBOR_ADDR_STR
	   "Don't send open messages to this neighbor\n")

  DEFUNST (neighbor_shutdown,
	   neighbor_shutdown_cmd,
	   NEIGHBOR_CMD "shutdown",
	   NEIGHBOR_STR
	   NEIGHBOR_ADDR_STR
	   "Administratively shut down this neighbor\n")


  DEFUNST (no_neighbor_shutdown,
	   no_neighbor_shutdown_cmd,
	   NO_NEIGHBOR_CMD "shutdown",
	   NO_STR
	   NEIGHBOR_STR
	   NEIGHBOR_ADDR_STR
	   "Administratively shut down this neighbor\n") 



  DEFUNST (neighbor_ebgp_multihop,
	   neighbor_ebgp_multihop_cmd,
	   NEIGHBOR_CMD "ebgp-multihop",
	   NEIGHBOR_STR
	   NEIGHBOR_ADDR_STR
	   "Allow EBGP neighbors not on directly connected networks\n")

  DEFUNST (no_neighbor_ebgp_multihop,
	   no_neighbor_ebgp_multihop_cmd,
	   NO_NEIGHBOR_CMD "ebgp-multihop",
	   NO_STR
	   NEIGHBOR_STR
	   NEIGHBOR_ADDR_STR
	   "Allow EBGP neighbors not on directly connected networks\n")


  DEFUNST (neighbor_ebgp_multihop_ttl,
	   neighbor_ebgp_multihop_ttl_cmd,
	   NEIGHBOR_CMD "ebgp-multihop <1-255>",
	   NEIGHBOR_STR
	   NEIGHBOR_ADDR_STR
	   "Allow EBGP neighbors not on directly connected networks\n"
	   "maximum hop count\n")

  DEFUNST (no_neighbor_ebgp_multihop_ttl,
	   no_neighbor_ebgp_multihop_ttl_cmd,
	   NO_NEIGHBOR_CMD "ebgp-multihop <1-255>",
	   NO_STR
	   NEIGHBOR_STR
	   NEIGHBOR_ADDR_STR
	   "Allow EBGP neighbors not on directly connected networks\n"
	   "maximum hop count\n")

  DEFUNST (neighbor_description,
	   neighbor_description_cmd,
	   NEIGHBOR_CMD "description .LINE",
	   NEIGHBOR_STR
	   NEIGHBOR_ADDR_STR
	   "Neighbor specific description\n"
	   "Up to 80 characters describing this neighbor\n")


  DEFUNST (no_neighbor_description,
	   no_neighbor_description_cmd,
	   NO_NEIGHBOR_CMD "description",
	   NO_STR
	   NEIGHBOR_STR
	   NEIGHBOR_ADDR_STR
	   "Neighbor specific description\n")
  DEFUNST (neighbor_version,
	   neighbor_version_cmd,
	   NEIGHBOR_CMD "version (4|4-)",
	   NEIGHBOR_STR
	   NEIGHBOR_ADDR_STR
	   "Neighbor's BGP version\n"
	   "Border Gateway Protocol 4\n"
	   "Multiprotocol Extensions for BGP-4(Old Draft)\n")


  DEFUNST (no_neighbor_version,
	   no_neighbor_version_cmd,
	   NO_NEIGHBOR_CMD "version",
	   NO_STR
	   NEIGHBOR_STR
	   NEIGHBOR_ADDR_STR
	   "Neighbor's BGP version\n")


  DEFUNST (neighbor_nexthop_self,
	   neighbor_nexthop_self_cmd,
	   NEIGHBOR_CMD "next-hop-self",
	   NEIGHBOR_STR
	   NEIGHBOR_ADDR_STR
	   "Disable the next hop calculation for this neighbor\n")

  DEFUNST (no_neighbor_nexthop_self,
	   no_neighbor_nexthop_self_cmd,
	   NO_NEIGHBOR_CMD "next-hop-self",
	   NO_STR
	   NEIGHBOR_STR
	   NEIGHBOR_ADDR_STR
	   "Disable the next hop calculation for this neighbor\n")


  DEFUNST (neighbor_send_community,
	   neighbor_send_community_cmd,
	   NEIGHBOR_CMD "send-community",
	   NEIGHBOR_STR
	   NEIGHBOR_ADDR_STR
	   "Send Community attribute to this neighbor (default enable)\n")


  DEFUNST (no_neighbor_send_community,
	   no_neighbor_send_community_cmd,
	   NO_NEIGHBOR_CMD "send-community",
	   NO_STR
	   NEIGHBOR_STR
	   NEIGHBOR_ADDR_STR
	   "Send Community attribute to this neighbor (default enable)\n")

  DEFUNST (neighbor_send_community_type,
	   neighbor_send_community_type_cmd,
	   NEIGHBOR_CMD "send-community (both|extended|standard)",
	   NEIGHBOR_STR
	   NEIGHBOR_ADDR_STR
	   "Send Community attribute to this neighbor (default enable)\n"
	   "Send Standard and Extended Community attributes\n"
	   "Send Extended Community attributes\n"
	   "Send Standard Community attributes\n")


  DEFUNST (no_neighbor_send_community_type,
	   no_neighbor_send_community_type_cmd,
	   NO_NEIGHBOR_CMD "send-community (both|extended|standard)",
	   NO_STR
	   NEIGHBOR_STR
	   NEIGHBOR_ADDR_STR
	   "Send Community attribute to this neighbor (default enable)\n"
	   "Send Standard and Extended Community attributes\n"
	   "Send Extended Community attributes\n"
	   "Send Standard Community attributes\n")

  DEFUNST (neighbor_weight,
	   neighbor_weight_cmd,
	   NEIGHBOR_CMD "weight <0-65535>",
	   NEIGHBOR_STR
	   NEIGHBOR_ADDR_STR
	   "Set default weight for routes from this neighbor\n"
	   "default weight\n")


  DEFUNST (no_neighbor_weight,
	   no_neighbor_weight_cmd,
	   NO_NEIGHBOR_CMD "weight",
	   NO_STR
	   NEIGHBOR_STR
	   NEIGHBOR_ADDR_STR
	   "Set default weight for routes from this neighbor\n")

  DEFUNST (neighbor_soft_reconfiguration,
	   neighbor_soft_reconfiguration_cmd,
	   NEIGHBOR_CMD "soft-reconfiguration inbound",
	   NEIGHBOR_STR
	   NEIGHBOR_ADDR_STR
	   "Per neighbor soft reconfiguration\n"
	   "Allow inbound soft reconfiguration for this neighbor\n")

  DEFUNST (no_neighbor_soft_reconfiguration,
	   no_neighbor_soft_reconfiguration_cmd,
	   NO_NEIGHBOR_CMD "soft-reconfiguration inbound",
	   NO_STR
	   NEIGHBOR_STR
	   NEIGHBOR_ADDR_STR
	   "Per neighbor soft reconfiguration\n"
	   "Allow inbound soft reconfiguration for this neighbor\n")

  DEFUNST (neighbor_route_reflector_client,
	   neighbor_route_reflector_client_cmd,
	   NEIGHBOR_CMD "route-reflector-client",
	   NEIGHBOR_STR
	   NEIGHBOR_ADDR_STR
	   "Configure a neighbor as Route Reflector client\n")

  DEFUNST (no_neighbor_route_reflector_client,
	   no_neighbor_route_reflector_client_cmd,
	   NO_NEIGHBOR_CMD "route-reflector-client",
	   NO_STR
	   NEIGHBOR_STR
	   NEIGHBOR_ADDR_STR
	   "Configure a neighbor as Route Reflector client\n")

  DEFUNST (neighbor_route_server_client,
	   neighbor_route_server_client_cmd,
	   NEIGHBOR_CMD "route-server-client",
	   NEIGHBOR_STR
	   NEIGHBOR_ADDR_STR
	   "Configure a neighbor as Route Server client\n")

  DEFUNST (no_neighbor_route_server_client,
	   no_neighbor_route_server_client_cmd,
	   NO_NEIGHBOR_CMD "route-server-client",
	   NO_STR
	   NEIGHBOR_STR
	   NEIGHBOR_ADDR_STR
	   "Configure a neighbor as Route Server client\n")
 
 DEFUNST (neighbor_capability_route_refresh,
	   neighbor_capability_route_refresh_cmd,
	   NEIGHBOR_CMD "capability route-refresh",
	   NEIGHBOR_STR
	   NEIGHBOR_ADDR_STR
	   "Outbound capability configuration\n"
	   "Advertise route-refresh capability to this neighbor\n")


  DEFUNST (no_neighbor_capability_route_refresh,
	   no_neighbor_capability_route_refresh_cmd,
	   NO_NEIGHBOR_CMD "capability route-refresh",
	   NO_STR
	   NEIGHBOR_STR
	   NEIGHBOR_ADDR_STR
	   "Outbound capability configuration\n"
	   "Advertise route-refresh capability to this neighbor\n")

  /* neighbor dont-capability-negotiate */
  DEFUNST (neighbor_dont_capability_negotiate,
	   neighbor_dont_capability_negotiate_cmd,
	   NEIGHBOR_CMD "dont-capability-negotiate",
	   NEIGHBOR_STR
	   NEIGHBOR_ADDR_STR
	   "Do not perform capability negotiation\n")

  DEFUNST (no_neighbor_dont_capability_negotiate,
	   no_neighbor_dont_capability_negotiate_cmd,
	   NO_NEIGHBOR_CMD "dont-capability-negotiate",
	   NO_STR
	   NEIGHBOR_STR
	   NEIGHBOR_ADDR_STR
	   "Do not perform capability negotiation\n")

  DEFUNST (neighbor_override_capability,
	   neighbor_override_capability_cmd,
	   NEIGHBOR_CMD "override-capability",
	   NEIGHBOR_STR
	   NEIGHBOR_ADDR_STR
	   "Override capability negotiation result\n")

  DEFUNST (no_neighbor_override_capability,
	   no_neighbor_override_capability_cmd,
	   NO_NEIGHBOR_CMD "override-capability",
	   NO_STR
	   NEIGHBOR_STR
	   NEIGHBOR_ADDR_STR
	   "Override capability negotiation result\n")

  DEFUNST (neighbor_strict_capability,
	   neighbor_strict_capability_cmd,
	   NEIGHBOR_CMD "strict-capability-match",
	   NEIGHBOR_STR
	   NEIGHBOR_ADDR_STR
	   "Strict capability negotiation match\n")

  DEFUNST (no_neighbor_strict_capability,
	   no_neighbor_strict_capability_cmd,
	   NO_NEIGHBOR_CMD "strict-capability-match",
	   NO_STR
	   NEIGHBOR_STR
	   NEIGHBOR_ADDR_STR
	   "Strict capability negotiation match\n")

  DEFUNST (neighbor_timers,
	   neighbor_timers_cmd,
	   NEIGHBOR_CMD "timers <0-65535> <0-65535>",
	   NEIGHBOR_STR
	   NEIGHBOR_ADDR_STR
	   "BGP per neighbor timers\n"
	   "Keepalive interval\n"
	   "Holdtime\n")

  DEFUNST (no_neighbor_timers,
	   no_neighbor_timers_cmd,
	   NO_NEIGHBOR_CMD "timers",
	   NO_STR
	   NEIGHBOR_STR
	   NEIGHBOR_ADDR_STR
	   "BGP per neighbor timers\n")

  DEFUNST (neighbor_timers_connect,
	   neighbor_timers_connect_cmd,
	   NEIGHBOR_CMD "timers connect <0-65535>",
	   NEIGHBOR_STR
	   NEIGHBOR_ADDR_STR
	   "BGP per neighbor timers\n"
	   "BGP connect timer\n"
	   "Connect timer\n")

  DEFUNST (no_neighbor_timers_connect,
	   no_neighbor_timers_connect_cmd,
	   NO_NEIGHBOR_CMD "timers connect [TIMER]",
	   NO_STR
	   NEIGHBOR_STR
	   NEIGHBOR_ADDR_STR
	   "BGP per neighbor timers\n"
	   "BGP connect timer\n"
	   "Connect timer\n")

  DEFUNST (neighbor_prefix_list,
	   neighbor_prefix_list_cmd,
	   NEIGHBOR_CMD "prefix-list WORD (in|out)",
	   NEIGHBOR_STR
	   NEIGHBOR_ADDR_STR
	   "Filter updates to/from this neighbor\n"
	   "Name of a prefix list\n"
	   "Filter incoming updates\n"
	   "Filter outgoing updates\n")

  DEFUNST (no_neighbor_prefix_list,
	   no_neighbor_prefix_list_cmd,
	   NO_NEIGHBOR_CMD "prefix-list WORD (in|out)",
	   NO_STR
	   NEIGHBOR_STR
	   NEIGHBOR_ADDR_STR
	   "Filter updates to/from this neighbor\n"
	   "Name of a prefix list\n"
	   "Filter incoming updates\n"
	   "Filter outgoing updates\n")
  DEFUNST (neighbor_filter_list,
	   neighbor_filter_list_cmd,
	   NEIGHBOR_CMD "filter-list WORD (in|out)",
	   NEIGHBOR_STR
	   NEIGHBOR_ADDR_STR
	   "Establish BGP filters\n"
	   "AS path access-list name\n"
	   "Filter incoming routes\n"
	   "Filter outgoing routes\n")


  DEFUNST (no_neighbor_filter_list,
	   no_neighbor_filter_list_cmd,
	   NO_NEIGHBOR_CMD "filter-list WORD (in|out)",
	   NO_STR
	   NEIGHBOR_STR
	   NEIGHBOR_ADDR_STR
	   "Establish BGP filters\n"
	   "AS path access-list name\n"
	   "Filter incoming routes\n"
	   "Filter outgoing routes\n")

  DEFUNST (neighbor_route_map,
	   neighbor_route_map_cmd,
	   NEIGHBOR_CMD "route-map WORD (in|out)",
	   NEIGHBOR_STR
	   NEIGHBOR_ADDR_STR
	   "Apply route map to neighbor\n"
	   "Name of route map\n"
	   "Apply map to incoming routes\n"
	   "Apply map to outbound routes\n")

  DEFUNST (no_neighbor_route_map,
	   no_neighbor_route_map_cmd,
	   NO_NEIGHBOR_CMD "route-map WORD (in|out)",
	   NO_STR
	   NEIGHBOR_STR
	   NEIGHBOR_ADDR_STR
	   "Apply route map to neighbor\n"
	   "Name of route map\n"
	   "Apply map to incoming routes\n"
	   "Apply map to outbound routes\n")

  DEFUNST (neighbor_maximum_prefix,
	   neighbor_maximum_prefix_cmd,
	   NEIGHBOR_CMD "maximum-prefix <1-4294967295>",
	   NEIGHBOR_STR
	   NEIGHBOR_ADDR_STR
	   "Maximum number of prefix accept from this peer\n"
	   "maximum no. of prefix limit\n")

  DEFUNST (no_neighbor_maximum_prefix,
	   no_neighbor_maximum_prefix_cmd,
	   NO_NEIGHBOR_CMD "maximum-prefix",
	   NO_STR
	   NEIGHBOR_STR
	   NEIGHBOR_ADDR_STR
	   "Maximum number of prefix accept from this peer\n")

  DEFUNST (neighbor_transparent_as,
	   neighbor_transparent_as_cmd,
	   NEIGHBOR_CMD "transparent-as",
	   NEIGHBOR_STR
	   NEIGHBOR_ADDR_STR
	   "Do not append my AS number even peer is EBGP peer\n")

  DEFUNST (no_neighbor_transparent_as,
	   no_neighbor_transparent_as_cmd,
	   NO_NEIGHBOR_CMD "transparent-as",
	   NO_STR
	   NEIGHBOR_STR
	   NEIGHBOR_ADDR_STR
	   "Do not append my AS number even peer is EBGP peer\n")

  DEFUNST (neighbor_transparent_nexthop,
	   neighbor_transparent_nexthop_cmd,
	   NEIGHBOR_CMD "transparent-nexthop",
	   NEIGHBOR_STR
	   NEIGHBOR_ADDR_STR
	   "Do not change nexthop even peer is EBGP peer\n")

  DEFUNST (no_neighbor_transparent_nexthop,
	   no_neighbor_transparent_nexthop_cmd,
	   NO_NEIGHBOR_CMD "transparent-nexthop",
	   NO_STR
	   NEIGHBOR_STR
	   NEIGHBOR_ADDR_STR
	   "Do not change nexthop even peer is EBGP peer\n")

  DEFUNST (show_ip_bgp_summary, 
	   show_ip_bgp_summary_cmd,
	   "show ip bgp summary",
	   SHOW_STR
	   IP_STR
	   BGP_STR
	   "Summary of BGP neighbor status\n")

  DEFUNST (show_ip_bgp_neighbors,
	   show_ip_bgp_neighbors_cmd,
	   "show ip bgp neighbors",
	   SHOW_STR
	   IP_STR
	   BGP_STR
	   "Detailed information on TCP and BGP neighbor connections\n")

  DEFUNST (show_ip_bgp_neighbors_peer,
	   show_ip_bgp_neighbors_peer_cmd,
	   "show ip bgp neighbors (A.B.C.D|X:X::X:X)",
	   SHOW_STR
	   IP_STR
	   BGP_STR
	   "Detailed information on TCP and BGP neighbor connections\n"
	   "Neighbor to display information about\n"
	   "Neighbor to display information about\n")

  DEFUNST (show_ip_bgp_paths, 
	   show_ip_bgp_paths_cmd,
	   "show ip bgp paths",
	   SHOW_STR
	   IP_STR
	   BGP_STR
	   "Path information\n")

  DEFUNST (show_ip_bgp_community_info, 
	   show_ip_bgp_community_info_cmd,
	   "show ip bgp community-info",
	   SHOW_STR
	   IP_STR
	   BGP_STR
	   "List all bgp community information\n")

  DEFUNST (show_ip_bgp_attr_info, 
	   show_ip_bgp_attr_info_cmd,
	   "show ip bgp attribute-info",
	   SHOW_STR
	   IP_STR
	   BGP_STR
	   "List all bgp attribute information\n")

  DEFUNST (clear_ip_bgp_all,
	   clear_ip_bgp_all_cmd,
	   "clear ip bgp *",
	   CLEAR_STR
	   IP_STR
	   BGP_STR
	   "Clear all peers\n")

  DEFUNST (clear_ip_bgp_as,
	   clear_ip_bgp_as_cmd,
	   "clear ip bgp <1-65535>",
	   CLEAR_STR
	   IP_STR
	   BGP_STR
	   "Clear peers with the AS number\n")

  DEFUNST (clear_ip_bgp_peer,
	   clear_ip_bgp_peer_cmd, 
	   "clear ip bgp (A.B.C.D|X:X::X:X)",
	   CLEAR_STR
	   IP_STR
	   BGP_STR
	   "BGP neighbor IP address to clear\n"
	   "BGP neighbor IPv6 address to clear\n")

  DEFUNST (clear_ip_bgp_peer_soft_in,
	   clear_ip_bgp_peer_soft_in_cmd,
	   "clear ip bgp A.B.C.D soft in",
	   CLEAR_STR
	   IP_STR
	   BGP_STR
	   "BGP neighbor address to clear\n"
	   "Soft reconfig\n"
	   "Soft reconfig inbound update\n")

  DEFUNST (clear_ip_bgp_peer_in,
	   clear_ip_bgp_peer_in_cmd,
	   "clear ip bgp A.B.C.D in",
	   CLEAR_STR
	   IP_STR
	   BGP_STR
	   "BGP neighbor address to clear\n"
	   "Soft reconfig inbound update\n")

  DEFUNST (clear_ip_bgp_as_soft_in,
	   clear_ip_bgp_as_soft_in_cmd,
	   "clear ip bgp <1-65535> soft in",
	   CLEAR_STR
	   IP_STR
	   BGP_STR
	   "Clear peers with the AS number\n"
	   "Soft reconfig\n"
	   "Soft reconfig inbound update\n")

  DEFUNST (clear_ip_bgp_as_in,
	   clear_ip_bgp_as_in_cmd,
	   "clear ip bgp <1-65535> in",
	   CLEAR_STR
	   IP_STR
	   BGP_STR
	   "Clear peers with the AS number\n"
	   "Soft reconfig inbound update\n")

  DEFUNST (clear_ip_bgp_all_soft_in,
	   clear_ip_bgp_all_soft_in_cmd,
	   "clear ip bgp * soft in",
	   CLEAR_STR
	   IP_STR
	   BGP_STR
	   "Clear all peers\n"
	   "Soft reconfig\n"
	   "Soft reconfig inbound update\n")

  DEFUNST (clear_ip_bgp_all_in,
	   clear_ip_bgp_all_in_cmd,
	   "clear ip bgp * in",
	   CLEAR_STR
	   IP_STR
	   BGP_STR
	   "Clear all peers\n"
	   "Soft reconfig inbound update\n")


  DEFUNST (clear_ip_bgp_as_soft_out,
	   clear_ip_bgp_as_soft_out_cmd,
	   "clear ip bgp <1-65535> soft out",
	   CLEAR_STR
	   IP_STR
	   BGP_STR
	   "Clear peers with the AS number\n"
	   "Soft reconfig\n"
	   "Soft reconfig outbound update\n")

  DEFUNST (clear_ip_bgp_all_soft_out,
	   clear_ip_bgp_all_soft_out_cmd,
	   "clear ip bgp * soft out",
	   CLEAR_STR
	   IP_STR
	   BGP_STR
	   "Clear all peers\n"
	   "Soft reconfig\n"
	   "Soft reconfig outbound update\n")

  DEFUNST (clear_ip_bgp_peer_soft,
	   clear_ip_bgp_peer_soft_cmd,
	   "clear ip bgp A.B.C.D soft",
	   CLEAR_STR
	   IP_STR
	   BGP_STR
	   "BGP neighbor address to clear\n"
	   "Soft reconfig\n")

  DEFUNST (clear_ip_bgp_as_soft,
	   clear_ip_bgp_as_soft_cmd,
	   "clear ip bgp <1-65535> soft",
	   CLEAR_STR
	   IP_STR
	   BGP_STR
	   "Clear peers with the AS number\n"
	   "Soft reconfig\n")

  DEFUNST (clear_ip_bgp_all_soft,
	   clear_ip_bgp_all_soft_cmd,
	   "clear ip bgp * soft",
	   CLEAR_STR
	   IP_STR
	   BGP_STR
	   "Clear all peers\n"
	   "Soft reconfig\n")

  DEFUNST (clear_ip_bgp_peer_soft_out,
	   clear_ip_bgp_peer_soft_out_cmd,
	   "clear ip bgp A.B.C.D soft out",
	   CLEAR_STR
	   IP_STR
	   BGP_STR
	   "BGP neighbor address to clear\n"
	   "Soft reconfig\n"
	   "Soft reconfig outbound update\n")

  DEFUNST (route_map,
	   route_map_cmd,
	   "route-map WORD (deny|permit) <1-65535>",
	   "Create route-map or enter route-map command mode\n"
	   "Route map tag\n"
	   "Route map denies set operations\n"
	   "Route map permits set operations\n"
	   "Sequence to insert to/delete from existing route-map entry\n")

  DEFUNST (no_route_map,
	   no_route_map_cmd,
	   "no route-map WORD (deny|permit) <1-65535>",
	   NO_STR
	   "Create route-map or enter route-map command mode\n"
	   "Route map tag\n"
	   "Route map denies set operations\n"
	   "Route map permits set operations\n"
	   "Sequence to insert to/delete from existing route-map entry\n")

  DEFUNST (no_route_map_all,
	   no_route_map_all_cmd,
	   "no route-map WORD",
	   NO_STR
	   "Create route-map or enter route-map command mode\n"
	   "Route map tag\n")

  DEFUNST (rmap_onmatch_next,
	   rmap_onmatch_next_cmd,
	   "on-match next",
	   "Exit policy on matches\n"
	   "Next clause\n")

  DEFUNST (no_rmap_onmatch_next,
	   no_rmap_onmatch_next_cmd,
	   "no on-match next",
	   NO_STR
	   "Exit policy on matches\n"
	   "Next clause\n")

  DEFUNST (rmap_onmatch_goto,
	   rmap_onmatch_goto_cmd,
	   "on-match goto <1-65535>",
	   "Exit policy on matches\n"
	   "Goto Clause number\n"
	   "Number\n")

  DEFUNST (no_rmap_onmatch_goto,
	   no_rmap_onmatch_goto_cmd,
	   "no on-match goto",
	   NO_STR
	   "Exit policy on matches\n"
	   "Next clause\n")

  DEFUNST (access_list, 
	   access_list_cmd,
	   "access-list WORD (deny|permit) (A.B.C.D/M|any)",
	   "Add an access list entry\n"
	   "Access-list name\n"
	   "Specify packets to reject\n"
	   "Specify packets to forward\n"
	   "Prefix to match. e.g. 10.0.0.0/8\n"
	   "Any prefix to match\n")

  DEFUNST (no_access_list,
	   no_access_list_cmd,
	   "no access-list WORD (deny|permit) (A.B.C.D/M|any)",
	   NO_STR 
	   "Add an access list entry\n"
	   "Access-list name\n"
	   "Specify packets to reject\n"
	   "Specify packets to forward\n"
	   "Prefix to match. e.g. 10.0.0.0/8\n"
	   "Any prefix to match\n")

  DEFUNST (access_list_remark,
	   access_list_remark_cmd,
	   "access-list WORD remark .LINE",
	   "Add an access list entry\n"
	   "Access-list name\n"
	   "Access list entry comment\n"
	   "Comment up to 100 characters\n")

  DEFUNST (no_access_list_remark,
	   no_access_list_remark_cmd,
	   "no access-list WORD remark",
	   NO_STR
	   "Add an access list entry\n"
	   "Access-list name\n"
	   "Access list entry comment\n")

  DEFUNST (no_access_list_all,
	   no_access_list_all_cmd,
	   "no access-list WORD",
	   NO_STR
	   "Add an access list entry\n"
	   "Access-list name\n")

  DEFUNST (ip_prefix_list,
	   ip_prefix_list_cmd,
	   "ip prefix-list WORD (deny|permit) (A.B.C.D/M|any)",
	   IP_STR
	   PREFIX_LIST_STR
	   "Name of a prefix list\n"
	   "Specify packets to reject\n"
	   "Specify packets to forward\n"
	   "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
	   "Any prefix match. Same as \"0.0.0.0/0 le 32\"\n")

  DEFUNST (no_ip_prefix_list,
	   no_ip_prefix_list_cmd,
	   "no ip prefix-list WORD",
	   NO_STR
	   IP_STR
	   PREFIX_LIST_STR
	   "Name of a prefix list\n")

  DEFUNST (show_ip_prefix_list,
	   show_ip_prefix_list_cmd,
	   "show ip prefix-list",
	   SHOW_STR
	   IP_STR
	   PREFIX_LIST_STR)

  DEFUNST (clear_ip_prefix_list,
	   clear_ip_prefix_list_cmd,
	   "clear ip prefix-list",
	   CLEAR_STR
	   IP_STR
	   PREFIX_LIST_STR)

  DEFUNST (ip_prefix_list_ge,
	   ip_prefix_list_ge_cmd,
	   "ip prefix-list WORD (deny|permit) A.B.C.D/M ge <0-32>",
	   IP_STR
	   PREFIX_LIST_STR
	   "Name of a prefix list\n"
	   "Specify packets to reject\n"
	   "Specify packets to forward\n"
	   "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
	   "Minimum prefix length to be matched\n"
	   "Minimum prefix length\n")

  DEFUNST (no_ip_prefix_list_ge,
	   no_ip_prefix_list_ge_cmd,
	   "no ip prefix-list WORD (deny|permit) A.B.C.D/M ge <0-32>",
	   NO_STR
	   IP_STR
	   PREFIX_LIST_STR
	   "Name of a prefix list\n"
	   "Specify packets to reject\n"
	   "Specify packets to forward\n"
	   "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
	   "Minimum prefix length to be matched\n"
	   "Minimum prefix length\n")

  DEFUNST (ip_prefix_list_ge_le,
	   ip_prefix_list_ge_le_cmd,
	   "ip prefix-list WORD (deny|permit) A.B.C.D/M ge <0-32> le <0-32>",
	   IP_STR
	   PREFIX_LIST_STR
	   "Name of a prefix list\n"
	   "Specify packets to reject\n"
	   "Specify packets to forward\n"
	   "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
	   "Minimum prefix length to be matched\n"
	   "Minimum prefix length\n"
	   "Maximum prefix length to be matched\n"
	   "Maximum prefix length\n")

  DEFUNST (ip_prefix_list_le,
	   ip_prefix_list_le_cmd,
	   "ip prefix-list WORD (deny|permit) A.B.C.D/M le <0-32>",
	   IP_STR
	   PREFIX_LIST_STR
	   "Name of a prefix list\n"
	   "Specify packets to reject\n"
	   "Specify packets to forward\n"
	   "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
	   "Maximum prefix length to be matched\n"
	   "Maximum prefix length\n")

  DEFUNST (no_ip_prefix_list_le,
	   no_ip_prefix_list_le_cmd,
	   "no ip prefix-list WORD (deny|permit) A.B.C.D/M le <0-32>",
	   NO_STR
	   IP_STR
	   PREFIX_LIST_STR
	   "Name of a prefix list\n"
	   "Specify packets to reject\n"
	   "Specify packets to forward\n"
	   "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
	   "Maximum prefix length to be matched\n"
	   "Maximum prefix length\n")

  DEFUNST (ip_prefix_list_le_ge,
	   ip_prefix_list_le_ge_cmd,
	   "ip prefix-list WORD (deny|permit) A.B.C.D/M le <0-32> ge <0-32>",
	   IP_STR
	   PREFIX_LIST_STR
	   "Name of a prefix list\n"
	   "Specify packets to reject\n"
	   "Specify packets to forward\n"
	   "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
	   "Maximum prefix length to be matched\n"
	   "Maximum prefix length\n"
	   "Minimum prefix length to be matched\n"
	   "Minimum prefix length\n")

  DEFUNST (no_ip_prefix_list_le_ge,
	   no_ip_prefix_list_le_ge_cmd,
	   "no ip prefix-list WORD (deny|permit) A.B.C.D/M le <0-32> ge <0-32>",
	   NO_STR
	   IP_STR
	   PREFIX_LIST_STR
	   "Name of a prefix list\n"
	   "Specify packets to reject\n"
	   "Specify packets to forward\n"
	   "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
	   "Maximum prefix length to be matched\n"
	   "Maximum prefix length\n"
	   "Minimum prefix length to be matched\n"
	   "Minimum prefix length\n")

  DEFUNST (ip_prefix_list_seq,
	   ip_prefix_list_seq_cmd,
	   "ip prefix-list WORD seq <1-4294967295> (deny|permit) (A.B.C.D/M|any)",
	   IP_STR
	   PREFIX_LIST_STR
	   "Name of a prefix list\n"
	   "sequence number of an entry\n"
	   "Sequence number\n"
	   "Specify packets to reject\n"
	   "Specify packets to forward\n"
	   "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
	   "Any prefix match. Same as \"0.0.0.0/0 le 32\"\n")

  DEFUNST (no_ip_prefix_list_seq,
	   no_ip_prefix_list_seq_cmd,
	   "no ip prefix-list WORD seq <1-4294967295> (deny|permit) (A.B.C.D/M|any)",
	   NO_STR
	   IP_STR
	   PREFIX_LIST_STR
	   "Name of a prefix list\n"
	   "sequence number of an entry\n"
	   "Sequence number\n"
	   "Specify packets to reject\n"
	   "Specify packets to forward\n"
	   "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
	   "Any prefix match.  Same as \"0.0.0.0/0 le 32\"\n")

  DEFUNST (ip_prefix_list_seq_ge,
	   ip_prefix_list_seq_ge_cmd,
	   "ip prefix-list WORD seq <1-4294967295> (deny|permit) A.B.C.D/M ge <0-32>",
	   IP_STR
	   PREFIX_LIST_STR
	   "Name of a prefix list\n"
	   "sequence number of an entry\n"
	   "Sequence number\n"
	   "Specify packets to reject\n"
	   "Specify packets to forward\n"
	   "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
	   "Minimum prefix length to be matched\n"
	   "Minimum prefix length\n")

  DEFUNST (no_ip_prefix_list_seq_ge,
	   no_ip_prefix_list_seq_ge_cmd,
	   "no ip prefix-list WORD seq <1-4294967295> (deny|permit) A.B.C.D/M ge <0-32>",
	   NO_STR
	   IP_STR
	   PREFIX_LIST_STR
	   "Name of a prefix list\n"
	   "sequence number of an entry\n"
	   "Sequence number\n"
	   "Specify packets to reject\n"
	   "Specify packets to forward\n"
	   "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
	   "Minimum prefix length to be matched\n"
	   "Minimum prefix length\n")

  DEFUNST (ip_prefix_list_seq_ge_le,
	   ip_prefix_list_seq_ge_le_cmd,
	   "ip prefix-list WORD seq <1-4294967295> (deny|permit) A.B.C.D/M ge <0-32> le <0-32>",
	   IP_STR
	   PREFIX_LIST_STR
	   "Name of a prefix list\n"
	   "sequence number of an entry\n"
	   "Sequence number\n"
	   "Specify packets to reject\n"
	   "Specify packets to forward\n"
	   "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
	   "Minimum prefix length to be matched\n"
	   "Minimum prefix length\n"
	   "Maximum prefix length to be matched\n"
	   "Maximum prefix length\n")

  DEFUNST (no_ip_prefix_list_seq_ge_le,
	   no_ip_prefix_list_seq_ge_le_cmd,
	   "no ip prefix-list WORD seq <1-4294967295> (deny|permit) A.B.C.D/M ge <0-32> le <0-32>",
	   NO_STR
	   IP_STR
	   PREFIX_LIST_STR
	   "Name of a prefix list\n"
	   "sequence number of an entry\n"
	   "Sequence number\n"
	   "Specify packets to reject\n"
	   "Specify packets to forward\n"
	   "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
	   "Minimum prefix length to be matched\n"
	   "Minimum prefix length\n"
	   "Maximum prefix length to be matched\n"
	   "Maximum prefix length\n")

  DEFUNST (ip_prefix_list_seq_le,
	   ip_prefix_list_seq_le_cmd,
	   "ip prefix-list WORD seq <1-4294967295> (deny|permit) A.B.C.D/M le <0-32>",
	   IP_STR
	   PREFIX_LIST_STR
	   "Name of a prefix list\n"
	   "sequence number of an entry\n"
	   "Sequence number\n"
	   "Specify packets to reject\n"
	   "Specify packets to forward\n"
	   "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
	   "Maximum prefix length to be matched\n"
	   "Maximum prefix length\n")

  DEFUNST (no_ip_prefix_list_seq_le,
	   no_ip_prefix_list_seq_le_cmd,
	   "no ip prefix-list WORD seq <1-4294967295> (deny|permit) A.B.C.D/M le <0-32>",
	   NO_STR
	   IP_STR
	   PREFIX_LIST_STR
	   "Name of a prefix list\n"
	   "sequence number of an entry\n"
	   "Sequence number\n"
	   "Specify packets to reject\n"
	   "Specify packets to forward\n"
	   "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
	   "Maximum prefix length to be matched\n"
	   "Maximum prefix length\n")

  DEFUNST (ip_prefix_list_seq_le_ge,
	   ip_prefix_list_seq_le_ge_cmd,
	   "ip prefix-list WORD seq <1-4294967295> (deny|permit) A.B.C.D/M le <0-32> ge <0-32>",
	   IP_STR
	   PREFIX_LIST_STR
	   "Name of a prefix list\n"
	   "sequence number of an entry\n"
	   "Sequence number\n"
	   "Specify packets to reject\n"
	   "Specify packets to forward\n"
	   "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
	   "Maximum prefix length to be matched\n"
	   "Maximum prefix length\n"
	   "Minimum prefix length to be matched\n"
	   "Minimum prefix length\n")

  DEFUNST (no_ip_prefix_list_seq_le_ge,
	   no_ip_prefix_list_seq_le_ge_cmd,
	   "no ip prefix-list WORD seq <1-4294967295> (deny|permit) A.B.C.D/M le <0-32> ge <0-32>",
	   NO_STR
	   IP_STR
	   PREFIX_LIST_STR
	   "Name of a prefix list\n"
	   "sequence number of an entry\n"
	   "Sequence number\n"
	   "Specify packets to reject\n"
	   "Specify packets to forward\n"
	   "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
	   "Maximum prefix length to be matched\n"
	   "Maximum prefix length\n"
	   "Minimum prefix length to be matched\n"
	   "Minimum prefix length\n")

  DEFUNST (ip_prefix_list_description,
	   ip_prefix_list_description_cmd,
	   "ip prefix-list WORD description .LINE",
	   IP_STR
	   PREFIX_LIST_STR
	   "Name of a prefix list\n"
	   "Prefix-list specific description\n"
	   "Up to 80 characters describing this prefix-list\n")

  DEFUNST (no_ip_prefix_list_description,
	   no_ip_prefix_list_description_cmd,
	   "no ip prefix-list WORD description",
	   NO_STR
	   IP_STR
	   PREFIX_LIST_STR
	   "Name of a prefix list\n"
	   "Prefix-list specific description\n")

  DEFUNST (ip_prefix_list_sequence_number,
	   ip_prefix_list_sequence_number_cmd,
	   "ip prefix-list sequence-number",
	   IP_STR
	   PREFIX_LIST_STR
	   "Include/exclude sequence numbers in NVGEN\n")

  DEFUNST (no_ip_prefix_list_sequence_number,
	   no_ip_prefix_list_sequence_number_cmd,
	   "no ip prefix-list sequence-number",
	   NO_STR
	   IP_STR
	   PREFIX_LIST_STR
	   "Include/exclude sequence numbers in NVGEN\n")

  DEFUNST (show_ip_prefix_list_name,
	   show_ip_prefix_list_name_cmd,
	   "show ip prefix-list WORD",
	   SHOW_STR
	   IP_STR
	   PREFIX_LIST_STR
	   "Name of a prefix list\n")

  DEFUNST (show_ip_prefix_list_name_seq,
	   show_ip_prefix_list_name_seq_cmd,
	   "show ip prefix-list WORD seq <1-4294967295>",
	   SHOW_STR
	   IP_STR
	   PREFIX_LIST_STR
	   "Name of a prefix list\n"
	   "sequence number of an entry\n"
	   "Sequence number\n")

  DEFUNST (show_ip_prefix_list_prefix,
	   show_ip_prefix_list_prefix_cmd,
	   "show ip prefix-list WORD A.B.C.D/M",
	   SHOW_STR
	   IP_STR
	   PREFIX_LIST_STR
	   "Name of a prefix list\n"
	   "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n")

  DEFUNST (show_ip_prefix_list_prefix_longer,
	   show_ip_prefix_list_prefix_longer_cmd,
	   "show ip prefix-list WORD A.B.C.D/M longer",
	   SHOW_STR
	   IP_STR
	   PREFIX_LIST_STR
	   "Name of a prefix list\n"
	   "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
	   "Lookup longer prefix\n")

  DEFUNST (show_ip_prefix_list_prefix_first_match,
	   show_ip_prefix_list_prefix_first_match_cmd,
	   "show ip prefix-list WORD A.B.C.D/M first-match",
	   SHOW_STR
	   IP_STR
	   PREFIX_LIST_STR
	   "Name of a prefix list\n"
	   "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
	   "First matched prefix\n")

  DEFUNST (show_ip_prefix_list_summary,
	   show_ip_prefix_list_summary_cmd,
	   "show ip prefix-list summary",
	   SHOW_STR
	   IP_STR
	   PREFIX_LIST_STR
	   "Summary of prefix lists\n")

  DEFUNST (show_ip_prefix_list_summary_name,
	   show_ip_prefix_list_summary_name_cmd,
	   "show ip prefix-list summary WORD",
	   SHOW_STR
	   IP_STR
	   PREFIX_LIST_STR
	   "Summary of prefix lists\n"
	   "Name of a prefix list\n")

  DEFUNST (show_ip_prefix_list_detail,
	   show_ip_prefix_list_detail_cmd,
	   "show ip prefix-list detail",
	   SHOW_STR
	   IP_STR
	   PREFIX_LIST_STR
	   "Detail of prefix lists\n")

  DEFUNST (show_ip_prefix_list_detail_name,
	   show_ip_prefix_list_detail_name_cmd,
	   "show ip prefix-list detail WORD",
	   SHOW_STR
	   IP_STR
	   PREFIX_LIST_STR
	   "Detail of prefix lists\n"
	   "Name of a prefix list\n")

  DEFUNST (clear_ip_prefix_list_name,
	   clear_ip_prefix_list_name_cmd,
	   "clear ip prefix-list WORD",
	   CLEAR_STR
	   IP_STR
	   PREFIX_LIST_STR
	   "Name of a prefix list\n")

  DEFUNST (clear_ip_prefix_list_name_prefix,
	   clear_ip_prefix_list_name_prefix_cmd,
	   "clear ip prefix-list WORD A.B.C.D/M",
	   CLEAR_STR
	   IP_STR
	   PREFIX_LIST_STR
	   "Name of a prefix list\n"
	   "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n")

  DEFUNST (no_ip_prefix_list_prefix,
	   no_ip_prefix_list_prefix_cmd,
	   "no ip prefix-list WORD (deny|permit) (A.B.C.D/M|any)",
	   NO_STR
	   IP_STR
	   PREFIX_LIST_STR
	   "Name of a prefix list\n"
	   "Specify packets to reject\n"
	   "Specify packets to forward\n"
	   "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
	   "Any prefix match.  Same as \"0.0.0.0/0 le 32\"\n")

  DEFUNST (no_ip_prefix_list_ge_le,
	   no_ip_prefix_list_ge_le_cmd,
	   "no ip prefix-list WORD (deny|permit) A.B.C.D/M ge <0-32> le <0-32>",
	   NO_STR
	   IP_STR
	   PREFIX_LIST_STR
	   "Name of a prefix list\n"
	   "Specify packets to reject\n"
	   "Specify packets to forward\n"
	   "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
	   "Minimum prefix length to be matched\n"
	   "Minimum prefix length\n"
	   "Maximum prefix length to be matched\n"
	   "Maximum prefix length\n")


#ifdef HAVE_PDNS_BGP
string*  
BgpRegistry::FindPdnsPeerByInterface(string IfStr) {
      
  String2List_t::iterator iter1;
  InterfaceList_t::iterator iter2;			
  
  for (iter1 = PeerIp2PeerIfTable.begin() ; iter1 != PeerIp2PeerIfTable.end(); ++iter1) 	  
    for (iter2 = iter1->second.begin() ; iter2 != iter1->second.end(); ++iter2) 	  
      if ( iter2->first == IfStr ) 
	return &(iter1->first);
  return NULL;      
}

InterfaceList_t* 
BgpRegistry::FindPdnsNeighbor(string IpStr) {    /*Return the InterfaceList that is stored in
						    the PeerIp2PeerIfTable for the given ip */
  String2List_t::iterator iter;
  for (iter = PeerIp2PeerIfTable.begin() ; iter != PeerIp2PeerIfTable.end(); ++iter) {    
    if (iter->first == IpStr) {	
      if(0)cout<<"ip address "<<IpStr<<" with "
	       <<iter->second.size()<<" interfaces, found in registry PeerIp2PeerIfTable table"
	       <<endl<<flush;	
      return &(iter->second);
    }
  }
  return NULL;
}

int 
BgpRegistry::command(int argc, const char*const* argv) { 
  if (argc == 2)
    {
      if (strcmp(argv[1], "debug") == 0) {
	debug =1 ;
	return (TCL_OK);
      }
      if (strcmp(argv[1], "print-peer-table") == 0) {
	String2List_t::iterator iter1;
	InterfaceList_t::iterator iter2;			
	
	cout<<"Start of Registrty PeerIp2PeerIfTable"<<endl;
	for (iter1 = PeerIp2PeerIfTable.begin() ; iter1 != PeerIp2PeerIfTable.end(); ++iter1) {	  
	  cout << "BGP peer: " << iter1->first.c_str() << endl;  
	  for (iter2 = iter1->second.begin() ; iter2 != iter1->second.end(); ++iter2) {	  
	    cout << "    Interface: " <<iter2->first.c_str() <<
	      " Mask: "<<iter2->second.c_str()<<endl;
	  }
	  cout << endl;		    
	}
	cout<<"End of Registrty PeerIp2PeerIfTable"<<endl;
	return (TCL_OK);
      }
     
    }
  if (argc >= 5)

    {
      if (strcmp(argv[1], "bgp-router") == 0) {
	string PeerIpStr = argv[2];
	InterfaceList_t InterfaceList;
	if((argc-1)%2 != 0) {
	  cout<<"Bgp Registry error: bad argument count"<<argv<<endl;
	  exit(1);
	}
	for (int i = 0;i < (argc-3); i=i+2) { 
	  InterfaceList.push_front
	    (pair<string,string> (string(argv[i+3]),string(argv[i+4])));
	}
	   
	PeerIp2PeerIfTable.push_front
	  (pair<string,InterfaceList_t>(PeerIpStr,InterfaceList));

	return(TCL_OK);
      }
    }
  return (TCL_ERROR);
}


#endif /* HAVE_PDNS_BGP */

/*Returns a list of all the BGP speakers in the simulation*/
BgpList_t*
BgpRegistry::GetAllBgp() {

  BgpList_t* list = new BgpList_t;
  Su2BgpMap_t::iterator itr ; 
  
  for(itr = Su2BgpMap.begin(); itr != Su2BgpMap.end();++itr)
    list->push_back(itr->second);
  
  return list;
}

Bgp::Bgp(double start):mrai_type(MRAI_PER_PREFIX),ssld(false),first_time_insert(1) 
{

    if (!Bgp::enter_bgp_construct) { 
      Bgp::enter_bgp_construct = true;
      Tcl& tcl = Tcl::instance(); 
      tcl.evalc("set con_time [clock seconds]");
    }
    Bgp::instance_cnt++;

    community_list_master.num.head=NULL;
    community_list_master.num.tail=NULL;
    community_list_master.str.head=NULL;
    community_list_master.str.tail=NULL;

#ifndef HAVE_ZEBRA_93b
    bgp_reuse_thread = NULL;
    memset(&bgp_damp_cfg,0,sizeof(struct bgp_damp_config));
    prev_bgp_damp_cfg = NULL;
#endif

    /* ip as-path access-list 10 permit AS1. */

    as_list_master.num.head =   NULL;
    as_list_master.num.tail =   NULL;
    as_list_master.str.head =   NULL;
    as_list_master.str.tail =   NULL;
    as_list_master.add_hook =   NULL;
    as_list_master.delete_hook =    NULL;

    zlog_default = NULL;
    sprintf(new_line,"\n");
    
    access_master_ipv4.num.head =  NULL  ;
    access_master_ipv4.num.tail =  NULL  ;
    access_master_ipv4.str.head =  NULL  ;
    access_master_ipv4.str.tail =  NULL  ;
    access_master_ipv4.add_hook =  NULL  ;
    access_master_ipv4.delete_hook =  NULL  ;

/* Static structure of IPv4 prefix_list's master. */

    prefix_master_ipv4.num.head =    NULL;
    prefix_master_ipv4.num.tail =    NULL;
    prefix_master_ipv4.str.head =    NULL;
    prefix_master_ipv4.str.tail =    NULL;
    prefix_master_ipv4.seqnum =    1;
    prefix_master_ipv4.add_hook =    NULL    ;
    prefix_master_ipv4.delete_hook =    NULL    ;

    route_map_master.head      =  NULL;
    route_map_master.tail      =  NULL;
    route_map_master.add_hook  =  NULL;
    route_map_master.delete_hook= NULL;
    route_map_master.event_hook= NULL;

    for (u_int mtype = 0; mtype < MTYPE_MAX ; mtype++) {
#ifdef MEMORY_LOG
      mstat[mtype].name = NULL;
      mstat[mtype].alloc = 0;
      mstat[mtype].t_malloc = 0;
      mstat[mtype].c_malloc = 0;
      mstat[mtype].t_calloc = 0;
      mstat[mtype].c_calloc = 0;
      mstat[mtype].t_realloc = 0;
      mstat[mtype].t_free = 0;
      mstat[mtype].c_strdup = 0;
#else
      mstat[mtype].name = NULL;
      mstat[mtype].alloc = 0;
#endif /* MTPYE_LOG */
    }
    
    time (&Bgp::start_time);
    
    if(!Bgp::rnd && Bgp::default_randomize) {
      FILE *fpr = NULL;
      int seedval;
      struct timeval timeval;
      Bgp::rnd =1 ;
      
      // If file "seed_with" exists in cwd seed from this file
      // otherwise seed from clock
      
      fpr = fopen("seed_with","r");
      if(fpr){ 
	char buf[512];
	fgets(buf,512,fpr);
	seedval = atoi(buf);
	fclose(fpr);
	printf ("Seed from file with %d\n",seedval);
      } else {
	gettimeofday (&timeval, NULL);
	seedval =(int)timeval.tv_usec;
      }

      srand(seedval);
      
      // Store the seed we use in the file "seed"
      // for debugging
      
      FILE* fp = fopen("seed","w");
      fprintf(fp,"%d\n",seedval);
      fclose(fp);
    }
    
    memset(&host,0,sizeof(struct host));
    timer = new BgpTimer(this);
    debug_on = 0 ;
    InterruptAgent = NULL;
    thread_to_be_fetched = NULL;
    workload_model = NO_WORKLOAD_MODEL;

#ifdef HAVE_ZEBRA_93b
    damp = &bgp_damp_cfg;
#endif
#ifdef HAVE_PDNS_BGP
    last_sendoob_time = -1;   
#endif      
    //Enter bgp_main() immediately
    SET_TIMEOUT_TYPE_MAIN;
    timer->Bgpresched(start); 
}
void print_event_prefixes()
{
	for (int i = 0; i < total_events; i ++)
	{
		cout << "DEBUG: Prefix " << i << " = " << event_prefix[i] << endl;
	}
}

/*****************************************************/
/***************  TCL LINKAGE ************************/
/*****************************************************/

static class BgpClass : public TclClass
{
public:
  BgpClass() : TclClass("Application/Route/Bgp") {}
  TclObject* create(int argc, const char*const* argv) {
    
    if( argc == 5 ) { 
      double start = atof(argv[4]);
      if(start < 0) { 
	printf("Bgp constructor linkage Error: bad start time %s\n",argv[4]);
	return NULL;
      }
      return (new Bgp(start));			
    }
    return(new Bgp(0));
  }
  virtual void bind();
  virtual int method(int argc, const char*const* argv);
} class_bgp_;

void BgpClass::bind()
{
  TclClass::bind();
  add_method("last-update-time");
  add_method("use-log-file");
  add_method("dont-reuse");
  add_method("checkpoint");
}

int BgpClass::method(int ac, const char*const* av)
{
  Tcl& tcl = Tcl::instance();
  int argc = ac - 2;
  const char*const* argv = av + 2;
  if (argc == 2) {
    if (strcmp(argv[1], "last-update-time") == 0) {
      tcl.resultf("%f", Bgp::last_update_time_);
      return (TCL_OK);
    }
    if (strcmp(argv[1], "dont-reuse") == 0) {
      Bgp::dont_reuse = true;
      return (TCL_OK);
    }
    if (strcmp(argv[1], "use-log-file") == 0) {
      if (Bgp::use_log_file_)
	tcl.resultf("%s", Bgp::use_log_file_);	      
      else
	tcl.resultf("");
      return (TCL_OK);
    }
  } else if (argc == 3) {
    if (strcmp(argv[1], "last-update-time") == 0) {
      Bgp::last_update_time_ = atof(argv[2]);
      return (TCL_OK);
    }
    if (strcmp(argv[1], "use-log-file") == 0) {
      Bgp::use_log_file_ = (char*) strdup(argv[2]);
      Bgp::use_log_fp_ = fopen (Bgp::use_log_file_, "w");
      if(Bgp::use_log_fp_)      
	return (TCL_OK);
      else 
	return (TCL_ERROR);
    }
#ifdef HAVE_CONDOR
    if (strcmp(argv[1], "checkpoint") == 0) {
      Bgp::default_randomize = false;
      init_image_with_file_name((char*)argv[2]);	
      return (TCL_OK);
    }
#endif

  }
  return TclClass::method(ac, av);
}

/******************************************************/


void Bgp::bgp_main() 
{

  if (!Bgp::enter_bgp_main) { 
    Bgp::enter_bgp_main = true;
    Tcl& tcl = Tcl::instance(); 
    tcl.evalc("set main_time [clock seconds]; puts  \"BGP constructors elapsed seconds [expr $main_time - $con_time]\"");
  }
  Bgp::instance_cnt--;
  
    //Makes all necessary initializations and enters the bgp FSM.

    // zlog_default is the default logging facility.
    zlog_default = openzlog (Bgp::progname, ZLOG_NOLOG, ZLOG_BGP,
                             LOG_CONS|LOG_NDELAY|LOG_PID, LOG_DAEMON);

    /* Make master thread. */
    master = thread_make_master ();

    /* Initializations. */
    cmd_init (1);
    if(cmdvec_init) memory_init();
    bgp_init();
    sort_node();
    /* static variables flag, only one instance of BGP does the cmd
       associated initialization, the others share the same memory*/
    cmdvec_init = 0;

    /* Parse config file. */
    vty_read_config ();

    /* Make BGP server socket. */
    bgp_serv_sock_family ();

    /* Start the main bgp event loop */
    SET_TIMEOUT_TYPE_FETCH1;
    timer->Bgpresched(0);  

    if (Bgp::instance_cnt == 0) { 
      Tcl& tcl = Tcl::instance(); 
      tcl.evalc("set main_time2 [clock seconds]; puts  \"BGP main elapsed seconds [expr $main_time2 - $main_time]\nEnd of BGP constructors at $main_time2\"");
      
      if(!Bgp::default_randomize) {
	/*First take a checkpoint. Attention this code assumes 
	  that ns was compiled with CONDOR*/
	cout<<"Taking checkpoint"<<endl;
	kill(getpid(),SIGTSTP);	
	
	/*seed*/
	FILE *fpr = NULL;
	int seedval;
	struct timeval timeval;
	Bgp::rnd =1 ;
	
	// If file "seed_with" exists in cwd seed from this file
	// otherwise seed from clock
	
	fpr = fopen("seed_with","r");
	if(fpr){ 
	  char buf[512];
	  fgets(buf,512,fpr);
	  seedval = atoi(buf);
	  fclose(fpr);
	  printf ("Seed from file with %d\n",seedval);
	} else {
	  gettimeofday (&timeval, NULL);
	  seedval =(int)timeval.tv_usec;
	}
	
	srand(seedval);
	
	// Store the seed we use in the file "seed"
	// for debugging
	
	FILE* fp = fopen("seed","w");
	fprintf(fp,"%d\n",seedval);
	fclose(fp);
	

	/*And then randomize*/
	Bgp::bgp_randomize();
      };
    }
}


void Bgp::timeout()
{
  if (debug_on) printf("\n\n%s: TIMEOUT Current Time: %lf\n",name(),NOW);

    switch (type)
    {
      
    case TYPE_MAIN:  
      bgp_main();
      break;
      
    case TYPE_FETCH1 :  
      thread_fetch_part1(master);
      break;
      
    case TYPE_FETCH2 :
      thread_fetch_part2(master,InterruptAgent);
      InterruptAgent = NULL;
      break;
      
    case TYPE_EXECUTE :  
      thread_call(thread_to_be_fetched);
      break;
    }
}


int  
Bgp::sendMessage(const RouteMsg& m, struct peer *peer )
{
  // Check connection status
  if(!(peer->LocalAgent->state() == TCPS_ESTABLISHED))
    return -1;
  
  Bgp * BgpPeer;
  bool found = false;
  BgpPeer = Bgp::Ip2BgpMap->FindBySu(peer->su);
  struct agent_index index = GetLocalIndex(peer->LocalAgent);
  char str[INET_ADDRSTRLEN];

#ifdef HAVE_PDNS_BGP
  double delta = 0;
#endif	
  if(BgpPeer) { 
    Agent2MsgListMap_t::iterator itr;
    
    // find msg list for this connection, 
    // the connection is indexed by the peer->rindex
    
    for(itr = BgpPeer->m_msgs.begin();itr != BgpPeer->m_msgs.end();++itr)
      if(memcmp(&itr->first,&index,sizeof(struct agent_index))==0) { 
	found = true;
	break;
      }
    
    if (!found)
      {
	struct bgp *bgp = bgp_get_default();
	//This could happen if the link is down and the other 
	//end understood that before us and wiped out our msg list.
	return -1;
      }
    
    // Store msg in BgpPeer 's msg list 
    itr->second.second.push_back(m);      
    if (0) printf("\n%s: SendMsg %d pending msgs in peers msg list",name(),itr->second.second.size());

#ifdef HAVE_PDNS_BGP
  } else if(peer->is_peer_remote) {
    //if the peer we are sending to is in
    //another federate.
    struct bgp *bgp = bgp_get_default();
    
    if (NOW == last_sendoob_time) {
      delta = 0.00000000000001;
      /*add a 10 femto seconds to avoid rtikit sychronization problem(out of order delivery)*/
    }
    if (0) vty_out(zlog_default, LOG_DEBUG,"Last Send %1.15lf, Now %1.15lf,delta %1.15lf\n",last_sendoob_time,NOW,delta); 
    SendBgpOOB(RTI_BgpPacket,bgp->su,peer->su,index,(RouteMsg*)&m,delta);
    last_sendoob_time = NOW;
    
    if (0) vty_out(zlog_default, LOG_DEBUG,"%s: %s Send msg at %lf, bytes: %d,delta: %1.15lf\n",peer->LocalAgent->name(),
		   Bgp::inet_ntop(AF_INET,&bgp->id,str,sizeof(str)),Scheduler::instance().clock(),m.Size(),delta);


    
#endif
  } else { 

    char buf[SU_ADDRSTRLEN];
    struct bgp *bgp = bgp_get_default();
    printf("Error(from sendMessage()): peer %s couldnt be found in BGP Registry, Local id: %s\n",
	   bgp->as,inet_sutop (&peer->su, buf),Bgp::inet_ntop(AF_INET,&bgp->id,str,sizeof(str)));
    return 0;
  }
  // Send ns msg
  peer->LocalAgent->advance_bytes(m.Size());
  return m.Size();
}

/* used for debuging */
void Bgp::dump_peer_list (){
    struct peer *peer;
    struct listnode *nn;
    for (nn = peer_list->head; nn; nn  = nn->next)
        if ((peer = ( struct peer * ) nn->data) != NULL)
        {
            printf("%s: peer AS: %d peer ",name(),peer->as);
        }
}

void
Bgp::recv (int nbytes, Agent* pFrom)
{


  struct bgp *bgp = ( struct bgp * ) bgp_get_default();    
  char str[INET_ADDRSTRLEN];

  if (0) vty_out(zlog_default, LOG_DEBUG,"%s: %s Recv msg at %lf, bytes: %d\n",name(),
		 Bgp::inet_ntop(AF_INET,&bgp->id,str,sizeof(str)),Scheduler::instance().clock(),nbytes);

  struct listnode *nn, *mm;
  struct thread *thread;
  struct thread *t;
  /*
    if 0 bytes received, then 
    Tcp connection is opening/closing. 
    This is a hack, used to let the app know 
    when the connection moves to ESTABLISHED, 
    or moves to CLOSE_WAIT (pasive connection 
    termination).
  */
  
  if ( ! nbytes ) {
    // Make dummy msg of 0 size so that the bgpd knows 
    // that tcp connection is closing/opening
    bgp_interrupt(this,(FullTcpAgent*) pFrom,
		  RouteMsg(0));
    return ;
  } else {

    //Get msg    
    Agent2MsgListMap_t::iterator itr ;
    bool found = false;
    struct agent_index rindex = GetRemoteIndex((FullTcpAgent*)pFrom);

    for(itr = m_msgs.begin();itr != m_msgs.end();++itr)
    if(memcmp(&itr->first,&rindex,sizeof(struct agent_index))==0) { 
      found = true;
      break;
    }
    if (!found)
      {
	if (0) vty_out(zlog_default,LOG_DEBUG,"%s:Warning(from recv):  no msg list found for agent%s",
		       name(),VTY_NEWLINE);
	return ;
      }
    //Add the rcvd bytes in the total pending bytes
    itr->second.first += nbytes;
    
    if (0) vty_out(zlog_default,LOG_DEBUG,"%s: Bgp::recv  nb %d rxb %d\n",
		   name(), nbytes,  itr->second.first);
    
    while (true)
      { // Deliver complete messages
	if (itr->second.second.size() == 0 ||  itr->second.first == 0)
	  {
	    if (0) vty_out(zlog_default,LOG_DEBUG,"%s: recv msg list size 0 break\n",name());
	    break;
	  }
	RouteMsg& msg = itr->second.second.front();
	if (itr->second.first < msg.Size())
	  {
	    if (0) vty_out(zlog_default,LOG_DEBUG,"%s: msg size (%d) in queue bigger than rxbb (%d)\n",name(),msg.Size(),itr->second.first);
	    break; // Not enough yet
	  }
	
	itr->second.first -= msg.Size();                // Reduce pending bytes
	if (0) vty_out(zlog_default,LOG_DEBUG,"%s: msg size (%d) new rxbb (%d)\n",name(),msg.Size(),itr->second.first);
	    
	msg.Reset();                                    // Reset offset to beginning
	bgp_interrupt(this,(FullTcpAgent*) pFrom,
		      msg);
	itr->second.second.pop_front();                 // And delete from the deque
      }
    if (itr->second.first && (itr->second.second.size() == 0))
      { // ? HuH, got bytes with no pending message
	
	if (0) vty_out(zlog_default,LOG_DEBUG,"%s: Bgp::recv %d bytes w/o pending message,"
                                           "ignoring\n",name(),itr->second.first);
	itr->second.first = 0;
      }
  }
}
/* This function is used for communication from ns-2 to Zebra code,
   i.e. packet arrivals or user interrupts 
   (using the ' ns at time "BGP execute \"command\"" ' ) invoke the
   bgp_interrupt function that checks the state of the simulated bgpd and 
   reschedules its timer, if necessary, for the simulated now, i.e. invokes
   the bgpd.
*/
void 
Bgp::bgp_interrupt( Bgp* BgpToInterrupt,
		    FullTcpAgent* interruptAgent,RouteMsg intmsg_) 
{

  //we check the timeout state of the BgpToInterrupt   
  int rtype = BgpToInterrupt->type;
  if (0) printf("\n%s: Interrupt",name());
  
  //shoudnt happen
  if (rtype == TYPE_MAIN)  return ; 
  
  if (rtype == TYPE_FETCH2 && (( BgpToInterrupt->timer->expire_ - Scheduler::instance().clock())>0))
      {

	//    If the BgpToInterrupt is waiting for a timer to expire, e.g. the remote peer is inactive, 
	//    we go ahead and reschedule the peer's timer to expire now. We also set the remote peer's 
	//    InterruptAgent variable to let it know who caused the interrupt.
	if (0) printf(" case 1st");
	
	BgpToInterrupt->InterruptAgent = (Agent*) interruptAgent ; 
	BgpToInterrupt->ReceivedMsg = intmsg_;
	BgpToInterrupt->timer->Bgpresched(0.0);
	
      }
    else if ((rtype != TYPE_FETCH2)||(rtype == TYPE_FETCH2 && (( BgpToInterrupt->timer->expire_ - Scheduler::instance().clock())==0 )))
      {
	// If the remote peer is "busy", we insert an entry in it's InterruptQueue 
	
	if (0) printf(" case 2nd");

        struct InterruptInfo  Intr;

        Intr.IntAgent = (Agent*)interruptAgent ;
	Intr.intmsg = intmsg_;
	BgpToInterrupt->InterruptQueue.push_back(Intr);
      }
}

void 
Bgp::bgp_interrupt(Application* a,Agent* interruptAgent) 
{

  if(0) printf("Bgp::bgp_interrupt generic called!\n");
  //we check the timeout state of the BgpToInterrupt   
  Bgp* BgpToInterrupt = (Bgp*)a;
  int rtype = BgpToInterrupt->type;
  if (0) printf("\n%s: Interrupt",BgpToInterrupt->name());
  
  //shoudnt happen
  if (rtype == TYPE_MAIN)  return ; 
  
  if (rtype == TYPE_FETCH2 && (( BgpToInterrupt->timer->expire_ - Scheduler::instance().clock())>0))
      {

	//    If the BgpToInterrupt is waiting for a timer to expire, e.g. the remote peer is inactive, 
	//    we go ahead and reschedule the peer's timer to expire now. We also set the remote peer's 
	//    InterruptAgent variable to let it know who caused the interrupt.
	if (0) printf(" case 1st");
	
	BgpToInterrupt->InterruptAgent = interruptAgent ; 
	BgpToInterrupt->timer->Bgpresched(0.0);
	
      }
    else if ((rtype != TYPE_FETCH2)||(rtype == TYPE_FETCH2 && (( BgpToInterrupt->timer->expire_ - Scheduler::instance().clock())==0 )))
      {
	// If the remote peer is "busy", we insert an entry in it's InterruptQueue 
	
	if (0) printf(" case 2nd");

        struct InterruptInfo  Intr;

        Intr.IntAgent = interruptAgent ;
	BgpToInterrupt->InterruptQueue.push_back(Intr);
      }
}


/* there are two workload models:
   Uniform: each time the simulated bgpd executes sth using the 
     thread_call function, it picks a random value from a user 
     specified range and waits for that period. This pariod corresponds 
     to the execution time of the of the thread call; during this period
     bgp_interrupts are queued, instead of processed.
   Time Sample: the perfctr-2.5.1 kernel patch has to be 
     installed. This workload model is similar to the previous 
     but instead of picking a random number, it measures the execution 
     of the thread_call using the performance counters and then it 
     waits for the measured time.
*/
#ifdef HAVE_PERFCTR
double
Bgp::workload(struct perfctr_sum_ctrs *before) { 
#else 
double
Bgp::workload() { 
#endif /* HAVE_PERFCTR */

  switch (workload_model) 
    {
    case  NO_WORKLOAD_MODEL:
      return 0 ; 
    case  UNIFORM_WORKLOAD_MODEL:
      return (((double)rand()/(double)RAND_MAX)*(uniform_max - uniform_min) + uniform_min);
    case  TIME_SAMPLE_WORKLOAD_MODEL: 
#ifdef HAVE_PERFCTR        
      struct perfctr_sum_ctrs after;
      do_read(&after);
      /*
	return the # cycles it took for this execution 
	times the cpu cycle period
      */	
      double diff = ((double)(after.tsc - before->tsc) /(double)(Bgp::info.cpu_khz*1000));
      if(0) cout <<diff<<endl;
      if( control.cpu_control.tsc_on)
	return diff ;
#endif  /* HAVE_PERFCTR */
      return 0;
    }
}  



int Bgp::command(int argc,const char*const* argv)
{
    if (argc == 2)
    {
        if (strcmp(argv[1], "show-memory") == 0)
	  {	    
	    double simulation_time = Scheduler::instance().clock();
	    printf( "\n At:%lf Total memory usage %ld MB\n",
		    simulation_time,ReportMemUsageMB());
	    return(TCL_OK);
	  }
	if (strcmp(argv[1], "mrai-off") == 0)
	  {
	    mrai_type = MRAI_DISABLE;
	    return(TCL_OK);
	  }
	if (strcmp(argv[1], "mrai-per-peer") == 0)
	  {
	    mrai_type = MRAI_PER_PEER;
	    return(TCL_OK);
	  }
	if (strcmp(argv[1], "ssld-on") == 0)
	  {
	    ssld = true;
	    return(TCL_OK);
	  }
	if (strcmp(argv[1], "ssld-off") == 0)
	  {
	    ssld = false;
	    return(TCL_OK);
	  }
    }

    if (argc == 3)
      {
        if (strcmp(argv[1], "finish-time") == 0)
	  {
	    cout<<" Warning the \"bgp-instance finish-time time\" command is not required any more"<<endl;
            return(TCL_OK);
	  }
        if (strcmp(argv[1], "register") == 0)
	  {
            //cout<<" Warning the \"bgp-instance register bgp-registry\""
	    //	<<" command is not necessary from  bgp++ 1.05."
	    //	<<" BGP instances are now registered automatically"<<endl;
	    //Tcl& tcl = Tcl::instance();
            //Bgp::Ip2BgpMap = (BgpRegistry*) TclObject::lookup(argv[2]);
            return(TCL_OK);
	  }
        if (strcmp(argv[1], "config-file") == 0)
	  {
	    strcpy(bgp_config_file,argv[2]);
	    return(TCL_OK);
	  }
	if (strcmp(argv[1], "start-time") == 0)
	  {
	    double time_to_start = atof(argv[2]);
	    
	    if (time_to_start < 0 || type != TYPE_MAIN) return (TCL_ERROR) ;
	    
	    timer->Bgpresched(time_to_start); 
	    return(TCL_OK);
	  }
	if (strcmp(argv[1], "command") == 0)
	  {
	    if (type==TYPE_MAIN) return (TCL_ERROR);
	    struct vty *vty;
	    struct _vector* vline;
	    int ret; 
	    
	    vty = vty_new ();
	    vty->node = CONFIG_NODE;
	    vty->index = bgp_get_default(); 
	    vline = cmd_make_strvec ((char*)argv[2]);
	    
	    if (vline == NULL)
	      return(TCL_OK);
	    
	    /* Execute configuration command : this is strict match */
	    
            /* Echo the command */
            vty_out (zlog_default,LOG_DEBUG, ">%s%s", argv[2], VTY_NEWLINE);

	    ret = cmd_execute_command_strict (vline, vty, NULL);
	    
	    cmd_free_strvec (vline);
	    
	    if ((ret != CMD_SUCCESS) && (ret != CMD_WARNING) )
	      {
		switch (ret)
		{
		case CMD_ERR_AMBIGUOUS:
		  fprintf (stderr, "Ambiguous command.\n");
		  break;
		case CMD_ERR_NO_MATCH:
		  fprintf (stderr, "There is no such command.\n");
		  break;
		}
		fprintf (stderr, "Error occured during reading below line.\n%s\nfrom tcl configuration file\n", 
			 argv[2]);
		vty_close (vty);
		exit (1);
	      }
	    
	    vty_close (vty);
	    bgp_interrupt(this,NULL,
			  RouteMsg());
	    
	    return(TCL_OK);
	  }    
        if (strcmp(argv[1], "table-lookup") == 0)
	  {
	    int ret;
	    NsObject *target_link = NULL;
	    struct prefix p;

	    ret = str2prefix((char*)argv[2],&p);
	    if (ret <= 0)
	      {
		printf("table-lookup: IP address prefix/prefixlen is malformed\n");			 
		return (TCL_OK);
	      }

	    target_link = bgp_table_lookup (&p.u.prefix4);
	    if (target_link) printf("Table Lookup Result: Local interface %s to be used for ip %s\n",target_link->name(),argv[2]);
	    else printf("Table Lookup Result: No match found for ip %s\n",argv[2]);

            return(TCL_OK);
	  }

      }
    if (argc == 4)
      {
        if (strcmp(argv[1], "registry-find") == 0)
        {
            printf("LOOKING FOR BGP %s",argv[2]);
            // For Testing it has to be called at t>0.0 
            union sockunion  su;
            char str[INET_ADDRSTRLEN];
            strcpy(str,argv[2]);
            str2sockunion (str,&su);
            Bgp * bgpcl = Bgp::Ip2BgpMap->FindBySu(su);
            Tcl& tcl = Tcl::instance();
            Bgp * rbgp = (Bgp*) TclObject::lookup(argv[3]);
            if (bgpcl == rbgp) puts(" FOUND IT");
            else puts(" DIDNT FIND IT");
            return(TCL_OK);
        }


    }

    if (strcmp(argv[1], "cpu-load-model") == 0)
      { 
	if (argc == 3) {
#ifdef HAVE_PERFCTR
	  if(strcmp(argv[2], "time-sample") == 0) {
	    workload_model =  TIME_SAMPLE_WORKLOAD_MODEL;
	    if(!Bgp::perfcnt_init) { 
	      Bgp::info = do_init();
	      do_setup(Bgp::info);
	      do_enable();
	      Bgp::perfcnt_init = 1;
	    }
	    return(TCL_OK);
	  }
#endif /* HAVE_PERFCTR */

	  if(strcmp(argv[2], "no") == 0) {
	    workload_model = NO_WORKLOAD_MODEL;
	    return(TCL_OK);
	  }
	}
	if (argc == 5) {
	  if(strcmp(argv[2], "uniform") == 0) {
	    workload_model =  UNIFORM_WORKLOAD_MODEL;

	    Bgp::uniform_max = atof(argv[3]);
	    Bgp::uniform_min = atof(argv[4]);

	    if (uniform_max <= uniform_min) {
	      fprintf(stderr,"class Bgp:uniform command: bad syntax max %s is not bigger than min %s",argv[3],argv[4]);
	      exit(1);
	    }	    
	    return(TCL_OK);
	  }
	}
      }
    
    return RouteApp::command(argc,argv);
}


FullTcpAgent * 
Bgp::get_remoteagent_by_localagent (FullTcpAgent * lagent) { 
  
    Tcl& tcl = Tcl::instance();

    // Get the id of the destination node of the local Agent
    char node_id[12];
    tcl.evalf("%s set dst_addr_", lagent->name());
    strcpy(node_id,tcl.result());

    // Get the destination port of the local agent.
    tcl.evalf("%s set dst_port_", lagent->name());
    int port = atoi(tcl.result());
    
    // Get the destination node by the node_id
    char node[12];
    tcl.evalf("[ Simulator instance ] get-node-by-id %s",node_id);
    strcpy(node,tcl.result());
    
    // Get the remote agent 
    tcl.evalf("%s agent %d",node,port);
    return  ((FullTcpAgent*) TclObject::lookup(tcl.result()));

}


////////////////////////////////////////////////
////////////////////////////////////////////////
/////////////////////bgp_aspath.c///////////////
////////////////////////////////////////////////


struct aspath *
Bgp::aspath_new ()
{
    struct aspath *aspath;

    aspath = (struct aspath * ) XMALLOC (MTYPE_AS_PATH, sizeof (struct aspath));
    memset (aspath, 0, sizeof (struct aspath));
    return aspath;
}

/* Free AS path structure. */
void
Bgp::aspath_free (struct aspath *aspath)
{
    if (!aspath)
        return;
    if (aspath->data)
        XFREE (MTYPE_AS_SEG, aspath->data);
    if (aspath->str)
        XFREE (MTYPE_AS_STR, aspath->str);
    XFREE (MTYPE_AS_PATH, aspath);
}

/* Unintern aspath from AS path bucket. */
void
Bgp::aspath_unintern (struct aspath *aspath)
{
    struct aspath *ret;

    if (aspath->refcnt)
        aspath->refcnt--;

    if (aspath->refcnt == 0)
    {
        /* This aspath must exist in aspath hash table. */
        ret = (struct aspath * ) hash_pull (ashash, aspath);
        assert (ret != NULL);
        aspath_free (aspath);
    }
}

/* Return the start or end delimiters for a particular Segment type */
char
Bgp::aspath_delimiter_char (u_char type, u_char which)
{
    int i;
    struct
    {
        int type;
        char start;
        char end;
    } aspath_delim_char [] =
    {
        { AS_SET,             '{', '}'},
        { AS_SEQUENCE,        ' ', ' '},
        { AS_CONFED_SET,      '[', ']'},
        { AS_CONFED_SEQUENCE, '(', ')'},
        { 0}
    };

    for (i = 0; aspath_delim_char[i].type != 0; i++)
    {
        if (aspath_delim_char[i].type == type)
        {
            if (which == AS_SEG_START)
                return aspath_delim_char[i].start;
            else if (which == AS_SEG_END)
                return aspath_delim_char[i].end;
        }
    }
    return ' ';
}

/* Convert aspath structure to string expression. */
char *
Bgp::aspath_make_str_count (struct aspath *as)
{
    int space;
    u_char type;
    caddr_t pnt;
    caddr_t end;
    struct assegment *assegment;
    int str_size = ASPATH_STR_DEFAULT_LEN;
    int str_pnt;
    u_char *str_buf;
    int count = 0;

    /* Empty aspath. */
    if (as->length == 0)
    {
        str_buf = ( u_char * ) XMALLOC (MTYPE_AS_STR, 1);
        str_buf[0] = '\0';
        as->count = count;
        char * str_tmp= (char * ) str_buf;
        return  str_tmp;
    }

    /* Set default value. */
    space = 0;
    type = AS_SEQUENCE;

    /* Set initial pointer. */
    pnt = as->data;
    end = (char * ) ( pnt + as->length ) ;

    str_buf = (u_char * ) XMALLOC (MTYPE_AS_STR, str_size);
    str_pnt = 0;

    assegment = (struct assegment *) pnt;

    while (pnt < end)
    {
        int i;
        int estimate_len;

        /* For fetch value. */
        assegment = (struct assegment *) pnt;

        /* Check AS type validity. */
        if ((assegment->type != AS_SET) && 
            (assegment->type != AS_SEQUENCE) &&
            (assegment->type != AS_CONFED_SET) && 
            (assegment->type != AS_CONFED_SEQUENCE))
        {
            XFREE (MTYPE_AS_STR, str_buf);
            return NULL;
        }

        /* Check AS length. */
        if ((pnt + (assegment->length * AS_VALUE_SIZE) + AS_HEADER_SIZE) > end)
        {
            XFREE (MTYPE_AS_STR, str_buf);
            return NULL;
        }

        /* Buffer length check. */
        estimate_len = ((assegment->length * 6) + 4);

        /* String length check. */
        while (str_pnt + estimate_len >= str_size)
        {
            str_size *= 2;
            str_buf = (u_char * )  XREALLOC (MTYPE_AS_STR, str_buf, str_size);
        }

        /* If assegment type is changed, print previous type's end
       character. */
        if (type != AS_SEQUENCE)
            str_buf[str_pnt++] = aspath_delimiter_char (type, AS_SEG_END);
        if (space)
            str_buf[str_pnt++] = ' ';

        if (assegment->type != AS_SEQUENCE)
            str_buf[str_pnt++] = aspath_delimiter_char (assegment->type, AS_SEG_START);

        space = 0;

        /* Increment count - ignoring CONFED SETS/SEQUENCES */
        if (assegment->type != AS_CONFED_SEQUENCE
            && assegment->type != AS_CONFED_SET)
        {
            if (assegment->type == AS_SEQUENCE)
                count += assegment->length;
            else if (assegment->type == AS_SET)
                count++;
        }

        for (i = 0; i < assegment->length; i++)
        {
            int len;

            if (space)
            {
                if (assegment->type == AS_SET
                    || assegment->type == AS_CONFED_SET)
                    str_buf[str_pnt++] = ',';
                else
                    str_buf[str_pnt++] = ' ';
            } else
                space = 1;

            len = sprintf ((char * )(str_buf + str_pnt), "%d", ntohs (assegment->asval[i]));
            str_pnt += len;
        }

        type = assegment->type;
        pnt += (assegment->length * AS_VALUE_SIZE) + AS_HEADER_SIZE;
    }

    if (assegment->type != AS_SEQUENCE)
        str_buf[str_pnt++] = aspath_delimiter_char (assegment->type, AS_SEG_END);

    str_buf[str_pnt] = '\0';

    as->count = count;

    return(char*)str_buf;
}

/* Intern allocated AS path. */
struct aspath *
Bgp::aspath_intern (struct aspath *aspath)
{
    struct aspath *find;

    /* Assert this AS path structure is not interned. */
    assert (aspath->refcnt == 0);
    assert (aspath->str == NULL);

    /* Check AS path hash. */
    find = (struct aspath * ) hash_search (ashash, aspath);
    if (find)
    {
        aspath_free (aspath);
        find->refcnt++;
        return find;
    }

    /* Push New AS path to AS path hash. */
    aspath->refcnt = 1;
    aspath->str = aspath_make_str_count (aspath);
    hash_push (ashash, aspath);

    return aspath;
}

/* Duplicate aspath structure.  Created same aspath structure but
   reference count and AS path string is cleared. */
struct aspath *
Bgp::aspath_dup (struct aspath *aspath)
{
    struct aspath *New;

    New = ( struct aspath * ) XMALLOC (MTYPE_AS_PATH, sizeof (struct aspath));
    memset (New, 0, sizeof (struct aspath));

    New->length = aspath->length;

    if (New->length)
    {
        New->data = ( char * ) XMALLOC (MTYPE_AS_SEG, aspath->length);
        memcpy (New->data, aspath->data, aspath->length);
    } else
        New->data = NULL;

    /*New->str = aspath_make_str_count (aspath); */

    return New;
}

/* AS path parse function.  pnt is a pointer to byte stream and length
   is length of byte stream.  If there is same AS path in the the AS
   path hash then return it else make New AS path structure. */
struct aspath *
Bgp::aspath_parse (caddr_t pnt, int length)
{
    struct aspath as;
    struct aspath *find;
    struct aspath *aspath;

    /* If length is odd it's malformed AS path. */
    if (length % 2)
    {
        return NULL;
    }
    /* Looking up aspath hash entry. */
    as.data = pnt;
    as.length = length;

    /* If already same aspath exist then return it. */
    find =( struct aspath * )  hash_search (ashash, &as);
    if (find)
    {
        find->refcnt++;
        return find;
    }

    /* New aspath strucutre is needed. */
    aspath = ( struct aspath * ) XMALLOC (MTYPE_AS_PATH, sizeof (struct aspath));
    memset ((void *)aspath, 0, sizeof (struct aspath));
    aspath->length = length;

    /* In case of IBGP connection aspath's length can be zero. */
    if (length)
    {
        aspath->data = (char * ) XMALLOC (MTYPE_AS_SEG, length);
        memcpy (aspath->data, pnt, length);
    } else
        aspath->data = NULL;

    /* Make AS path string. */
    aspath->str = aspath_make_str_count (aspath);

    /* Malformed AS path value. */
    if (! aspath->str)
    {
        aspath_free (aspath);
        return NULL;
    }

    /* Reference count set to 1. */
    aspath->refcnt = 1;

    /* Everyting OK, push this AS path to the AS path hash backet. */
    hash_push (ashash, aspath);

    return aspath;
}


struct aspath *
Bgp::aspath_aggregate_segment_copy (struct aspath *aspath, struct assegment *seg,
                                    int i)
{
    struct assegment *newseg;

    if (! aspath->data)
    {
        aspath->data = ( char * ) XMALLOC (MTYPE_AS_SEG, ASSEGMENT_SIZE (i));
        newseg = (struct assegment *) aspath->data;
        aspath->length = ASSEGMENT_SIZE (i);
    } else
    {
        aspath->data = ( char * ) XREALLOC (MTYPE_AS_SEG, aspath->data,
                                            aspath->length + ASSEGMENT_SIZE (i));
        newseg = (struct assegment *) (aspath->data + aspath->length);
        aspath->length += ASSEGMENT_SIZE (i);
    }

    newseg->type = seg->type;
    newseg->length = i;
    memcpy (newseg->asval, seg->asval, (i * AS_VALUE_SIZE));

    return aspath;
}

struct assegment *
Bgp::aspath_aggregate_as_set_add (struct aspath *aspath, struct assegment *asset,
                                  as_t as)
{
    int i;

    /* If this is first AS set member, create New as-set segment. */
    if (asset == NULL)
    {
        if (! aspath->data)
        {
            aspath->data = ( char * ) XMALLOC (MTYPE_AS_SEG, ASSEGMENT_SIZE (1));
            asset = (struct assegment *) aspath->data;
            aspath->length = ASSEGMENT_SIZE (1);
        } else
        {
            aspath->data = ( char * ) XREALLOC (MTYPE_AS_SEG, aspath->data,
                                                aspath->length + ASSEGMENT_SIZE (1));
            asset = (struct assegment *) (aspath->data + aspath->length);
            aspath->length += ASSEGMENT_SIZE (1);
        }
        asset->type = AS_SET;
        asset->length = 1;
        asset->asval[0] = as;
    } else
    {
        size_t offset;

        /* Check this AS value already exists or not. */
        for (i = 0; i < asset->length; i++)
            if (asset->asval[i] == as)
                return asset;

        offset = (caddr_t) asset - (caddr_t) aspath->data;
        aspath->data = ( char * ) XREALLOC (MTYPE_AS_SEG, aspath->data,
                                            aspath->length + AS_VALUE_SIZE);

        asset = (struct assegment *) (aspath->data + offset);
        aspath->length += AS_VALUE_SIZE;
        asset->asval[asset->length] = as;
        asset->length++;
    }

    return asset;
}

/* Modify as1 using as2 for aggregation. */
struct aspath *
Bgp::aspath_aggregate (struct aspath *as1, struct aspath *as2)
{
    int i;
    int minlen;
    int match;
    int match1;
    int match2;
    caddr_t cp1;
    caddr_t cp2;
    caddr_t end1;
    caddr_t end2;
    struct assegment *seg1;
    struct assegment *seg2;
    struct aspath *aspath;
    struct assegment *asset;

    match = 0;
    minlen = 0;
    aspath = NULL;
    asset = NULL;
    cp1 = as1->data;
    end1 = as1->data + as1->length;
    cp2 = as2->data;
    end2 = as2->data + as2->length;

    seg1 = (struct assegment *) cp1;
    seg2 = (struct assegment *) cp2;

    /* First of all check common leading sequence. */
    while ((cp1 < end1) && (cp2 < end2))
    {
        /* Check segment type. */
        if (seg1->type != seg2->type)
            break;

        /* Minimum segment length. */
        minlen = min (seg1->length, seg2->length);

        for (match = 0; match < minlen; match++)
            if (seg1->asval[match] != seg2->asval[match])
                break;

        if (match)
        {
            if (! aspath)
                aspath = aspath_new();
            aspath = aspath_aggregate_segment_copy (aspath, seg1, match);
        }

        if (match != minlen || match != seg1->length 
            || seg1->length != seg2->length)
            break;

        cp1 += ((seg1->length * AS_VALUE_SIZE) + AS_HEADER_SIZE);
        cp2 += ((seg2->length * AS_VALUE_SIZE) + AS_HEADER_SIZE);

        seg1 = (struct assegment *) cp1;
        seg2 = (struct assegment *) cp2;
    }

    if (! aspath)
        aspath = aspath_new();

    /* Make as-set using rest of all information. */
    match1 = match;
    while (cp1 < end1)
    {
        seg1 = (struct assegment *) cp1;

        for (i = match1; i < seg1->length; i++)
            asset = aspath_aggregate_as_set_add (aspath, asset, seg1->asval[i]);

        match1 = 0;
        cp1 += ((seg1->length * AS_VALUE_SIZE) + AS_HEADER_SIZE);
    }

    match2 = match;
    while (cp2 < end2)
    {
        seg2 = (struct assegment *) cp2;

        for (i = match2; i < seg2->length; i++)
            asset = aspath_aggregate_as_set_add (aspath, asset, seg2->asval[i]);

        match2 = 0;
        cp2 += ((seg2->length * AS_VALUE_SIZE) + AS_HEADER_SIZE);
    }

    return aspath;
}

/* AS path loop check.  If aspath contains asno then return 1. */
int
Bgp::aspath_loop_check (struct aspath *aspath, as_t asno)
{
    caddr_t pnt;
    caddr_t end;
    struct assegment *assegment;

    if (aspath == NULL)
        return 0;

    pnt = aspath->data;
    end = aspath->data + aspath->length;

    while (pnt < end)
    {
        int i;
        assegment = (struct assegment *) pnt;

        for (i = 0; i < assegment->length; i++)
            if (assegment->asval[i] == htons(asno))
                return 1;

        pnt += (assegment->length * AS_VALUE_SIZE) + AS_HEADER_SIZE;
    }
    return 0;
}

/* Command for enforce-first-as. */
int
Bgp::aspath_firstas_check (struct aspath *aspath, as_t asno)
{
    caddr_t pnt;
    struct assegment *assegment;

    if (aspath == NULL)
        return 0;

    pnt = aspath->data;
    assegment = (struct assegment *) pnt;

    if (assegment
        && assegment->type == AS_SEQUENCE
        && assegment->asval[0] == htons (asno))
        return 1;

    return 0;
}

/* Merge as1 to as2.  as2 should be uninterned aspath. */
struct aspath *
Bgp::aspath_merge (struct aspath *as1, struct aspath *as2)
{
    caddr_t data;

    if (! as1 || ! as2)
        return NULL;

    data =( char * )  XMALLOC (MTYPE_AS_SEG, as1->length + as2->length);
    memcpy (data, as1->data, as1->length);
    memcpy (data + as1->length, as2->data, as2->length);

    XFREE (MTYPE_AS_SEG, as2->data);
    as2->data = data;
    as2->length += as1->length;
    as2->count += as1->count;
    return as2;
}

/* Prepend as1 to as2.  as2 should be uninterned aspath. */
struct aspath *
Bgp::aspath_prepend (struct aspath *as1, struct aspath *as2)
{
    caddr_t pnt;
    caddr_t end;
    struct assegment *seg1 = NULL;
    struct assegment *seg2 = NULL;

    if (! as1 || ! as2)
        return NULL;

    seg2 = (struct assegment *) as2->data;

    /* In case of as2 is empty AS. */
    if (seg2 == NULL)
    {
        as2->length = as1->length;
        as2->data =  ( char * ) XMALLOC (MTYPE_AS_SEG, as1->length);
        as2->count = as1->count;
        memcpy (as2->data, as1->data, as1->length);
        return as2;
    }

    /* assegment points last segment of as1. */
    pnt = as1->data;
    end = as1->data + as1->length;
    while (pnt < end)
    {
        seg1 = (struct assegment *) pnt;
        pnt += (seg1->length * AS_VALUE_SIZE) + AS_HEADER_SIZE;
    }

    /* In case of as1 is empty AS. */
    if (seg1 == NULL)
        return as2;

    /* Compare last segment type of as1 and first segment type of as2. */
    if (seg1->type != seg2->type)
        return aspath_merge (as1, as2);

    if (seg1->type == AS_SEQUENCE)
    {
        caddr_t newdata;
        struct assegment *seg = NULL;

        newdata = ( char * ) XMALLOC (MTYPE_AS_SEG, 
                                      as1->length + as2->length - AS_HEADER_SIZE);
        memcpy (newdata, as1->data, as1->length);
        seg = (struct assegment *) (newdata + ((caddr_t)seg1 - as1->data));
        seg->length += seg2->length;
        memcpy (newdata + as1->length, as2->data + AS_HEADER_SIZE,
                as2->length - AS_HEADER_SIZE);

        XFREE (MTYPE_AS_SEG, as2->data);
        as2->data = newdata;
        as2->length += (as1->length - AS_HEADER_SIZE);
        as2->count += as1->count;

        return as2;
    } else
    {
        /* AS_SET merge code is needed at here. */
        return aspath_merge (as1, as2);
    }

    /* Not reached */
}

/* Add specified AS to the leftmost of aspath. */
struct aspath *
Bgp::aspath_add_one_as (struct aspath *aspath, as_t asno, u_char type)
{
    struct assegment *assegment;

    assegment = (struct assegment *) aspath->data;

    /* In case of empty aspath. */
    if (assegment == NULL || assegment->length == 0)
    {
        aspath->length = AS_HEADER_SIZE + AS_VALUE_SIZE;

        if (assegment)
            aspath->data = ( char * ) XREALLOC (MTYPE_AS_SEG, aspath->data, aspath->length);
        else
            aspath->data = ( char * ) XMALLOC (MTYPE_AS_SEG, aspath->length);

        assegment = (struct assegment *) aspath->data;
        assegment->type = type;
        assegment->length = 1;
        assegment->asval[0] = htons (asno);

        return aspath;
    }

    if (assegment->type == type)
    {
        caddr_t newdata;
        struct assegment *newsegment;

        newdata = ( char * ) XMALLOC (MTYPE_AS_SEG, aspath->length + AS_VALUE_SIZE);
        newsegment = (struct assegment *) newdata;

        newsegment->type = type;
        newsegment->length = assegment->length + 1;
        newsegment->asval[0] = htons (asno);

        memcpy (newdata + AS_HEADER_SIZE + AS_VALUE_SIZE,
                aspath->data + AS_HEADER_SIZE, 
                aspath->length - AS_HEADER_SIZE);

        XFREE (MTYPE_AS_SEG, aspath->data);

        aspath->data = newdata;
        aspath->length += AS_VALUE_SIZE;
    } else
    {
        caddr_t newdata;
        struct assegment *newsegment;

        newdata = ( char * ) XMALLOC (MTYPE_AS_SEG, aspath->length + AS_VALUE_SIZE + AS_HEADER_SIZE);
        newsegment = (struct assegment *) newdata;

        newsegment->type = type;
        newsegment->length = 1;
        newsegment->asval[0] = htons (asno);

        memcpy (newdata + AS_HEADER_SIZE + AS_VALUE_SIZE,
                aspath->data,
                aspath->length);

        XFREE (MTYPE_AS_SEG, aspath->data);

        aspath->data = newdata;
        aspath->length += AS_HEADER_SIZE + AS_VALUE_SIZE;
    }

    return aspath;
}

/* Add specified AS to the leftmost of aspath. */
struct aspath *
Bgp::aspath_add_seq (struct aspath *aspath, as_t asno)
{
    return aspath_add_one_as (aspath, asno, AS_SEQUENCE);
}

/* Compare leftmost AS value for MED check.  If as1's leftmost AS and
   as2's leftmost AS is same return 1. */
int
Bgp::aspath_cmp_left (struct aspath *aspath1, struct aspath *aspath2)
{
    struct assegment *seg1;
    struct assegment *seg2;
    as_t as1;
    as_t as2;

    seg1 = (struct assegment *) aspath1->data;
    seg2 = (struct assegment *) aspath2->data;

    while (seg1 && seg1->length 
           && (seg1->type == AS_CONFED_SEQUENCE || seg1->type == AS_CONFED_SET))
        seg1 = (struct assegment *) ((caddr_t) seg1 + ASSEGMENT_LEN (seg1));
    while (seg2 && seg2->length 
           && (seg2->type == AS_CONFED_SEQUENCE || seg2->type == AS_CONFED_SET))
        seg2 = (struct assegment *) ((caddr_t) seg2 + ASSEGMENT_LEN (seg2));

    /* Check as1's */
    if (seg1 == NULL || seg1->length == 0 || seg1->type != AS_SEQUENCE)
        return 0;
    as1 = seg1->asval[0];

    if (seg2 == NULL || seg2->length == 0 || seg2->type != AS_SEQUENCE)
        return 0;
    as2 = seg2->asval[0];

    if (as1 == as2)
        return 1;

    return 0;
}

/* Compare leftmost AS value for MED check.  If as1's leftmost AS and
   as2's leftmost AS is same return 1. (confederation as-path
   only).  */
int
Bgp::aspath_cmp_left_confed (struct aspath *aspath1, struct aspath *aspath2)
{
    struct assegment *seg1;
    struct assegment *seg2;

    as_t as1;
    as_t as2;

    if (aspath1->count || aspath2->count)
        return 0;

    seg1 = (struct assegment *) aspath1->data;
    seg2 = (struct assegment *) aspath2->data;

    /* Check as1's */
    if (seg1 == NULL || seg1->length == 0 || seg1->type != AS_CONFED_SEQUENCE)
        return 0;
    as1 = seg1->asval[0];

    /* Check as2's */
    if (seg2 == NULL || seg2->length == 0 || seg2->type != AS_CONFED_SEQUENCE)
        return 0;
    as2 = seg2->asval[0];

    if (as1 == as2)
        return 1;

    return 0;
}

/* Delete first sequential AS_CONFED_SEQUENCE from aspath.  */
struct aspath *
Bgp::aspath_delete_confed_seq (struct aspath *aspath)
{
    int seglen;
    struct assegment *assegment;

    if (! aspath)
        return aspath;

    assegment = (struct assegment *) aspath->data;

    while (assegment)
    {
        if (assegment->type != AS_CONFED_SEQUENCE)
            return aspath;

        seglen = ASSEGMENT_LEN (assegment);

        if (seglen == aspath->length)
        {
            XFREE (MTYPE_AS_SEG, aspath->data);
            aspath->data = NULL;
            aspath->length = 0;
        } else
        {
            memcpy (aspath->data, aspath->data + seglen,
                    aspath->length - seglen);
            aspath->data = (char * ) XREALLOC (MTYPE_AS_SEG, aspath->data,
                                               aspath->length - seglen);
            aspath->length -= seglen;
        }

        assegment = (struct assegment *) aspath->data;
    }
    return aspath;
}

/* Add New AS number to the leftmost part of the aspath as
   AS_CONFED_SEQUENCE.  */
struct aspath*
Bgp::aspath_add_confed_seq (struct aspath *aspath, as_t asno)
{
    return aspath_add_one_as (aspath, asno, AS_CONFED_SEQUENCE);
}

/* Add New as value to as path structure. */
void
Bgp::aspath_as_add (struct aspath *as, as_t asno)
{
    caddr_t pnt;
    caddr_t end;
    struct assegment *assegment;

    /* Increase as->data for New as value. */
    as->data = (char * ) XREALLOC (MTYPE_AS_SEG, as->data, as->length + 2);
    as->length += 2;

    pnt = as->data;
    end = as->data + as->length;
    assegment = (struct assegment *) pnt;

    /* Last segment search procedure. */
    while (pnt + 2 < end)
    {
        assegment = (struct assegment *) pnt;

        /* We add 2 for segment_type and segment_length and segment
       value assegment->length * 2. */
        pnt += (AS_HEADER_SIZE + (assegment->length * AS_VALUE_SIZE));
    }

    assegment->asval[assegment->length] = htons (asno);
    assegment->length++;
}

/* Add New as segment to the as path. */
void
Bgp::aspath_segment_add (struct aspath *as, int type)
{
    struct assegment *assegment;


    if (as->data == NULL)
    {
        as->data = (char * ) XMALLOC (MTYPE_AS_SEG, 2);
        assegment = (struct assegment *) as->data;
        as->length = 2;
    } else
    {
        as->data = (char * ) XREALLOC (MTYPE_AS_SEG, as->data, as->length + 2);
        assegment = (struct assegment *) (as->data + as->length);
        as->length += 2;
    }

    assegment->type = type;
    assegment->length = 0;
}

struct aspath *
Bgp::aspath_empty ()
{
    return aspath_parse (NULL, 0);
}

unsigned long
Bgp::aspath_count ()
{
    return ashash->count;
}     


/* Return next token and point for string parse. */
char *
Bgp::aspath_gettoken (char *buf, enum as_token *token, u_short *asno)
{
    char *p = buf;

    /* Skip space. */
    while (isspace ((int) *p))
        p++;

    /* Check the end of the string and type specify characters
       (e.g. {}()). */
    switch (*p)
    {
    case '\0':
        return NULL;
        break;
    case '{':
        *token = as_token_set_start;
        p++;
        return p;
        break;
    case '}':
        *token = as_token_set_end;
        p++;
        return p;
        break;
    case '(':
        *token = as_token_confed_start;
        p++;
        return p;
        break;
    case ')':
        *token = as_token_confed_end;
        p++;
        return p;
        break;
    }

    /* Check actual AS value. */
    if (isdigit ((int) *p))
    {
        u_short asval;

        *token = as_token_asval;
        asval = (*p - '0');
        p++;
        while (isdigit ((int) *p))
        {
            asval *= 10;
            asval += (*p - '0');
            p++;
        }
        *asno = asval;
        return p;
    }

    /* There is no match then return unknown token. */
    *token = as_token_unknown;
    return  p++;
}

struct aspath *
Bgp::aspath_str2aspath (char *str)
{
    enum as_token token;
    u_short as_type;
    u_short asno;
    struct aspath *aspath;
    int needtype;

    aspath = aspath_new ();

    /* We start default type as AS_SEQUENCE. */
    as_type = AS_SEQUENCE;
    needtype = 1;

    while ((str = aspath_gettoken (str, &token, &asno)) != NULL)
    {
        switch (token)
        {
        case as_token_asval:
            if (needtype)
            {
                aspath_segment_add (aspath, as_type);
                needtype = 0;
            }
            aspath_as_add (aspath, asno);
            break;
        case as_token_set_start:
            as_type = AS_SET;
            aspath_segment_add (aspath, as_type);
            needtype = 0;
            break;
        case as_token_set_end:
            as_type = AS_SEQUENCE;
            needtype = 1;
            break;
        case as_token_confed_start:
            as_type = AS_CONFED_SEQUENCE;
            aspath_segment_add (aspath, as_type);
            needtype = 0;
            break;
        case as_token_confed_end:
            as_type = AS_SEQUENCE;
            needtype = 1;
            break;
        case as_token_unknown:
        default:
            return NULL;
            break;
        }
    }

    aspath->str = aspath_make_str_count (aspath);

    return aspath;
}

/* Make hash value by raw aspath data. */
unsigned int
Bgp::aspath_key_make (struct aspath *aspath)
{
    unsigned int key = 0;
    int length;
    caddr_t pnt;

    length = aspath->length;
    pnt = aspath->data;

    while (length)
        key += pnt[--length];

    return key %= HASHTABSIZE;
}

/* If two aspath have same value then return 1 else return 0 */
int
Bgp::aspath_cmp (struct aspath *as1, struct aspath *as2)
{
    if (as1->length == as2->length 
        && !memcmp (as1->data, as2->data, as1->length))
        return 1;
    else
        return 0;
}

/* AS path hash initialize. */
void
Bgp::aspath_init ()
{
    ashash = hash_new (HASHTABSIZE);
    ashash->hash_key = ( unsigned  int (*) (void * )) &Bgp::aspath_key_make;
    ashash->hash_cmp = ( int (*) (void *, void *)) &Bgp::aspath_cmp;
}

/* return and as path value */
const char *
Bgp::aspath_print (struct aspath *as)
{
    return as->str;
}

/* Printing functions */
void
Bgp::aspath_print_vty (struct vty *vty, struct aspath *as)
{
    vty_out (zlog_default, LOG_DEBUG," %s", as->str);
}

/* Print all aspath and hash information.  This function is used from
   `show ip bgp paths' command. */
void
Bgp::aspath_print_all_vty (struct vty *vty)
{
    int i;
    HashBacket *mp;
    struct aspath *as;

    for (i = 0; i < HASHTABSIZE; i++)
        if ((mp = hash_head (ashash, i)) != NULL)
            while (mp)
            {
	      vty_out (zlog_default,LOG_DEBUG, "[%p:%d] (%ld) ", 
                         mp, i, ((struct aspath *)mp->data)->refcnt);
                as = ( struct aspath * ) mp->data;
                vty_out (zlog_default,LOG_DEBUG,"%s%s", as->str, VTY_NEWLINE);
                mp = mp->next;
            }
}

void
Bgp::aspath_aggr_test()
{
    struct aspath *New;
    struct aspath *as1 = aspath_str2aspath ("(3 4) 123");
#if 0
    struct aspath *as2 = aspath_str2aspath ("3");
    struct aspath *as3 = aspath_str2aspath ("4");
    struct aspath *as2 = aspath_empty();
    struct aspath *as1 = aspath_empty();
#endif

    New = aspath_add_seq (as1, 123);
    New->str = aspath_make_str_count (New);
    printf ("New %s\n", New->str);
}

////////////////////////////////////////////////
////////////////////////////////////////////////
/////////////////////bgp_attr.c///////////////
////////////////////////////////////////////////

/* Cluster list related functions. */
struct cluster_list *
Bgp::cluster_parse (caddr_t pnt, int length)
{
    struct cluster_list tmp;
    struct cluster_list *find;
    struct cluster_list *cluster;

    tmp.length = length;
    tmp.list = (struct in_addr *) pnt;

    find =  ( struct cluster_list * ) hash_search (cluster_hash, &tmp);
    if (find)
    {
        find->refcnt++;
        return find;
    }

    cluster = ( struct cluster_list * ) XMALLOC (MTYPE_CLUSTER, sizeof (struct cluster_list));
    cluster->length = length;

    if (cluster->length)
    {
        cluster->list = ( struct in_addr * ) XMALLOC (MTYPE_CLUSTER_VAL, length);
        memcpy (cluster->list, pnt, length);
    } else
        cluster->list = NULL;

    cluster->refcnt = 1;

    hash_push (cluster_hash, cluster);

    return cluster;
}

int
Bgp::cluster_loop_check (struct cluster_list *cluster, struct in_addr originator)
{
    int i;

    for (i = 0; i < cluster->length / 4; i++)
        if (cluster->list[i].s_addr == originator.s_addr)
            return 1;
    return 0;
}

unsigned int
Bgp::cluster_hash_key_make (struct cluster_list *cluster)
{
    unsigned int key = 0;
    int length;
    caddr_t pnt;

    length = cluster->length;
    pnt = (caddr_t) cluster->list;

    while (length)
        key += pnt[--length];

    return key %= HASHTABSIZE;
}

int
Bgp::cluster_hash_cmp (struct cluster_list *cluster1, struct cluster_list *cluster2)
{
    if (cluster1->length == cluster2->length &&
        memcmp (cluster1->list, cluster2->list, cluster1->length) == 0)
        return 1;
    return 0;
}

void
Bgp::cluster_free (struct cluster_list *cluster)
{
    if (cluster->list)
        XFREE (MTYPE_CLUSTER_VAL, cluster->list);
    XFREE (MTYPE_CLUSTER, cluster);
}

struct cluster_list *
Bgp::cluster_dup (struct cluster_list *cluster)
{
    struct cluster_list *New;

    New = ( struct cluster_list * ) XMALLOC (MTYPE_CLUSTER, sizeof (struct cluster_list));
    memset (New, 0, sizeof (struct cluster_list));
    New->length = cluster->length;

    if (cluster->length)
    {
        New->list = ( struct in_addr * ) XMALLOC (MTYPE_CLUSTER_VAL, cluster->length);
        memcpy (New->list, cluster->list, cluster->length);
    } else
        New->list = NULL;

    return New;
}

struct cluster_list *
Bgp::cluster_intern (struct cluster_list *cluster)
{
    struct cluster_list *find;

    find = ( struct cluster_list * ) hash_search (cluster_hash, cluster);
    if (find)
    {
        cluster_free (cluster);
        find->refcnt++;
        return find;
    }

    cluster->refcnt = 1;
    hash_push (cluster_hash, cluster);

    return cluster;
}

void
Bgp::cluster_unintern (struct cluster_list *cluster)
{
    struct cluster_list *ret;

    if (cluster->refcnt)
        cluster->refcnt--;

    if (cluster->refcnt == 0)
    {
        ret = ( struct cluster_list * ) hash_pull (cluster_hash, cluster);
        cluster_free (cluster);
    }
}

void
Bgp::cluster_init ()
{
    cluster_hash = hash_new (HASHTABSIZE);
    cluster_hash->hash_key =(unsigned int (*)(void * ) ) &Bgp::cluster_hash_key_make;
    cluster_hash->hash_cmp = ( int (*) ( void * , void * ) ) &Bgp::cluster_hash_cmp;
}


void
Bgp::transit_free (struct transit *transit)
{
    if (transit->val)
        XFREE (MTYPE_TRANSIT_VAL, transit->val);
    XFREE (MTYPE_TRANSIT, transit);
}

struct transit *
Bgp::transit_intern (struct transit *transit)
{
    struct transit *find;

    find = ( struct transit*  ) hash_search (transit_hash, transit);
    if (find)
    {
        transit_free (transit);
        find->refcnt++;
        return find;
    }

    transit->refcnt = 1;
    hash_push (transit_hash, transit);

    return transit;
}

void
Bgp::transit_unintern (struct transit *transit)
{
    struct transit *ret;

    if (transit->refcnt)
        transit->refcnt--;

    if (transit->refcnt == 0)
    {
        ret = ( struct transit * ) hash_pull (transit_hash, transit);
        transit_free (transit);
    }
}

unsigned int
Bgp::transit_hash_key_make (struct transit *transit)
{
    unsigned int key = 0;
    int length;
    caddr_t pnt;

    length = transit->length;
    pnt = (caddr_t) transit->val;

    while (length)
        key += pnt[--length];

    return key %= HASHTABSIZE;
}

int
Bgp::transit_hash_cmp (struct transit *transit1, struct transit *transit2)
{
    if (transit1->length == transit2->length &&
        memcmp (transit1->val, transit2->val, transit1->length) == 0)
        return 1;
    return 0;
}

void
Bgp::transit_init ()
{
    transit_hash = hash_new (HASHTABSIZE);
    transit_hash->hash_key = ( unsigned int (*) ( void * ) ) &Bgp::transit_hash_key_make;
    transit_hash->hash_cmp = ( int (*) (void *, void * ) )&Bgp::transit_hash_cmp;
}

unsigned int
Bgp::attrhash_key_make (struct attr *attr)
{
    unsigned int key = 0;
    int i;

    key += attr->origin;
    key += attr->nexthop.s_addr;
    key += attr->med;
    key += attr->local_pref;
    key += attr->aggregator_as;
    key += attr->aggregator_addr.s_addr;
    /* key += attr->dpa; */
    key += attr->weight;


    //key += attr->mp_nexthop_global_in.s_addr;
    if (attr->aspath)
        key += Bgp::aspath_key_make (attr->aspath);
    if (attr->community)
        key += Bgp::community_hash_make (attr->community);
    if (attr->ecommunity)
        key += Bgp::ecommunity_hash_make (attr->ecommunity);
    if (attr->cluster)
        key += Bgp::cluster_hash_key_make (attr->cluster);
    if (attr->transit)
        key += Bgp::transit_hash_key_make (attr->transit);

    return key %= HASHTABSIZE;
}

int
Bgp::attrhash_cmp (struct attr *attr1, struct attr *attr2)
{
    if (attr1->flag == attr2->flag
        && attr1->origin == attr2->origin
        && attr1->nexthop.s_addr == attr2->nexthop.s_addr
        && attr1->med == attr2->med
        && attr1->local_pref == attr2->local_pref
        && attr1->aggregator_as == attr2->aggregator_as
        && attr1->aggregator_addr.s_addr == attr2->aggregator_addr.s_addr
        /* && attr1->dpa == attr2->dpa */
        && attr1->weight == attr2->weight
        //&& IPV4_ADDR_SAME (&attr1->mp_nexthop_global_in, &attr2->mp_nexthop_global_in)
        && attr1->aspath == attr2->aspath
        && attr1->community == attr2->community
        && attr1->ecommunity == attr2->ecommunity
        && attr1->cluster == attr2->cluster
        && attr1->transit == attr2->transit)
        return 1;
    else
        return 0;
}

void
Bgp::attrhash_init ()
{
    attrhash = hash_new (HASHTABSIZE);
    attrhash->hash_key = (unsigned int (*) ( void * ))&Bgp::attrhash_key_make;
    attrhash->hash_cmp = ( int (*) ( void * , void * ) ) &Bgp::attrhash_cmp;
}

void
Bgp::attr_dump_vty (struct vty *vty, struct attr *attr)
{
    vty_out (zlog_default,LOG_DEBUG,"attr[%ld] nexthop %s%s", attr->refcnt,
             inet_ntoa (attr->nexthop), VTY_NEWLINE);
}


void
Bgp::attrhash_dump (struct vty *vty)
{
    int i;
    HashBacket *mp;

    for (i = 0; i < HASHTABSIZE; i++)
        if ((mp = (HashBacket *) hash_head (attrhash, i)) != NULL)
            while (mp)
            {
                struct attr *attr;

                attr = (struct attr *) mp->data;

                attr_dump_vty (vty, attr);

                mp = mp->next;
            }
}

/* Internet argument attribute. */
struct attr *
Bgp::bgp_attr_intern (struct attr *attr)
{
    struct attr *find;
    struct attr *New;

    /* Intern referenced strucutre. */
    if (attr->aspath)
    {
        if (! attr->aspath->refcnt)
            attr->aspath = aspath_intern (attr->aspath);
        else
            attr->aspath->refcnt++;
    }
    if (attr->community)
    {
        if (! attr->community->refcnt)
            attr->community = community_intern (attr->community);
        else
            attr->community->refcnt++;
    }
    if (attr->ecommunity)
    {
        if (! attr->ecommunity->refcnt)
            attr->ecommunity = ecommunity_intern (attr->ecommunity);
        else
            attr->ecommunity->refcnt++;
    }
    if (attr->cluster)
    {
        if (! attr->cluster->refcnt)
            attr->cluster = cluster_intern (attr->cluster);
        else
            attr->cluster->refcnt++;
    }
    if (attr->transit)
    {
        if (! attr->transit->refcnt)
            attr->transit = transit_intern (attr->transit);
        else
            attr->transit->refcnt++;
    }

    find = (struct attr *) hash_search (attrhash, attr);
    if (find)
    {
        find->refcnt++;
        return find;
    }

    New = ( struct attr * )  XMALLOC (MTYPE_ATTR, sizeof (struct attr));
    *New = *attr;

    New->refcnt = 1;

    hash_push (attrhash, New);

    return New;
}

/* Make network statement's attribute. */
struct attr *
Bgp::bgp_attr_default_set (struct attr *attr, u_char origin)
{
    memset (attr, 0, sizeof (struct attr));

    attr->origin = origin;
    attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_ORIGIN);
    attr->aspath = aspath_empty ();
    attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_AS_PATH);
    attr->weight = 32768;
    return attr;
}

/* Make network statement's attribute. */
struct attr *
Bgp::bgp_attr_default_intern (u_char origin)
{
    struct attr attr;
    struct attr *New;

    memset (&attr, 0, sizeof (struct attr));

    attr.origin = origin;
    attr.flag |= ATTR_FLAG_BIT (BGP_ATTR_ORIGIN);
    attr.aspath = aspath_empty ();
    attr.flag |= ATTR_FLAG_BIT (BGP_ATTR_AS_PATH);
    attr.weight = 32768;

    New = bgp_attr_intern (&attr);
    aspath_unintern (New->aspath);
    return New;
}

struct attr *
Bgp::bgp_attr_aggregate_intern (struct bgp *bgp, u_char origin,
                                struct aspath *aspath,
                                struct community *community, int as_set)
{
    struct attr attr;
    struct attr *New;

    memset (&attr, 0, sizeof (struct attr));

    /* Origin attribute. */
    attr.origin = origin;
    attr.flag |= ATTR_FLAG_BIT (BGP_ATTR_ORIGIN);

    /* AS path attribute. */
    if (aspath)
        attr.aspath = aspath_intern (aspath);
    else
        attr.aspath = aspath_empty ();
    attr.flag |= ATTR_FLAG_BIT (BGP_ATTR_AS_PATH);

    if (community)
    {
        attr.community = community;
        attr.flag |= ATTR_FLAG_BIT (BGP_ATTR_COMMUNITIES);
    }

    attr.weight = 32768;

    if (! as_set)
        attr.flag |= ATTR_FLAG_BIT (BGP_ATTR_ATOMIC_AGGREGATE);
    attr.flag |= ATTR_FLAG_BIT (BGP_ATTR_AGGREGATOR);
    if (CHECK_FLAG (bgp->config, BGP_CONFIG_CONFEDERATION))
      attr.aggregator_as = bgp->confederation_id;
    else
      attr.aggregator_as = bgp->as;
    attr.aggregator_addr = bgp->id;

    New = bgp_attr_intern (&attr);
    aspath_unintern (New->aspath);
    return New;
}

/* Free bgp attribute and aspath. */
void
Bgp::bgp_attr_unintern (struct attr *attr)
{
    struct attr *ret;
    struct aspath *aspath;
    struct community *community;
    struct ecommunity *ecommunity;
    struct cluster_list *cluster;
    struct transit *transit;

    /* Decrement attribute reference. */
    attr->refcnt--;
    aspath = attr->aspath;
    community = attr->community;
    ecommunity = attr->ecommunity;
    cluster = attr->cluster;
    transit = attr->transit;

    /* If reference becomes zero then free attribute object. */
    if (attr->refcnt == 0)
    {
        ret = ( struct attr * ) hash_pull (attrhash, attr);
        assert (ret != NULL);
        XFREE (MTYPE_ATTR, attr);
    }

    /* aspath refcount shoud be decrement. */
    if (aspath)
        aspath_unintern (aspath);
    if (community)
        community_unintern (community);
    if (ecommunity)
        ecommunity_unintern (ecommunity);
    if (cluster)
        cluster_unintern (cluster);
    if (transit)
        transit_unintern (transit);
}

void
Bgp::bgp_attr_flush (struct attr *attr)
{
    if (attr->aspath && ! attr->aspath->refcnt)
        aspath_free (attr->aspath);
    if (attr->community && ! attr->community->refcnt)
        community_free (attr->community);
    if (attr->ecommunity && ! attr->ecommunity->refcnt)
        ecommunity_free (attr->ecommunity);
    if (attr->cluster && ! attr->cluster->refcnt)
        cluster_free (attr->cluster);
    if (attr->transit && ! attr->transit->refcnt)
        transit_free (attr->transit);
}

/* Get origin attribute of the update message. */
int
Bgp::bgp_attr_origin (struct peer *peer, bgp_size_t length, 
                      struct attr *attr, u_char flag, u_char *startp)
{
    bgp_size_t total;

    /* total is entire attribute length include Attribute Flags (1),
       Attribute Type code (1) and Attribute length (1 or 2).  */
    total = length + (CHECK_FLAG (flag, BGP_ATTR_FLAG_EXTLEN) ? 4 : 3);

    /* If any recognized attribute has Attribute Flags that conflict
       with the Attribute Type Code, then the Error Subcode is set to
       Attribute Flags Error.  The Data field contains the erroneous
       attribute (type, length and value). */
    if (flag != BGP_ATTR_FLAG_TRANS)
    {
        zlog (peer->log, LOG_ERR, 
              "Origin attribute flag isnt transitive %d\n", flag);
        bgp_notify_send_with_data (peer, 
                                   BGP_NOTIFY_UPDATE_ERR, 
                                   BGP_NOTIFY_UPDATE_ATTR_FLAG_ERR,
                                   startp, total);
        return -1;
    }

    /* If any recognized attribute has Attribute Length that conflicts
       with the expected length (based on the attribute type code), then
       the Error Subcode is set to Attribute Length Error.  The Data
       field contains the erroneous attribute (type, length and
       value). */
    if (length != 1)
    {
        zlog (peer->log, LOG_ERR, "Origin attribute length is not one %d\n",
              length);
        bgp_notify_send_with_data (peer, BGP_NOTIFY_UPDATE_ERR, 
                                   BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,
                                   startp, total);
        return -1;
    }

    /* Fetch origin attribute. */
    attr->origin = stream_getc (BGP_INPUT (peer));

    /* If the ORIGIN attribute has an undefined value, then the Error
       Subcode is set to Invalid Origin Attribute.  The Data field
       contains the unrecognized attribute (type, length and value). */
    if ((attr->origin != BGP_ORIGIN_IGP)
        && (attr->origin != BGP_ORIGIN_EGP)
        && (attr->origin != BGP_ORIGIN_INCOMPLETE))
    {
        zlog (peer->log, LOG_ERR, "Origin attribute value is invalid %d\n",
              attr->origin);

        bgp_notify_send_with_data (peer, 
                                   BGP_NOTIFY_UPDATE_ERR, 
                                   BGP_NOTIFY_UPDATE_INVAL_ORIGIN,
                                   startp, total);
        return -1;
    }

    /* Set oring attribute flag. */
    attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_ORIGIN);

    return 0;
}

/* Parse AS path information.  This function is wrapper of
   aspath_parse. */
int
Bgp::bgp_attr_aspath (struct peer *peer, bgp_size_t length, 
                      struct attr *attr, u_char flag, u_char *startp)
{
    struct bgp *bgp;
    struct peer_conf *conf;
    struct listnode *nn;
    bgp_size_t total;

    total = length + (CHECK_FLAG (flag, BGP_ATTR_FLAG_EXTLEN) ? 4 : 3);

    /* Flag check. */
    if (CHECK_FLAG (flag, BGP_ATTR_FLAG_OPTIONAL)
        || ! CHECK_FLAG (flag, BGP_ATTR_FLAG_TRANS))
    {
        zlog (peer->log, LOG_ERR, 
              "Origin attribute flag isnt transitive %d\n", flag);
        bgp_notify_send_with_data (peer, 
                                   BGP_NOTIFY_UPDATE_ERR, 
                                   BGP_NOTIFY_UPDATE_ATTR_FLAG_ERR,
                                   startp, total);
        return -1;
    }

    /* In case of IBGP, length will be zero. */
    attr->aspath = aspath_parse ((char *)stream_pnt (peer->ibuf),(int) length);
    if (! attr->aspath)
    {
        zlog (peer->log, LOG_ERR, "Malformed AS path length is %d\n", length);
        bgp_notify_send (peer, 
                         BGP_NOTIFY_UPDATE_ERR, 
                         BGP_NOTIFY_UPDATE_MAL_AS_PATH);
        return -1;
    }

    bgp = NULL;
    if (peer->conf)
    {
        for ((nn) = (peer->conf)->head; (nn); (nn) = (nn)->next)
            if (((conf) = ( peer_conf *) (nn)->data) != NULL)
            {
                bgp = conf->bgp;
            }
    }

    /* First AS check for EBGP. */
    if (bgp != NULL && CHECK_FLAG (bgp->config, BGP_CONFIG_ENFORCE_FIRST_AS))
    {
        if (peer_sort (peer) == BGP_PEER_EBGP 
            && ! aspath_firstas_check (attr->aspath, peer->as))
        {
            zlog (peer->log, LOG_ERR,
                  "%s incorrect first AS (must be %d)\n", peer->host, peer->as);
            bgp_notify_send (peer,
                             BGP_NOTIFY_UPDATE_ERR,
                             BGP_NOTIFY_UPDATE_MAL_AS_PATH);
            return -1;
        }
    }

    /* Forward pointer. */
    stream_forward (peer->ibuf, length);

    /* Set aspath attribute flag. */
    attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_AS_PATH);

    return 0;
}

/* Nexthop attribute. */
int
Bgp::bgp_attr_nexthop (struct peer *peer, bgp_size_t length, 
                       struct attr *attr, u_char flag, u_char *startp)
{
    bgp_size_t total;

    total = length + (CHECK_FLAG (flag, BGP_ATTR_FLAG_EXTLEN) ? 4 : 3);

    /* Flag check. */
    if (CHECK_FLAG (flag, BGP_ATTR_FLAG_OPTIONAL)
        || ! CHECK_FLAG (flag, BGP_ATTR_FLAG_TRANS))
    {
        zlog (peer->log, LOG_ERR, 
              "Origin attribute flag isnt transitive %d\n", flag);
        bgp_notify_send_with_data (peer, 
                                   BGP_NOTIFY_UPDATE_ERR, 
                                   BGP_NOTIFY_UPDATE_ATTR_FLAG_ERR,
                                   startp, total);
        return -1;
    }

    /* Check nexthop attribute length. */
    if (length != 4)
    {
        zlog (peer->log, LOG_ERR, "Nexthop attribute length isnt four [%d]\n",
              length);

        bgp_notify_send_with_data (peer, 
                                   BGP_NOTIFY_UPDATE_ERR, 
                                   BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,
                                   startp, total);
        return -1;
    }

    attr->nexthop.s_addr = stream_get_ipv4 (peer->ibuf);
    attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_NEXT_HOP);

    return 0;
}

/* MED atrribute. */
int
Bgp::bgp_attr_med (struct peer *peer, bgp_size_t length, 
                   struct attr *attr, u_char flag, u_char *startp)
{
    bgp_size_t total;

    total = length + (CHECK_FLAG (flag, BGP_ATTR_FLAG_EXTLEN) ? 4 : 3);

    /* Length check. */
    if (length != 4)
    {
        zlog (peer->log, LOG_ERR, 
              "MED attribute length isnt four [%d]\n", length);

        bgp_notify_send_with_data (peer, 
                                   BGP_NOTIFY_UPDATE_ERR, 
                                   BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,
                                   startp, total);
        return -1;
    }

    attr->med = stream_getl (peer->ibuf);

    attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_MULTI_EXIT_DISC);

    return 0;
}

/* Local preference attribute. */
int
Bgp::bgp_attr_local_pref (struct peer *peer, bgp_size_t length, 
                          struct attr *attr, u_char flag)
{
    /* If it is contained in an UPDATE message that is received from an
       external peer, then this attribute MUST be ignored by the
       receiving speaker. */
    if (peer_sort (peer) == BGP_PEER_EBGP)
    {
        stream_forward (peer->ibuf, length);
        return 0;
    }

    if (length == 4)
        attr->local_pref = stream_getl (peer->ibuf);
    else
        attr->local_pref = 0;

    /* Set atomic aggregate flag. */
    attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_LOCAL_PREF);

    return 0;
}

/* Atomic aggregate. */
int
Bgp::bgp_attr_atomic (struct peer *peer, bgp_size_t length, 
                      struct attr *attr, u_char flag)
{
    if (length != 0)
    {
        zlog (peer->log, LOG_ERR, "Bad atomic aggregate length %d\n", length);

        bgp_notify_send (peer, 
                         BGP_NOTIFY_UPDATE_ERR, 
                         BGP_NOTIFY_UPDATE_ATTR_LENG_ERR);
        return -1;
    }

    /* Set atomic aggregate flag. */
    attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_ATOMIC_AGGREGATE);

    return 0;
}

/* Aggregator attribute */
int
Bgp::bgp_attr_aggregator (struct peer *peer, bgp_size_t length,
                          struct attr *attr, u_char flag)
{
    if (length != 6)
    {
        zlog (peer->log, LOG_ERR, "Aggregator length is not 6 [%d]\n", length);

        bgp_notify_send (peer,
                         BGP_NOTIFY_UPDATE_ERR,
                         BGP_NOTIFY_UPDATE_ATTR_LENG_ERR);
        return -1;
    }
    attr->aggregator_as = stream_getw (peer->ibuf);
    attr->aggregator_addr.s_addr = stream_get_ipv4 (peer->ibuf);

    /* Set atomic aggregate flag. */
    attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_AGGREGATOR);

    return 0;
}

/* Community attribute. */
int
Bgp::bgp_attr_community (struct peer *peer, bgp_size_t length, 
                         struct attr *attr, u_char flag)
{
    if (length == 0)
        attr->community = NULL;
    else
    {
        attr->community = community_parse ((char * )stream_pnt (peer->ibuf),(short unsigned int ) length);
        stream_forward (peer->ibuf, length);
    }

    attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_COMMUNITIES);

    return 0;
}

/* Originator ID attribute. */
int
Bgp::bgp_attr_originator_id (struct peer *peer, bgp_size_t length, 
                             struct attr *attr, u_char flag)
{
    if (length != 4)
    {
        zlog (peer->log, LOG_ERR, "Bad originator ID length %d\n", length);

        bgp_notify_send (peer, 
                         BGP_NOTIFY_UPDATE_ERR, 
                         BGP_NOTIFY_UPDATE_ATTR_LENG_ERR);
        return -1;
    }

    attr->originator_id.s_addr = stream_get_ipv4 (peer->ibuf);

    attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_ORIGINATOR_ID);

    return 0;
}

/* Cluster list attribute. */
int
Bgp::bgp_attr_cluster_list (struct peer *peer, bgp_size_t length, 
                            struct attr *attr, u_char flag)
{
    /* Check length. */
    if (length % 4)
    {
        zlog (peer->log, LOG_ERR, "Bad cluster list length %d\n", length);

        bgp_notify_send (peer, 
                         BGP_NOTIFY_UPDATE_ERR, 
                         BGP_NOTIFY_UPDATE_ATTR_LENG_ERR);
        return -1;
    }

    attr->cluster = cluster_parse ((char * )stream_pnt (peer->ibuf),(int) length);

    stream_forward (peer->ibuf, length);;

    attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_CLUSTER_LIST);

    return 0;
}

/* Multiprotocol reachability information parse. */
// int
// Bgp::bgp_mp_reach_parse (struct peer *peer, bgp_size_t length, struct attr *attr,
//                          struct bgp_nlri *mp_update)
// {
//     u_int16_t afi;
//     u_char safi;
//     u_char snpa_num;
//     u_char snpa_len;
//     u_char *lim;
//     bgp_size_t nlri_len;
//     int ret;
//     struct stream *s;

//     /* Set end of packet. */
//     s = peer->ibuf;
//     lim = stream_pnt (s) + length;

//     /* Load AFI, SAFI. */
//     afi = stream_getw (s);
//     safi = stream_getc (s);

//     /* Get nexthop length. */
//     attr->mp_nexthop_len = stream_getc (s);

//     /* Nexthop length check. */
//     switch (attr->mp_nexthop_len)
//     {
//     case 4:
//         stream_get (&attr->mp_nexthop_global_in, s, 4);
//         break;
//     case 12:
//         {
//             u_int32_t rd_high;
//             u_int32_t rd_low;

//             rd_high = stream_getl (s);
//             rd_low = stream_getl (s);
//             /* stream_forward (s, 8); */
//             stream_get (&attr->mp_nexthop_global_in, s, 4);
//             zlog_info ("VPNv4 nexthop recv %d:%d:%s\n",
//                        rd_high, rd_low, inet_ntoa (attr->mp_nexthop_global_in));
//         }
//         break;
//     default:
//         zlog_info ("Wrong multiprotocol next hop length: %d\n", 
//                    attr->mp_nexthop_len);
//         return -1;
//         break;
//     }

//     snpa_num = stream_getc (s);

//     while (snpa_num--)
//     {
//         snpa_len = stream_getc (s);
//         stream_forward (s, (snpa_len + 1) >> 1);
//     }

//     /* If peer is based on old draft-00. I read NLRI length from the
//        packet. */
//     if (peer->version == BGP_VERSION_MP_4_DRAFT_00)
//     {
//         bgp_size_t nlri_total_len;
//         nlri_total_len = stream_getw (s);
//     }

//     nlri_len = lim - stream_pnt (s);

//     ret = nlri_sanity_check (peer, afi, stream_pnt (s), nlri_len);
//     if (ret < 0)
//       return -1;
   
//     mp_update->afi = afi;
//     mp_update->safi = safi;
//     mp_update->nlri = stream_pnt (s);
//     mp_update->length = nlri_len;

//     stream_forward (s, nlri_len);

//     return 0;
// }

/* Multiprotocol unreachable parse */
int
Bgp::bgp_mp_unreach_parse (struct peer *peer, int length, 
                           struct bgp_nlri *mp_withdraw)
{
    struct stream *s;
    u_int16_t afi;
    u_char safi;
    u_char *lim;
    u_int16_t withdraw_len;
    int ret;

    s = peer->ibuf;
    lim = stream_pnt (s) + length;

    afi = stream_getw (s);
    safi = stream_getc (s);

    withdraw_len = lim - stream_pnt (s);

    
    ret = nlri_sanity_check (peer, afi, stream_pnt (s), withdraw_len);
    if (ret < 0)
      return -1;
    

    mp_withdraw->afi = afi;
    mp_withdraw->safi = safi;
    mp_withdraw->nlri = stream_pnt (s);
    mp_withdraw->length = withdraw_len;

    stream_forward (s, withdraw_len);

    return 0;
}

/* Extended Community attribute. */
int
Bgp::bgp_attr_ext_communities (struct peer *peer, bgp_size_t length, 
                               struct attr *attr, u_char flag)
{
    if (length == 0)
        attr->ecommunity = NULL;
    else
    {
        attr->ecommunity = ecommunity_parse ( (char * ) stream_pnt (peer->ibuf),(short unsigned int) length);
        stream_forward (peer->ibuf, length);
    }
    attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_EXT_COMMUNITIES);

    return 0;
}

/* BGP unknown attribute treatment. */
int
Bgp::bgp_attr_unknown (struct peer *peer, struct attr *attr, u_char flag,
                       u_char type, bgp_size_t length, u_char *startp)
{
    bgp_size_t total;
    struct transit *transit;

    if (BGP_DEBUG (events, EVENTS))
        zlog (peer->log, LOG_INFO, 
              "Unknown attribute type %d length %d is received\n", type, length);

    /* Forward read pointer of input stream. */
    stream_forward (peer->ibuf, length);

    /* Adjest total length to include type and length. */
    total = length + (CHECK_FLAG (flag, BGP_ATTR_FLAG_EXTLEN) ? 4 : 3);

    /* If any of the mandatory well-known attributes are not recognized,
       then the Error Subcode is set to Unrecognized Well-known
       Attribute.  The Data field contains the unrecognized attribute
       (type, length and value). */
    if (! CHECK_FLAG (flag, BGP_ATTR_FLAG_OPTIONAL))
    {
        /* Adjust startp to do not include flag value. */
        bgp_notify_send_with_data (peer, 
                                   BGP_NOTIFY_UPDATE_ERR, 
                                   BGP_NOTIFY_UPDATE_UNREC_ATTR,
                                   startp, total);
        return -1;
    }

    /* Unrecognized non-transitive optional attributes must be quietly
       ignored and not passed along to other BGP peers. */
    if (! CHECK_FLAG (flag, BGP_ATTR_FLAG_TRANS))
        return 0;

    /* If a path with recognized transitive optional attribute is
       accepted and passed along to other BGP peers and the Partial bit
       in the Attribute Flags octet is set to 1 by some previous AS, it
       is not set back to 0 by the current AS. */
    SET_FLAG (*startp, BGP_ATTR_FLAG_PARTIAL);

    /* Store transitive attribute to the end of attr->transit. */
    if (! attr->transit)
    {
        attr->transit = ( struct transit * )  XMALLOC (MTYPE_TRANSIT, sizeof (struct transit));
        memset (attr->transit, 0, sizeof (struct transit));
    }

    transit = attr->transit;

    if (transit->val)
        transit->val = ( u_char * ) XREALLOC (MTYPE_TRANSIT_VAL, transit->val, 
                                              transit->length + total);
    else
        transit->val = ( u_char * ) XMALLOC (MTYPE_TRANSIT_VAL, total);

    memcpy (transit->val + transit->length, startp, total);
    transit->length += total;

    return 0;
}



/* Read attribute of update packet.  This function is called from
   bgp_update() in bgpd.c.  */
int
Bgp::bgp_attr_parse (struct peer *peer, struct attr *attr, bgp_size_t size,
                     struct bgp_nlri *mp_update, struct bgp_nlri *mp_withdraw)
{
    int ret;
    u_char flag;
    u_char type;
    bgp_size_t length;
    u_char *startp, *endp;
    u_char *attr_endp;
    u_char seen[BGP_ATTR_BITMAP_SIZE];

    /* Initialize bitmap. */
    memset (seen, 0, BGP_ATTR_BITMAP_SIZE);

    /* End pointer of BGP attribute. */
    endp = BGP_INPUT_PNT (peer) + size;

    /* Get attributes to the end of attribute length. */
    while (BGP_INPUT_PNT (peer) < endp)
    {
        /* Check remaining length check.*/
        if (endp - BGP_INPUT_PNT (peer) < BGP_ATTR_MIN_LEN)
        {
            zlog (peer->log, LOG_WARNING, 
                  "%s error BGP attribute length %d is smaller than min len\n",
                  peer->host, endp - STREAM_PNT (BGP_INPUT (peer)));

            bgp_notify_send (peer, 
                             BGP_NOTIFY_UPDATE_ERR, 
                             BGP_NOTIFY_UPDATE_ATTR_LENG_ERR);
            return -1;
        }

        /* Fetch attribute flag and type. */
        startp = BGP_INPUT_PNT (peer);
        flag = stream_getc (BGP_INPUT (peer));
        type = stream_getc (BGP_INPUT (peer));

        /* Check extended attribue length bit. */
        if (CHECK_FLAG (flag, BGP_ATTR_FLAG_EXTLEN))
            length = stream_getw (BGP_INPUT (peer));
        else
            length = stream_getc (BGP_INPUT (peer));

        /* If any attribute appears more than once in the UPDATE
       message, then the Error Subcode is set to Malformed Attribute
       List. */

        if (CHECK_BITMAP (seen, type))
        {
            zlog (peer->log, LOG_WARNING,
                  "%s error BGP attribute type %d appears twice in a message\n",
                  peer->host, type);

            bgp_notify_send (peer, 
                             BGP_NOTIFY_UPDATE_ERR, 
                             BGP_NOTIFY_UPDATE_MAL_ATTR);
            return -1;
        }

        /* Set type to bitmap to check duplicate attribute.  `type' is
       unsigned char so it never overflow bitmap range. */

        SET_BITMAP (seen, type);

        /* Overflow check. */
        attr_endp =  BGP_INPUT_PNT (peer) + length;

        if (attr_endp > endp)
        {
            zlog (peer->log, LOG_WARNING, 
                  "%s BGP type %d length %d is too large, attribute total length is %d.  attr_endp is %p.  endp is %p\n", 
		  peer->host, type, length, size, attr_endp, endp);
            bgp_notify_send (peer, 
                             BGP_NOTIFY_UPDATE_ERR, 
                             BGP_NOTIFY_UPDATE_ATTR_LENG_ERR);
            return -1;
        }

        /* OK check attribute and store it's value. */
        switch (type)
        {
        case BGP_ATTR_ORIGIN:
            ret = bgp_attr_origin (peer, length, attr, flag, startp);
            break;
        case BGP_ATTR_AS_PATH:
            ret = bgp_attr_aspath (peer, length, attr, flag, startp);
            break;
        case BGP_ATTR_NEXT_HOP:    
            ret = bgp_attr_nexthop (peer, length, attr, flag, startp);
            break;
        case BGP_ATTR_MULTI_EXIT_DISC:
            ret = bgp_attr_med (peer, length, attr, flag, startp);
            break;
        case BGP_ATTR_LOCAL_PREF:
            ret = bgp_attr_local_pref (peer, length, attr, flag);
            break;
        case BGP_ATTR_ATOMIC_AGGREGATE:
            ret = bgp_attr_atomic (peer, length, attr, flag);
            break;
        case BGP_ATTR_AGGREGATOR:
            ret = bgp_attr_aggregator (peer, length, attr, flag);
            break;
        case BGP_ATTR_COMMUNITIES:
            ret = bgp_attr_community (peer, length, attr, flag);
            break;
        case BGP_ATTR_ORIGINATOR_ID:
            ret = bgp_attr_originator_id (peer, length, attr, flag);
            break;
        case BGP_ATTR_CLUSTER_LIST:
            ret = bgp_attr_cluster_list (peer, length, attr, flag);
            break;
	    //        case BGP_ATTR_MP_REACH_NLRI:
	    //            ret = bgp_mp_reach_parse (peer, length, attr, mp_update);
	    //            break;
        case BGP_ATTR_MP_UNREACH_NLRI:
            ret = bgp_mp_unreach_parse (peer, length, mp_withdraw);
            break;
        case BGP_ATTR_EXT_COMMUNITIES:
            ret = bgp_attr_ext_communities (peer, length, attr, flag);
            break;
        default:
            ret = bgp_attr_unknown (peer, attr, flag, type, length, startp);
            break;
        }

        /* If error occured immediately return to the caller. */
        if (ret < 0)
            return ret;

        /* Check the fetched length. */
        if (BGP_INPUT_PNT (peer) != attr_endp)
        {
            zlog (peer->log, LOG_WARNING, 
                  "%s BGP attribute fetch error\n", peer->host);
            bgp_notify_send (peer, 
                             BGP_NOTIFY_UPDATE_ERR, 
                             BGP_NOTIFY_UPDATE_ATTR_LENG_ERR);
            return -1;
        }
    }

    /* Check final read pointer is same as end pointer. */
    if (BGP_INPUT_PNT (peer) != endp)
    {
        zlog (peer->log, LOG_WARNING, 
              "%s BGP attribute length mismatch\n", peer->host);
        bgp_notify_send (peer, 
                         BGP_NOTIFY_UPDATE_ERR, 
                         BGP_NOTIFY_UPDATE_ATTR_LENG_ERR);
        return -1;
    }

    /* Finally intern unknown attribute. */
    if (attr->transit)
        attr->transit = transit_intern (attr->transit);

    return 0;
}

/* Well-known attribute check. */
int
Bgp::bgp_attr_check (struct peer *peer, struct attr *attr)
{
    u_char type = 0;

    if (! CHECK_FLAG (attr->flag, ATTR_FLAG_BIT (BGP_ATTR_ORIGIN)))
        type = BGP_ATTR_ORIGIN;

    if (! CHECK_FLAG (attr->flag, ATTR_FLAG_BIT (BGP_ATTR_AS_PATH)))
        type = BGP_ATTR_AS_PATH;

    if (! CHECK_FLAG (attr->flag, ATTR_FLAG_BIT (BGP_ATTR_NEXT_HOP)))
        type = BGP_ATTR_NEXT_HOP;

    if (peer_sort (peer) == BGP_PEER_IBGP
        && ! CHECK_FLAG (attr->flag, ATTR_FLAG_BIT (BGP_ATTR_LOCAL_PREF)))
        type = BGP_ATTR_LOCAL_PREF;

    if (type)
    {
        zlog (peer->log, LOG_WARNING, 
              "%s Missing well-known attribute %d.\n",
              peer->host, type);
        bgp_notify_send_with_data (peer, 
                                   BGP_NOTIFY_UPDATE_ERR, 
                                   BGP_NOTIFY_UPDATE_MISS_ATTR,
                                   &type, 1);
        return -1;
    }
    return 0;
}



/* Make attribute packet. */
bgp_size_t
Bgp::bgp_packet_attribute (struct peer_conf *conf, struct peer *peer,
                           struct stream *s, struct attr *attr, struct prefix *p,
                           afi_t afi, safi_t safi, struct peer *from,
                           struct prefix_rd *prd, u_char *tag)
{
    unsigned long cp;
    struct aspath *aspath;
    struct bgp *bgp = conf->bgp;

    /* Remember current pointer. */
    cp = stream_get_putp (s);

    /* Origin attribute. */
    stream_putc (s, BGP_ATTR_FLAG_TRANS);
    stream_putc (s, BGP_ATTR_ORIGIN);
    stream_putc (s, 1);
    stream_putc (s, attr->origin);

    /* AS path attribute. */

    /* If remote-peer is EBGP */
    if (peer_sort (peer) == BGP_PEER_EBGP
        && ! CHECK_FLAG (peer->flags, PEER_FLAG_TRANSPARENT_AS)
        && ! (CHECK_FLAG (from->af_flags[afi][safi], PEER_FLAG_RSERVER_CLIENT)
              && CHECK_FLAG (peer->af_flags[afi][safi], PEER_FLAG_RSERVER_CLIENT)))
    {
        aspath = aspath_dup (attr->aspath);

        if (CHECK_FLAG(bgp->config, BGP_CONFIG_CONFEDERATION))
        {
            /* Strip the confed info, and then stuff our path CONFED_ID
               on the front */
            aspath = aspath_delete_confed_seq (aspath);
            aspath = aspath_add_seq (aspath, bgp->confederation_id);
        } else
        {
            aspath = aspath_add_seq (aspath, peer->local_as);
        }
    } else if (peer_sort (peer) == BGP_PEER_CONFED)
    {
        /* A confed member, so we need to do the AS_CONFED_SEQUENCE thing */
        aspath = aspath_dup (attr->aspath);
        aspath = aspath_add_confed_seq (aspath, peer->local_as);
    } else
        aspath = attr->aspath;

    /* AS path attribute extended length bit check. */
    if (aspath->length > 255)
    {
        stream_putc (s, BGP_ATTR_FLAG_TRANS|BGP_ATTR_FLAG_EXTLEN);
        stream_putc (s, BGP_ATTR_AS_PATH);
        stream_putw (s, aspath->length);
    } else
    {
        stream_putc (s, BGP_ATTR_FLAG_TRANS);
        stream_putc(s, BGP_ATTR_AS_PATH);
        stream_putc (s, aspath->length);
    }
    stream_put (s, aspath->data, aspath->length);

    if (peer_sort (peer) == BGP_PEER_EBGP
        && ! CHECK_FLAG (peer->flags, PEER_FLAG_TRANSPARENT_AS)
        && ! (CHECK_FLAG (from->af_flags[afi][safi], PEER_FLAG_RSERVER_CLIENT)
              && CHECK_FLAG (peer->af_flags[afi][safi], PEER_FLAG_RSERVER_CLIENT)))
        aspath_free (aspath);

    /* Nexthop attribute. */
    stream_putc (s, BGP_ATTR_FLAG_TRANS);
    stream_putc (s, BGP_ATTR_NEXT_HOP);
    stream_putc (s, 4);
    stream_put_ipv4 (s, attr->nexthop.s_addr);

    /* MED attribute. */
    if (attr->flag & ATTR_FLAG_BIT (BGP_ATTR_MULTI_EXIT_DISC))
    {
        stream_putc (s, BGP_ATTR_FLAG_OPTIONAL);
        stream_putc (s, BGP_ATTR_MULTI_EXIT_DISC);
        stream_putc (s, 4);
        stream_putl (s, attr->med);
    }

    /* Local preference. */
    if (peer_sort (peer) == BGP_PEER_IBGP ||
        peer_sort (peer) == BGP_PEER_CONFED)
    {
        stream_putc (s, BGP_ATTR_FLAG_TRANS);
        stream_putc (s, BGP_ATTR_LOCAL_PREF);
        stream_putc (s, 4);
        stream_putl (s, attr->local_pref);
    }

    /* Atomic aggregate. */
    if (attr->flag & ATTR_FLAG_BIT (BGP_ATTR_ATOMIC_AGGREGATE))
    {
        stream_putc (s, BGP_ATTR_FLAG_TRANS);
        stream_putc (s, BGP_ATTR_ATOMIC_AGGREGATE);
        stream_putc (s, 0);
    }

    /* Aggregator. */
    if (attr->flag & ATTR_FLAG_BIT (BGP_ATTR_AGGREGATOR))
    {
        stream_putc (s, BGP_ATTR_FLAG_OPTIONAL|BGP_ATTR_FLAG_TRANS);
        stream_putc (s, BGP_ATTR_AGGREGATOR);
        stream_putc (s, 6);
        stream_putw (s, attr->aggregator_as);
        stream_put_ipv4 (s, attr->aggregator_addr.s_addr);
    }

    /* Community attribute. */
    if (CHECK_FLAG (peer->af_flags[afi][safi], PEER_FLAG_SEND_COMMUNITY) 
        && (attr->flag & ATTR_FLAG_BIT (BGP_ATTR_COMMUNITIES)))
    {
        if (attr->community->size * 4 > 255)
        {
            stream_putc (s, BGP_ATTR_FLAG_OPTIONAL|BGP_ATTR_FLAG_TRANS|BGP_ATTR_FLAG_EXTLEN);
            stream_putc (s, BGP_ATTR_COMMUNITIES);
            stream_putw (s, attr->community->size * 4);
        } else
        {
            stream_putc (s, BGP_ATTR_FLAG_OPTIONAL|BGP_ATTR_FLAG_TRANS);
            stream_putc (s, BGP_ATTR_COMMUNITIES);
            stream_putc (s, attr->community->size * 4);
        }
        stream_put (s, attr->community->val, attr->community->size * 4);
    }

    /* Route Reflector. */
    if (peer_sort (peer) == BGP_PEER_IBGP
        && peer_sort (from) == BGP_PEER_IBGP)
    {
        /* Originator ID. */
        stream_putc (s, BGP_ATTR_FLAG_OPTIONAL);
        stream_putc (s, BGP_ATTR_ORIGINATOR_ID);
        stream_putc (s, 4);

        if (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_ORIGINATOR_ID))
            stream_put_in_addr (s, &attr->originator_id);
        else
            stream_put_in_addr (s, &from->remote_id);

        /* Cluster list. */
        stream_putc (s, BGP_ATTR_FLAG_OPTIONAL);
        stream_putc (s, BGP_ATTR_CLUSTER_LIST);

        if (attr->cluster)
        {
            stream_putc (s, attr->cluster->length + 4);
            /* If this peer configuration's parent BGP has cluster_id. */
            if (conf->bgp->config & BGP_CONFIG_CLUSTER_ID)
                stream_put_in_addr (s, &conf->bgp->cluster);
            else
                stream_put_in_addr (s, &conf->bgp->id);
            stream_put (s, attr->cluster->list, attr->cluster->length);
        } else
        {
            stream_putc (s, 4);
            /* If this peer configuration's parent BGP has cluster_id. */
            if (conf->bgp->config & BGP_CONFIG_CLUSTER_ID)
                stream_put_in_addr (s, &conf->bgp->cluster);
            else
                stream_put_in_addr (s, &conf->bgp->id);
        }
    }
    
//     if (p->family == AF_INET && safi == SAFI_MULTICAST)
//     {
//         unsigned long sizep;
//         unsigned long draftp = 0;

//         stream_putc (s, BGP_ATTR_FLAG_OPTIONAL);
//         stream_putc (s, BGP_ATTR_MP_REACH_NLRI);
//         sizep = stream_get_putp (s);
//         stream_putc (s, 0);  /* Length of this attribute. */
//         stream_putw (s, AFI_IP); /* AFI */
//         stream_putc (s, SAFI_MULTICAST); /* SAFI */

//         stream_putc (s, 4);
//         stream_put_ipv4 (s, attr->nexthop.s_addr);

//         /* SNPA */
//         stream_putc (s, 0);

//         /* In case of old draft BGP-4+. */
//         if (peer->version == BGP_VERSION_MP_4_DRAFT_00)
//         {
//             draftp = stream_get_putp (s);
//             stream_putw (s, 0);
//         }

//         /* Prefix write. */
//         stream_put_prefix (s, p);

//         /* Set MP attribute length. */
//         stream_putc_at (s, sizep, (stream_get_putp (s) - sizep) - 1);

//         /* In case of old draft BGP-4+. */
//         if (peer->version == BGP_VERSION_MP_4_DRAFT_00)
//             stream_putw_at (s, draftp, (stream_get_putp (s) - draftp) - 2);
//    }

    /* Extended Communities attribute. */
    if (CHECK_FLAG (peer->af_flags[afi][safi], PEER_FLAG_SEND_EXT_COMMUNITY) 
        && (attr->flag & ATTR_FLAG_BIT (BGP_ATTR_EXT_COMMUNITIES)))
    {
        if (attr->ecommunity->size * 8 > 255)
        {
            stream_putc (s, BGP_ATTR_FLAG_OPTIONAL|BGP_ATTR_FLAG_TRANS|BGP_ATTR_FLAG_EXTLEN);
            stream_putc (s, BGP_ATTR_EXT_COMMUNITIES);
            stream_putw (s, attr->ecommunity->size * 8);
        } else
        {
            stream_putc (s, BGP_ATTR_FLAG_OPTIONAL|BGP_ATTR_FLAG_TRANS);
            stream_putc (s, BGP_ATTR_EXT_COMMUNITIES);
            stream_putc (s, attr->ecommunity->size * 8);
        }
        stream_put (s, attr->ecommunity->val, attr->ecommunity->size * 8);
    }

    /* Unknown transit attribute. */
    if (attr->transit)
        stream_put (s, attr->transit->val, attr->transit->length);

    /* Return total size of attribute. */
    return stream_get_putp (s) - cp;
}
bgp_size_t
Bgp::bgp_packet_withdraw (struct peer *peer, struct stream *s, struct prefix *p,
                          afi_t afi, safi_t safi, struct prefix_rd *prd,
                          u_char *tag)
{
    unsigned long cp;
    unsigned long attrlen_pnt;
    bgp_size_t size;

    cp = stream_get_putp (s);

    stream_putc (s, BGP_ATTR_FLAG_OPTIONAL);
    stream_putc (s, BGP_ATTR_MP_UNREACH_NLRI);

    attrlen_pnt = stream_get_putp (s);
    stream_putc (s, 0);      /* Length of this attribute. */

    stream_putw (s, family2afi (p->family));

    /* SAFI */
    stream_putc (s, safi);
    
    /* prefix */
    stream_put_prefix (s, p);
	

    /* Set MP attribute length. */
    size = stream_get_putp (s) - attrlen_pnt - 1;
    stream_putc_at (s, attrlen_pnt, size);

    return stream_get_putp (s) - cp;
}

/* Initialization of attribute. */
void
Bgp::bgp_attr_init ()
{
    aspath_init ();
    attrhash_init ();
    community_init ();
    ecommunity_init ();
    cluster_init ();
    transit_init ();
}

/* Make attribute packet. */
void
Bgp::bgp_dump_routes_attr (struct stream *s, struct attr *attr)
{
    unsigned long cp;
    unsigned long len;
    struct aspath *aspath;

    /* Remember current pointer. */
    cp = stream_get_putp (s);

    /* Place holder of length. */
    stream_putw (s, 0);

    /* Origin attribute. */
    stream_putc (s, BGP_ATTR_FLAG_TRANS);
    stream_putc (s, BGP_ATTR_ORIGIN);
    stream_putc (s, 1);
    stream_putc (s, attr->origin);

    aspath = attr->aspath;

    if (aspath->length > 255)
    {
        stream_putc (s, BGP_ATTR_FLAG_TRANS|BGP_ATTR_FLAG_EXTLEN);
        stream_putc (s, BGP_ATTR_AS_PATH);
        stream_putw (s, aspath->length);
    } else
    {
        stream_putc (s, BGP_ATTR_FLAG_TRANS);
        stream_putc (s, BGP_ATTR_AS_PATH);
        stream_putc (s, aspath->length);
    }
    stream_put (s, aspath->data, aspath->length);

    /* Nexthop attribute. */
    stream_putc (s, BGP_ATTR_FLAG_TRANS);
    stream_putc (s, BGP_ATTR_NEXT_HOP);
    stream_putc (s, 4);
    stream_put_ipv4 (s, attr->nexthop.s_addr);

    /* MED attribute. */
    if (attr->flag & ATTR_FLAG_BIT (BGP_ATTR_MULTI_EXIT_DISC))
    {
        stream_putc (s, BGP_ATTR_FLAG_OPTIONAL);
        stream_putc (s, BGP_ATTR_MULTI_EXIT_DISC);
        stream_putc (s, 4);
        stream_putl (s, attr->med);
    }

    /* Local preference. */
    if (attr->flag & ATTR_FLAG_BIT (BGP_ATTR_LOCAL_PREF))
    {
        stream_putc (s, BGP_ATTR_FLAG_TRANS);
        stream_putc (s, BGP_ATTR_LOCAL_PREF);
        stream_putc (s, 4);
        stream_putl (s, attr->local_pref);
    }

    /* Atomic aggregate. */
    if (attr->flag & ATTR_FLAG_BIT (BGP_ATTR_ATOMIC_AGGREGATE))
    {
        stream_putc (s, BGP_ATTR_FLAG_TRANS);
        stream_putc (s, BGP_ATTR_ATOMIC_AGGREGATE);
        stream_putc (s, 0);
    }

    /* Aggregator. */
    if (attr->flag & ATTR_FLAG_BIT (BGP_ATTR_AGGREGATOR))
    {
        stream_putc (s, BGP_ATTR_FLAG_OPTIONAL|BGP_ATTR_FLAG_TRANS);
        stream_putc (s, BGP_ATTR_AGGREGATOR);
        stream_putc (s, 6);
        stream_putw (s, attr->aggregator_as);
        stream_put_ipv4 (s, attr->aggregator_addr.s_addr);
    }

    /* Community attribute. */
    if (attr->flag & ATTR_FLAG_BIT (BGP_ATTR_COMMUNITIES))
    {
        if (attr->community->size * 4 > 255)
        {
            stream_putc (s, BGP_ATTR_FLAG_OPTIONAL|BGP_ATTR_FLAG_TRANS|BGP_ATTR_FLAG_EXTLEN);
            stream_putc (s, BGP_ATTR_COMMUNITIES);
            stream_putw (s, attr->community->size * 4);
        } else
        {
            stream_putc (s, BGP_ATTR_FLAG_OPTIONAL|BGP_ATTR_FLAG_TRANS);
            stream_putc (s, BGP_ATTR_COMMUNITIES);
            stream_putc (s, attr->community->size * 4);
        }
        stream_put (s, attr->community->val, attr->community->size * 4);
    }

    /* Return total size of attribute. */
    len = stream_get_putp (s) - cp - 2;
    stream_putw_at (s, cp, len);
}



////////////////////////////////////////////////
////////////////////////////////////////////////
/////////////////////bgp_clist.c////////////////
////////////////////////////////////////////////

struct community_entry *
Bgp::community_entry_new ()
{
    struct community_entry *New;

    New = ( struct community_entry * ) XMALLOC (MTYPE_COMMUNITY_ENTRY, sizeof (struct community_entry));
    memset (New, 0, sizeof (struct community_entry));
    return New;
}

void
Bgp::community_entry_free (struct community_entry *entry)
{
    if (entry->com)
        community_free (entry->com);
    if (entry->regexp)
    {
        XFREE (MTYPE_COMMUNITY_REGEXP, entry->regexp);
        bgp_regex_free (entry->reg);
    }
    XFREE (MTYPE_COMMUNITY_ENTRY, entry);
}

struct community_entry *
Bgp::community_entry_make (struct community *com, enum community_entry_type type)
{
    struct community_entry *entry;

    entry = community_entry_new ();
    entry->com = com;
    entry->type = type;
    entry->style = COMMUNITY_LIST;

    return entry;
}

struct community_list *
Bgp::community_list_new ()
{
    struct community_list *New;

    New = ( struct community_list * ) XMALLOC (MTYPE_COMMUNITY_LIST, sizeof (struct community_list));
    memset (New, 0, sizeof (struct community_list));
    return New;
}

void
Bgp::community_list_free (struct community_list *list)
{
    if (list->name)
        XFREE (0, list->name);
    XFREE (MTYPE_COMMUNITY_LIST, list);
}

struct community_list *
Bgp::community_list_insert (char *name)
{
    int i;
    long number;
    struct community_list *New;
    struct community_list *point;
    struct community_list_list *list;

    /* Allocate New community_list and copy given name. */
    New = community_list_new ();
    New->name = strdup (name);

    /* If name is made by all digit character.  We treat it as
       number. */
    for (number = 0, i = 0; i < strlen (name); i++)
    {
        if (isdigit ((int) name[i]))
            number = (number * 10) + (name[i] - '0');
        else
            break;
    }

    /* In case of name is all digit character */
    if (i == strlen (name))
    {
        New->sort = COMMUNITY_LIST_NUMBER;

        /* Set access_list to number list. */
        list = &community_list_master.num;

        for (point = list->head; point; point = point->next)
            if (atol (point->name) >= number)
                break;
    } else
    {
        New->sort = COMMUNITY_LIST_STRING;

        /* Set access_list to string list. */
        list = &community_list_master.str;

        /* Set point to insertion point. */
        for (point = list->head; point; point = point->next)
            if (strcmp (point->name, name) >= 0)
                break;
    }

    /* In case of this is the first element of master. */
    if (list->head == NULL)
    {
        list->head = list->tail = New;
        return New;
    }

    /* In case of insertion is made at the tail of access_list. */
    if (point == NULL)
    {
        New->prev = list->tail;
        list->tail->next = New;
        list->tail = New;
        return New;
    }

    /* In case of insertion is made at the head of access_list. */
    if (point == list->head)
    {
        New->next = list->head;
        list->head->prev = New;
        list->head = New;
        return New;
    }

    /* Insertion is made at middle of the access_list. */
    New->next = point;
    New->prev = point->prev;

    if (point->prev)
        point->prev->next = New;
    point->prev = New;

    return New;
}

struct community_list *
Bgp::community_list_lookup (char *name)
{
    struct community_list *list;

    if (name == NULL)
        return NULL;

    for (list = community_list_master.num.head; list; list = list->next)
        if (strcmp (list->name, name) == 0)
            return list;

    for (list = community_list_master.str.head; list; list = list->next)
        if (strcmp (list->name, name) == 0)
            return list;

    return NULL;
}

struct community_list *
Bgp::community_list_get (char *name)
{
    struct community_list *list;

    list = community_list_lookup (name);
    if (list == NULL)
        list = community_list_insert (name);
    return list;
}

struct community_entry *
Bgp::community_entry_lookup (struct community_list *list, 
                             struct community *com, enum community_entry_type type)
{
    struct community_entry *entry;

    for (entry = list->head; entry; entry = entry->next)
        if (entry->style == COMMUNITY_LIST)
            if (community_cmp (entry->com, com))
                return entry;
    return NULL;
}

struct community_entry *
Bgp::community_entry_regexp_lookup (struct community_list *list,
                                    char *str, enum community_entry_type type)
{
    struct community_entry *entry;

    for (entry = list->head; entry; entry = entry->next)
        if (entry->style == COMMUNITY_REGEXP)
            if (strcmp (entry->regexp, str) == 0)
                return entry;
    return NULL;
}

void
Bgp::community_list_entry_add (struct community_list *list, 
                               struct community_entry *entry)
{
    entry->next = NULL;
    entry->prev = list->tail;

    if (list->tail)
        list->tail->next = entry;
    else
        list->head = entry;
    list->tail = entry;
}

void
Bgp::community_list_delete (struct community_list *list)
{
    struct community_list_list *clist;
    struct community_entry *entry, *next;

    for (entry = list->head; entry; entry = next)
    {
        next = entry->next;
        community_entry_free (entry);
    }

    if (list->sort == COMMUNITY_LIST_NUMBER)
        clist = &community_list_master.num;
    else
        clist = &community_list_master.str;

    if (list->next)
        list->next->prev = list->prev;
    else
        clist->tail = list->prev;

    if (list->prev)
        list->prev->next = list->next;
    else
        clist->head = list->next;

    community_list_free (list);
}

int 
Bgp::community_list_empty (struct community_list *list)
{
    if (list->head == NULL && list->tail == NULL)
        return 1;
    else
        return 0;
}

void
Bgp::community_list_entry_delete (struct community_list *list,
                                  struct community_entry *entry)
{
    if (entry->next)
        entry->next->prev = entry->prev;
    else
        list->tail = entry->prev;

    if (entry->prev)
        entry->prev->next = entry->next;
    else
        list->head = entry->next;

    community_entry_free (entry);

    if (community_list_empty (list))
        community_list_delete (list);
}

int
Bgp::community_match_regexp (struct community_entry *entry,
                             struct community *com)
{
    int i;
    char c[12];
    u_int32_t comval;

    /* This is an evil special case, sorry */
    if (strcmp(entry->regexp, "^$") == 0
        && (com == NULL || com->size == 0))
    {
        return 1;
    }

    for (i = 0; i < com->size; i++)
    {
        memcpy (&comval, com_nthval (com, i), sizeof (u_int32_t));
        comval = ntohl (comval);

        sprintf(c, "%d:%d", (comval >> 16) & 0xFFFF, comval & 0xFFFF);

        if (regexec (entry->reg, c, 0, NULL, 0) == 0)
            return 1;
    }
    return 0;
}

struct community *
Bgp::community_delete_regexp (struct community *com, regex_t *reg)
{
    int i;
    char c[12];
    u_int32_t comval;

    i = 0;
    while (i < com->size)
    {
        memcpy (&comval, com_nthval (com, i), sizeof (u_int32_t));
        comval = ntohl (comval);

        sprintf(c, "%d:%d", (comval >> 16) & 0xFFFF, comval & 0xFFFF);

        if (regexec (reg, c, 0, NULL, 0) == 0)
        {
            /* Matched - delete! */
            community_del_val (com, com_nthval (com, i));
        } else
            i++;
    }

    return com;
}

/* Delete all permitted communities in the list from com1 */
struct community *
Bgp::community_list_delete_entries (struct community *com1,
                                    struct community_list *list)
{
    struct community_entry *entry;

    for (entry = list->head; entry; entry = entry->next)
    {
        if (entry->style == COMMUNITY_LIST)
        {
            if (entry->type == COMMUNITY_PERMIT)
                community_delete (com1, entry->com);
        } else if (entry->style == COMMUNITY_REGEXP)
        {
            if (entry->type == COMMUNITY_PERMIT)
                community_delete_regexp (com1, entry->reg);
        }
    }

    return com1;
}


int
Bgp::community_list_match (struct community *com, struct community_list *list)
{
    struct community_entry *entry;

    for (entry = list->head; entry; entry = entry->next)
    {
        if (entry->style == COMMUNITY_LIST)
        {
            if (community_match (com, entry->com))
                return(entry->type == COMMUNITY_PERMIT ? 1 : 0);
        } else if (entry->style == COMMUNITY_REGEXP)
        {
            if (community_match_regexp (entry, com))
                return(entry->type == COMMUNITY_PERMIT ? 1 : 0);
        }
    }
    return 0;
}

int
Bgp::community_list_match_exact (struct community *com, struct community_list *list)
{
    struct community_entry *entry;

    for (entry = list->head; entry; entry = entry->next)
        if (entry->style == COMMUNITY_LIST)
            if (community_cmp (com, entry->com))
                return(entry->type == COMMUNITY_PERMIT ? 1 : 0);
    return 0;
}

char *
Bgp::community_type_str (enum community_entry_type type)
{
    switch (type)
    {
    case COMMUNITY_DENY:
        return "deny";
        break;
    case COMMUNITY_PERMIT:
        return "permit";
        break;
    default:
        return "";
        break;
    }
}

void
Bgp::community_list_print (struct community_list *list)
{
    struct community_entry *entry;

    for (entry = list->head; entry; entry = entry->next)
        printf ("ip community-list %s %s%s\n", list->name, 
                community_type_str (entry->type), community_print (entry->com));
}

int
Bgp::community_list_dup_check (struct community_list *list, 
                               struct community_entry *New)
{
    struct community_entry *entry;

    for (entry = list->head; entry; entry = entry->next)
    {
        if (entry->style != New->style)
            continue;
        if (entry->style == COMMUNITY_LIST)
        {
            if (entry->type == New->type
                && community_cmp (entry->com, New->com))
                return 1;
        } else if (entry->style == COMMUNITY_REGEXP)
        {
            if (entry->type == New->type
                && (strcmp(entry->regexp, New->regexp) == 0))
                return 1;
        }
    }
    return 0;
}


DEFUN (ip_community_list, 
       ip_community_list_cmd,
       "ip community-list WORD (deny|permit) .AA:NN",
       IP_STR
       "Add a community list entry\n"
       "Community list name\n"
       "Specify community to reject\n"
       "Specify community to accept\n"
       "Community number in aa:nn format or local-AS|no-advertise|no-export\n")
{
    enum community_entry_type type;
    struct community_entry *entry;
    struct community_list *list;
    struct community *com;
    struct buffer *b;
    regex_t *regex;
    int i;
    char *str;
    int first = 0;

    /* Check the list type. */
    if (strncmp (argv[1], "p", 1) == 0)
        type = COMMUNITY_PERMIT;
    else if (strncmp (argv[1], "d", 1) == 0)
        type = COMMUNITY_DENY;
    else
    {
        vty_out (zlog_default,LOG_DEBUG,"community-list type must be [permit|deny]%s", VTY_NEWLINE);
        return CMD_WARNING;
    }

    b = buffer_new (1024);
    for (i = 2; i < argc; i++)
    {
        if (first)
            buffer_putc (b, ' ');
        else
            first = 1;

        buffer_putstr (( buffer* )b,(u_char * )  argv[i]);
    }
    buffer_putc (b, '\0');

    str = buffer_getstr (b);
    buffer_free (b);

    com = community_str2com (str);
    if (com)
    {
        entry = community_entry_make (com, type);
        free (str);
    } else
    {
        regex = bgp_regcomp (str);

        if (regex)
        {
            entry = community_entry_new ();
            entry->reg = regex;
            entry->regexp = XSTRDUP (MTYPE_COMMUNITY_REGEXP, str);
            entry->type = type;
            entry->style = COMMUNITY_REGEXP;
            free(str);
        } else
        {
            vty_out (zlog_default,LOG_DEBUG,"Community-list malformed: %s%s", str,
                     VTY_NEWLINE);
            free (str);
            return CMD_WARNING;
        }
    }

    /* Install New community list to the community_list. */
    list = community_list_get (argv[0]);

    if (community_list_dup_check (list, entry))
        community_entry_free (entry);
    else
        community_list_entry_add (list, entry);

    return CMD_SUCCESS;
}

DEFUN (no_ip_community_list,
       no_ip_community_list_cmd,
       "no ip community-list WORD (deny|permit) .AA:NN",
       NO_STR
       IP_STR
       "Add a community list entry\n"
       "Community list name\n"
       "Specify community to reject\n"
       "Specify community to accept\n"
       "Community number in aa:nn format or local-AS|no-advertise|no-export\n")
{
    enum community_entry_type type;
    struct community_entry *entry;
    struct community_list *list;
    struct community *com;
    struct buffer *b;
    regex_t *regex;
    int i;
    char *str;
    int first = 0;

    list = community_list_lookup (argv[0]);
    if (list == NULL)
    {
        vty_out (zlog_default,LOG_DEBUG,"ip community-list %s doesnt exist.%s", argv[0],
                 VTY_NEWLINE);
        return CMD_WARNING;
    }

    /* Check the list type. */
    if (strncmp (argv[1], "p", 1) == 0)
        type = COMMUNITY_PERMIT;
    else if (strncmp (argv[1], "d", 1) == 0)
        type = COMMUNITY_DENY;
    else
    {
        vty_out (zlog_default,LOG_DEBUG,"community-list type must be [permit|deny]%s",
                 VTY_NEWLINE);
        return CMD_WARNING;
    }

    b = buffer_new (1024);
    for (i = 2; i < argc; i++)
    {
        if (first)
            buffer_putc (b, ' ');
        else
            first = 1;

        buffer_putstr (( buffer * ) b,(u_char *)  argv[i]);
    }
    buffer_putc (b, '\0');

    str = buffer_getstr (b);
    buffer_free (b);

    com = community_str2com (str);

    if (com)
    {
        free (str);
        entry = community_entry_lookup (list, com, type);
    } else
    {
        regex = bgp_regcomp (str);
        if (regex)
        {
            entry = community_entry_regexp_lookup (list, str, type);
            free(str);
        } else
        {
            vty_out (zlog_default,LOG_DEBUG,"Community-list malformed: %s%s", str,
                     VTY_NEWLINE);
            free (str);
            return CMD_WARNING;
        }
    }

    if (entry == NULL)
    {
        vty_out (zlog_default,LOG_DEBUG, "Cant find specified community list.%s",
                 VTY_NEWLINE);
        return CMD_WARNING;
    }

    community_list_entry_delete (list, entry);

    return CMD_SUCCESS;
}

DEFUN (no_ip_community_list_all,
       no_ip_community_list_all_cmd,
       "no ip community-list WORD",
       NO_STR
       IP_STR
       "Add a community list entry\n"
       "Community list name\n")
{
    struct community_list *list;

    list = community_list_lookup (argv[0]);
    if (list == NULL)
    {
        vty_out (zlog_default,LOG_DEBUG, "ip community-list %s doesnt exist.%s", argv[0],
                 VTY_NEWLINE);
        return CMD_WARNING;
    }

    community_list_delete (list);

    return CMD_SUCCESS;
}

void
Bgp::community_list_init ()
{
    install_element (CONFIG_NODE, &ip_community_list_cmd);
    install_element (CONFIG_NODE, &no_ip_community_list_cmd);
    install_element (CONFIG_NODE, &no_ip_community_list_all_cmd);
}

void
Bgp::community_list_test ()
{
    struct community *com1;
    struct community *com2;
    struct community_list *list;
    struct community_entry *entry;

    /* ip community-list 10 permit no-export. */
    list = community_list_get ("10");

    com1 = community_str2com ("7675:70");
    entry = community_entry_make (com1, COMMUNITY_PERMIT);
    community_list_entry_add (list, entry);

    com1 = community_str2com ("7675:60");
    entry = community_entry_make (com1, COMMUNITY_PERMIT);
    community_list_entry_add (list, entry);

    com2 = community_str2com ("7675:60");
    entry = community_entry_lookup (list, com2, COMMUNITY_PERMIT);
    community_list_entry_delete (list, entry);

    community_list_print (list);
}



////////////////////////////////////////////////
////////////////////////////////////////////////
//////////////////bgp_community.c///////////////
////////////////////////////////////////////////

struct community *
Bgp::community_new ()
{
    struct community *New;

    New = (struct community * )  XMALLOC (MTYPE_COMMUNITY, sizeof (struct community));
    memset (New, 0, sizeof (struct community));
    return New;
}

void
Bgp::community_free (struct community *com)
{
    if (com->val)
        XFREE (MTYPE_COMMUNITY_VAL, com->val);
    XFREE (MTYPE_COMMUNITY, com);
}

/* Add one community value to the community. */
void
Bgp::community_add_val (struct community *com, u_int32_t val)
{
    com->size++;
    if (com->val)
        com->val = ( u_int32_t * ) XREALLOC (MTYPE_COMMUNITY_VAL, com->val, com_length (com));
    else
        com->val = ( u_int32_t * ) XMALLOC (MTYPE_COMMUNITY_VAL, com_length (com));

    val = htonl (val);
    memcpy (com_lastval (com), &val, sizeof (u_int32_t));
}

/* Delete one community. */
void
Bgp::community_del_val (struct community *com, u_int32_t *val)
{
    int i = 0;
    int c = 0;

    if (! com->val)
        return;

    while (i < com->size)
    {
        if (memcmp (com->val + i, val, sizeof (u_int32_t)) == 0)
        {
            c = com->size -i -1;

            if (c > 0)
                memcpy (com->val + i, com->val + (i + 1), c * sizeof (val));

            com->size--;

            if (com->size > 0)
                com->val = ( u_int32_t * ) XREALLOC (MTYPE_COMMUNITY_VAL, com->val,
                                                     com_length (com));
            else
            {
                XFREE (MTYPE_COMMUNITY_VAL, com->val);
                com->val = NULL;
            }
            return;
        }
        i++;
    }
}

/* Delete all communities listed in com2 from com1 */
struct community *
Bgp::community_delete (struct community *com1, struct community *com2)
{
    int i = 0;

    while (i < com2->size)
    {
        community_del_val (com1, com2->val + i);
        i++;
    }

    return com1;
}

/* Callback function from qsort(). */
int
Bgp::community_compare (const void *a1, const void *a2)
{
    u_int32_t v1;
    u_int32_t v2;

    memcpy (&v1, a1, sizeof (u_int32_t));
    memcpy (&v2, a2, sizeof (u_int32_t));
    v1 = ntohl (v1);
    v2 = ntohl (v2);

    if (v1 < v2)
        return -1;
    if (v1 > v2)
        return 1;
    return 0;
}

int
Bgp::community_include (struct community *com, u_int32_t val)
{
    int i;

    val = htonl (val);

    for (i = 0; i < com->size; i++)
    {
        if (memcmp (&val, com_nthval (com, i), sizeof (u_int32_t)) == 0)
            return 1;
    }
    return 0;
}

u_int32_t
Bgp::community_val_get (struct community *com, int i)
{
    u_char *p;
    u_int32_t val;

    p = (u_char *) com->val;
    p += (i * 4);

    memcpy (&val, p, sizeof (u_int32_t));

    return ntohl (val);
}

/* Sort and uniq given community. */
struct community *
Bgp::community_uniq_sort (struct community *com)
{
    int i;
    struct community *New;
    u_int32_t val;

    New = community_new ();

    for (i = 0; i < com->size; i++)
    {
        val = community_val_get (com, i);

        if (! community_include (New, val))
            community_add_val (New, val);
    }
    qsort (New->val, New->size, sizeof (u_int32_t), Bgp::community_compare);

    return New;
}

/* Create New community attribute. */
struct community *
Bgp::community_parse (char *pnt, u_short length)
{
    struct community tmp;
    struct community *find;
    struct community *New;

    /* If length is malformed return NULL. */
    if (length % 4)
        return NULL;

    /* Make temporary community for hash look up. */
    tmp.size = length / 4;
    tmp.val = (u_int32_t *) pnt;

    New = community_uniq_sort (&tmp);

    /* Looking up hash of community attribute. */
    find = (struct community *) hash_search (comhash, New);
    if (find)
    {
        find->refcnt++;
        community_free (New);
        return find;
    }

    New->refcnt = 1;
    New->size = length / 4;
    New->val = (u_int32_t *) XMALLOC (MTYPE_COMMUNITY_VAL, length);
    memcpy (New->val, pnt, length);

    hash_push (comhash, New);

    return New;
}

struct community *
Bgp::community_dup (struct community *com)
{
    struct community *New;

    New = ( struct community * ) XMALLOC (MTYPE_COMMUNITY, sizeof (struct community));
    memset (New, 0, sizeof (struct community));
    New->size = com->size;
    if (New->size)
    {
        New->val = ( u_int32_t * )  XMALLOC (MTYPE_COMMUNITY_VAL, com->size * 4);
        memcpy (New->val, com->val, com->size * 4);
    } else
        New->val = NULL;
    return New;
}

struct community *
Bgp::community_intern (struct community *com)
{
    struct community *find;

    /* Assert this community structure is not interned. */
    assert (com->refcnt == 0);

    /* Lookup community hash. */
    find = (struct community *) hash_search (comhash, com);
    if (find)
    {
        community_free (com);
        find->refcnt++;
        return find;
    }

    /* Push New community to hash bucket. */
    com->refcnt = 1;
    hash_push (comhash, com);
    return com;
}

/* Free community attribute. */
void
Bgp::community_unintern (struct community *com)
{
    if (com->refcnt)
        com->refcnt--;

    if (com->refcnt == 0)
    {
        struct community *ret;

        /* Community value com must exist in hash. */
        ret = (struct community *) hash_pull (comhash, com);
        assert (ret != NULL);

        community_free (com);
    }
}

/* Pretty printing of community.  For debug and logging purpose. */
const char *
Bgp::community_print (struct community *com)
{
    /* XXX non-re-entrant warning */
    static char buf[BUFSIZ];
    int i;
    u_int32_t comval;
    u_int16_t as;
    u_int16_t val;

    memset (buf, 0, BUFSIZ);

    for (i = 0; i < com->size; i++)
    {
        memcpy (&comval, com_nthval (com, i), sizeof (u_int32_t));
        comval = ntohl (comval);
        switch (comval)
        {
        case COMMUNITY_NO_EXPORT:
            strlcat (buf, " no-export", BUFSIZ);
            break;
        case COMMUNITY_NO_ADVERTISE:
            strlcat (buf, " no-advertise", BUFSIZ);
            break;
        case COMMUNITY_LOCAL_AS:
            strlcat (buf, " local-AS", BUFSIZ);
            break;
        default:
            as = (comval >> 16) & 0xFFFF;
            val = comval & 0xFFFF;
            snprintf (buf + strlen (buf), BUFSIZ - strlen (buf), 
                      " %d:%d", as, val);
            break;
        }
    }
    return buf;
}

/* Make hash value of community attribute. This function is used by
   hash package.*/
unsigned int
Bgp::community_hash_make (struct community *com)
{
    int c;
    unsigned int key;
    unsigned char *pnt;

    key = 0;
    pnt = (unsigned char *)com->val;

    for (c = 0; c < com->size * 4; c++)
        key += pnt[c];

    return key %= HASHTABSIZE;
}

int
Bgp::community_match (struct community *com1, struct community *com2)
{
    int i = 0;
    int j = 0;

    if (com1 == NULL && com2 == NULL)
        return 1;

    if (com1 == NULL || com2 == NULL)
        return 0;

    if (com1->size < com2->size)
        return 0;

    /* Every community on com2 needs to be on com1 for this to match */
    while (i < com1->size && j < com2->size)
    {
        if (memcmp (com1->val + i, com2->val + j, sizeof (u_int32_t)) == 0)
            j++;
        i++;
    }

    if (j == com2->size)
        return 1;
    else
        return 0;
}

/* If two aspath have same value then return 1 else return 0. This
   function is used by hash package. */
int
Bgp::community_cmp (struct community *com1, struct community *com2)
{
    if (com1 == NULL && com2 == NULL)
        return 1;
    if (com1 == NULL || com2 == NULL)
        return 0;

    if (com1->size == com2->size)
        if (memcmp (com1->val, com2->val, com1->size * 4) == 0)
            return 1;
    return 0;
}


/* Add com2 to the end of com1. */
struct community *
Bgp::community_merge (struct community *com1, struct community *com2)
{
    if (com1->val)
        com1->val =( u_int32_t * )  XREALLOC (MTYPE_COMMUNITY_VAL, com1->val, 
                                              (com1->size + com2->size) * 4);
    else
        com1->val =( u_int32_t * ) XMALLOC (MTYPE_COMMUNITY_VAL, (com1->size + com2->size) * 4);

    memcpy (com1->val + com1->size, com2->val, com2->size * 4);
    com1->size += com2->size;

    return com1;
}

/* Initialize comminity related hash. */
void
Bgp::community_init ()
{
    comhash = hash_new (HASHTABSIZE);
    comhash->hash_key = (unsigned int (*) ( void * ) ) &Bgp::community_hash_make;
    comhash->hash_cmp = ( int (*) ( void * , void * ) )&Bgp:: community_cmp;
}

/* Pretty printing of community attribute. */
void
Bgp::community_print_vty (struct vty *vty, struct community *com)
{
    int i;
    u_int32_t comval;
    u_int16_t as;
    u_int16_t val;

    for (i = 0; i < com->size; i++)
    {
        memcpy (&comval, com_nthval (com, i), sizeof (u_int32_t));
        comval = ntohl (comval);
        switch (comval)
        {
        case COMMUNITY_NO_EXPORT:
            vty_out (zlog_default,LOG_DEBUG, " no-export");
            break;
        case COMMUNITY_NO_ADVERTISE:
            vty_out (zlog_default,LOG_DEBUG, " no-advertise");
            break;
        case COMMUNITY_LOCAL_AS:
            vty_out (zlog_default,LOG_DEBUG, " local-AS");
            break;
        default:
            as = (comval >> 16) & 0xFFFF ;
            val = comval & 0xFFFF;
            vty_out (zlog_default,LOG_DEBUG, " %d:%d", as, val);
            break;
        }
    }
}

/* For `show ip bgp community' command. */
void
Bgp::community_print_all_vty (struct vty *vty)
{
    int i;
    HashBacket *mp;

    for (i = 0; i < HASHTABSIZE; i++)
        if ((mp = (HashBacket *) hash_head (comhash, i)) != NULL)
            while (mp)
            {
                struct community *com;

                com = (struct community *) mp->data;

                vty_out (zlog_default,LOG_DEBUG, "[%p:%d] (%ld)", mp, i, com->refcnt);
                community_print_vty (vty, com);
                vty_out (zlog_default,LOG_DEBUG, "%s", VTY_NEWLINE);
                mp = mp->next;
            }
}


/* Get next community token from string. */
u_char *
Bgp::community_gettoken (char *buf, enum community_token *token, u_int32_t *val)
{
    char *p = buf;

    /* Skip white space. */
    while (isspace ((int) *p))
        p++;

    /* Check the end of the line. */
    if (*p == '\0')
        return NULL;

    /* Well known community string check. */
    if (isalpha ((int) *p))
    {
        if (strncmp (p, "no-export", strlen ("no-export")) == 0)
        {
            *val = COMMUNITY_NO_EXPORT;
            *token = community_token_no_export;
            p += strlen ("no-export");
            return (u_char*)p;
        }
        if (strncmp (p, "no-advertise", strlen ("no-advertise")) == 0)
        {
            *val = COMMUNITY_NO_ADVERTISE;
            *token = community_token_no_advertise;
            p += strlen ("no-advertise");
            return (u_char*)p;
        }
        if (strncmp (p, "local-AS", strlen ("local-AS")) == 0)
        {
            *val = COMMUNITY_LOCAL_AS;
            *token = community_token_local_as;
            p += strlen ("local-AS");
            return (u_char*)p;
        }

        /* Unknown string. */
        *token = community_token_unknown;
        return (u_char*)p;
    }

    /* Community value. */
    if (isdigit ((int) *p))
    {
        int separator = 0;
        u_int32_t community_low = 0;
        u_int32_t community_high = 0;

        while (isdigit ((int) *p) || *p == ':')
        {
            if (*p == ':')
            {
                if (separator)
                {
                    *token = community_token_unknown;
                    return (u_char*)p;
                } else
                {
                    separator = 1;
                    community_high = community_low << 16;
                    community_low = 0;
                }
            } else
            {
                community_low *= 10;
                community_low += (*p - '0');
            }
            p++;
        }
        *val = community_high + community_low;
        *token = community_token_val;
        return (u_char*)p;
    }
    *token = community_token_unknown;
    return (u_char*)p;
}

/* convert string to community structure */
struct community *
Bgp::community_str2com (char *str)
{
    struct community *com = NULL;
    struct community *com_sort = NULL;
    u_int32_t val;
    enum community_token token;

    while ((str = ( char * ) community_gettoken (str, &token, &val)))
    {
        switch (token)
        {
        case community_token_val:
        case community_token_no_export:
        case community_token_no_advertise:
        case community_token_local_as:
            if (com == NULL)
                com = community_new();
            community_add_val (com, val);
            break;
        case community_token_unknown:
        default:
            if (com)
                community_free (com);
            return NULL;
            break;
        }
    }

    com_sort = community_uniq_sort (com);
    community_free (com);

    return com_sort;
}

unsigned long
Bgp::community_count ()
{
    return comhash->count;
}





////////////////////////////////////////////////
////////////////////////////////////////////////
/////////////////////bgp_damp.c/////////////////
////////////////////////////////////////////////

#ifndef HAVE_ZEBRA_93b

int
Bgp::bgp_damp_init(struct vty *vty, int hlife, int reuse, int sup, int maxsup)
{

  double reuse_max_ratio;
  int i;
  struct bgp_damp_config *bdc;
  
  if (hlife == -1)
    hlife = DEFAULT_HALF_LIFE * 60;
  
  if (reuse == -1)
    {
      /* Default values */
      reuse = DEFAULT_REUSE;
      sup = DEFAULT_SUPPRESS;
      maxsup = 4*hlife;
    }
  
  /* Clear previous configuration if any */
  if (prev_bgp_damp_cfg)
    bgp_damp_clear_config (&bgp_damp_cfg);
  
  prev_bgp_damp_cfg = bdc = &bgp_damp_cfg;
  bdc->suppress_value = sup;
  bdc->half_life = hlife;
  bdc->reuse_limit = reuse;
  bdc->max_suppress_time = maxsup;
  
  /* Initialize system-wide params */
  bdc->reuse_list_size = REUSE_LIST_SIZE;
  bdc->reuse_index_array_size = REUSE_ARRAY_SIZE;
  
  bdc->ceiling = (int)(bdc->reuse_limit * 
     		       exp((double) (bdc->max_suppress_time/bdc->half_life)) * log(2.0));
  
  /* Decay-array computations */
  bdc->decay_array_size = (int)  ceil ((double)bdc->max_suppress_time/DELTA_T);
  bdc->decay_array =( double * )  XMALLOC (MTYPE_BGP_DAMP_ARRAY,
					   sizeof(double) * (bdc->decay_array_size));
  bdc->decay_array[0] = 1.0;
  bdc->decay_array[1] = exp ((1.0/(bdc->half_life/DELTA_T)) * log(0.5));
  
  /* Calculate decay values for all possible times */
  for (i = 2; i < bdc->decay_array_size; i++)
    bdc->decay_array[i] = bdc->decay_array[i-1] * bdc->decay_array[1];
  
  /* Reuse-list computations */
  bdc->reuse_list_array = ( bgp_damp_info **) XMALLOC (MTYPE_BGP_DAMP_ARRAY, 
			  bdc->reuse_list_size * sizeof (struct bgp_reuse_list *));
  memset (bdc->reuse_list_array, 0x00, 
	  bdc->reuse_list_size * sizeof (struct bgp_reuse_list*));
  
  /* Reuse-array computations */
  bdc->reuse_index_array = ( int * ) XMALLOC (MTYPE_BGP_DAMP_ARRAY, 
					      sizeof(int) * bdc->reuse_index_array_size);
  reuse_max_ratio = bdc->ceiling/bdc->reuse_limit;
  i = (int)exp((1.0/((double)bdc->half_life/(bdc->reuse_list_size*DELTA_REUSE))) * log(2.0));
  if ( reuse_max_ratio > i && i != 0 )
    reuse_max_ratio = i;
  
  bdc->scale_factor = (int) ceil((double)bdc->reuse_index_array_size/(reuse_max_ratio - 1));
  
  for (i = 0; i < bdc->reuse_index_array_size; i++)
    {
      bdc->reuse_index_array[i] = (int)
	ceil( (bdc->half_life/DELTA_REUSE)
	      * log(1.0/(bdc->reuse_limit * ( 1.0 + ((double)i/bdc->scale_factor)))) / log(0.5) );
    }
  
  return CMD_SUCCESS;
}

double
Bgp::bgp_damp_get_decay(time_t tdiff)
{
    int i;
    struct bgp_damp_config *bdc;

    bdc = &bgp_damp_cfg;
    i = tdiff/DELTA_T;

    if (i >= bdc->decay_array_size)
        return 0;

    return bdc->decay_array[i];
}


int
Bgp::bgp_get_reuse_index(int penalty)
{
    int i;
    struct bgp_damp_config *bdc;

    bdc = &bgp_damp_cfg;
    i = (int)(((double)penalty / bdc->reuse_limit - 1.0) * bdc->scale_factor);

    if (i >= bdc->reuse_index_array_size)
        i = bdc->reuse_index_array_size - 1;
    return(bdc->reuse_index_array[i]);
}

void
Bgp::bgp_reuse_list_insert(struct bgp_damp_info *bdi)
{
    int index;
    struct bgp_damp_config *bdc;

    if (first_time_insert)
    {
        /* Kick off reuse timer */
        bgp_reuse_thread 
        = thread_add_timer (master, &Bgp::bgp_reuse_timer, NULL, DELTA_REUSE);
        first_time_insert = 0;
    }

    bdc = &bgp_damp_cfg;

    index = (reuse_array_offset + bgp_get_reuse_index(bdi->penalty)) % bdc->reuse_list_size;
    bdi->reuse_next = bdc->reuse_list_array[index];
    bdc->reuse_list_array[index] = bdi;

    return;
}

/* bgp_reuse_timer is called every DELTA_REUSE seconds.
 * Each route in the current reuse-list is evaluated and is used or requeued
 */
int
Bgp::bgp_reuse_timer(struct thread *t)
{
    struct bgp_damp_info *bdi, *tbdi;
    struct bgp_damp_config *bdc;
    time_t t_now, t_diff;


    /* Restart the reuse timer */
    bgp_reuse_thread = thread_add_timer(master,&Bgp:: bgp_reuse_timer, 
                                        NULL, DELTA_REUSE);

    /* zlog(NULL, LOG_INFO, "DAMP:reuse timer:offset: %d", reuse_array_offset); */

    double simulation_time;
    simulation_time = Scheduler::instance().clock();
    t_now = Bgp::start_time + (int)simulation_time;

    bdc = &bgp_damp_cfg;
    bdi = bdc->reuse_list_array[reuse_array_offset];
    bdc->reuse_list_array[reuse_array_offset] = NULL;
    reuse_array_offset = (reuse_array_offset + 1 ) % bdc->reuse_list_size;

    while (bdi)
    {
        tbdi = bdi->reuse_next;
        bdi->reuse_next = NULL;
        t_diff = t_now - bdi->t_updated;
        bdi->t_updated = t_now;

        if (bdi->bgp_info == NULL)
            free(bdi);
        else
        {
            bdi->penalty
            = (int)((double)bdi->penalty * bgp_damp_get_decay(t_diff));

	    /* zlog(NULL, LOG_INFO, "DAMP:reuse timer: updated penalty: %d", bdi->penalty); */

            if (bdi->penalty <= bdc->reuse_limit/2)
            {
                UNSET_FLAG (bdi->bgp_info->flags, BGP_INFO_DAMPED);
                bdi->bgp_info->bgp_damp_info = NULL;
                free(bdi);
            } else if (bdi->penalty < bdc->reuse_limit)
                UNSET_FLAG (bdi->bgp_info->flags, BGP_INFO_DAMPED);
            else
                bgp_reuse_list_insert(bdi);
        }

        bdi = tbdi;
    }

    return 0;
}

int
Bgp::bgp_damp_withdraw(struct bgp_info *bgp_info)
{
    time_t t_now;
    struct bgp_damp_info *bdi;
    struct bgp_damp_config *bdc;
    int status;

    bdc = &bgp_damp_cfg;

    if (! bdc->enabled)
        return BGP_DAMP_DISABLED;

    SET_FLAG (bgp_info->flags, BGP_INFO_HISTORY);

    double simulation_time;
    simulation_time = Scheduler::instance().clock();
    t_now = start_time + (int)simulation_time;

    bdi = bgp_info->bgp_damp_info;

    status = BGP_DAMP_CONTINUE;

    if (bdi == NULL)
    {
        bdi = (bgp_damp_info * )  XMALLOC (MTYPE_BGP_DAMP_INFO, sizeof (struct bgp_damp_info));
        memset (bdi, 0, sizeof (struct bgp_damp_info));
        bgp_info->bgp_damp_info = bdi;
        bdi->penalty = DEFAULT_PENALTY;
        bdi->flap = 1;
        bdi->start_time = t_now;
        bdi->bgp_info = bgp_info;
    } else
    {
        bdi->penalty = (int)(bdi->penalty * bgp_damp_get_decay(t_now - bdi->t_updated)) + DEFAULT_PENALTY;
        bdi->flap++;
        if (bdi->penalty > bdc->ceiling)
            bdi->penalty = bdc->ceiling;
    }

    /* If the penalty is greater than suppress value or the route is damped,
     * no need to send withdraw to peers.
     */
    if (CHECK_FLAG (bdi->bgp_info->flags, BGP_INFO_DAMPED))
        status = BGP_DAMP_DISCONTINUE;
    else if (bdi->penalty >= bdc->suppress_value)
    {
        bgp_reuse_list_insert(bdi);
        SET_FLAG (bdi->bgp_info->flags, BGP_INFO_DAMPED);
    }
    bdi->t_updated = t_now;

    /* zlog(NULL, LOG_ERR, "DAMP:Withdraw - penalty: %d, damped: %d", bdi->penalty, bdi->bgp_info->damped); */

    return(status);
}

int
Bgp::bgp_damp_update(struct bgp_info *bgp_info)
{
    time_t t_now;
    struct bgp_damp_info *bdi;
    struct bgp_damp_config *bdc;
    int status;

    bdc = &bgp_damp_cfg;

    if (! bdc->enabled)
        return BGP_DAMP_DISABLED;

    if ((bdi = bgp_info->bgp_damp_info) == NULL)
        return BGP_DAMP_CONTINUE;
    double simulation_time;
    simulation_time = Scheduler::instance().clock();
    t_now = start_time + (int)simulation_time;

    bdi->penalty = (int) (bdi->penalty * bgp_damp_get_decay(t_now - bdi->t_updated));

    /* zlog(NULL, LOG_ERR, "UPDATE: penalty: %d", bdi->penalty); */
    if (! CHECK_FLAG (bgp_info->flags, BGP_INFO_DAMPED)
        && (bdi->penalty < bdc->suppress_value))
    {
        status = BGP_DAMP_CONTINUE;
    } else if (CHECK_FLAG (bgp_info->flags, BGP_INFO_DAMPED)
               && (bdi->penalty < bdc->reuse_limit))
    {
        UNSET_FLAG (bgp_info->flags, BGP_INFO_DAMPED);
        status = BGP_DAMP_CONTINUE;
    } else
        status = BGP_DAMP_DISCONTINUE;

    bdi->t_updated = t_now;

    return status;
}

int
Bgp::bgp_damp_enable(struct vty *vty, int argc, char **argv)
{

    bgp_damp_cfg.enabled = 1;

    if (argc == 0)
    {
        if (prev_bgp_damp_cfg)
        {
            if (! bgp_reuse_thread)
                bgp_reuse_thread
                = thread_add_timer(master, &Bgp::bgp_reuse_timer, NULL, DELTA_REUSE);

            /* zlog(NULL, LOG_ERR, "Using old config"); */

            return CMD_SUCCESS;
        }

        /* zlog(NULL, LOG_ERR, "Using New config"); */

        return bgp_damp_init(vty, -1, -1, -1, -1);
    }

    if (argc == 1)
    {
        return bgp_damp_init (vty, atoi(argv[0])*60, -1, -1, -1);
    }

    return bgp_damp_init (vty, atoi(argv[0]) * 60, atoi(argv[1]), atoi(argv[2]),
                          atoi(argv[3]) * 60);
}

int
Bgp::bgp_damp_disable( struct vty *vty )
{

    bgp_damp_cfg.enabled = 0;

    if (bgp_reuse_thread)
        thread_cancel (bgp_reuse_thread);

    bgp_reuse_thread = NULL;

    /* Clear the reuse list entries */
    bgp_damp_clear_reuse_list();

    /* Clear configuration */
    bgp_damp_clear_config(&bgp_damp_cfg);

    return CMD_SUCCESS;
}

void
Bgp::bgp_damp_clear_config(struct bgp_damp_config *bdc)
{
    /* Free decay array */
    free (bdc->decay_array);

    /* Free reuse index array */
    free (bdc->reuse_index_array);

    if (bgp_reuse_thread)
        thread_cancel (bgp_reuse_thread);
    bgp_reuse_thread = NULL;

    /* Remove all entries from reuse lists */
    prev_bgp_damp_cfg = NULL;
}

void
Bgp::bgp_damp_clear_reuse_list()
{
    struct bgp_damp_info *bdi, *tbdi;
    struct bgp_damp_config *bdc;
    int i;

    reuse_array_offset = 0;
    bdc = &bgp_damp_cfg;

    //printf("%d",bdc->reuse_list_size);
    for (i = 0; i < bdc->reuse_list_size; i++)
    {

        if (bdc->reuse_list_array[i] == NULL)
            continue;

        bdi = bdc->reuse_list_array[i];
        bdc->reuse_list_array[i] = NULL;

        while (bdi)
        {
            tbdi = bdi->reuse_next;

            if (bdi->bgp_info)
            {
                bdi->bgp_info->bgp_damp_info = NULL;
                UNSET_FLAG (bdi->bgp_info->flags, BGP_INFO_DAMPED);
            }

            free (bdi);
            bdi = tbdi;
        }
    }

}


int
Bgp::bgp_config_write_damp (struct vty *vty)
{
    if (bgp_damp_cfg.enabled)
    {
        if (bgp_damp_cfg.half_life == DEFAULT_HALF_LIFE*60
            && bgp_damp_cfg.reuse_limit == DEFAULT_REUSE
            && bgp_damp_cfg.suppress_value == DEFAULT_SUPPRESS
            && bgp_damp_cfg.max_suppress_time == bgp_damp_cfg.half_life*4)
            vty_out (zlog_default,LOG_DEBUG, " bgp dampening%s", VTY_NEWLINE);
        else if (bgp_damp_cfg.half_life != DEFAULT_HALF_LIFE*60
                 && bgp_damp_cfg.reuse_limit == DEFAULT_REUSE
                 && bgp_damp_cfg.suppress_value == DEFAULT_SUPPRESS
                 && bgp_damp_cfg.max_suppress_time == bgp_damp_cfg.half_life*4)
            vty_out (zlog_default,LOG_DEBUG, " bgp dampening %d%s",
                     bgp_damp_cfg.half_life/60,
                     VTY_NEWLINE);
        else
            vty_out (zlog_default,LOG_DEBUG, " bgp dampening %d %d %d %d%s",
                     bgp_damp_cfg.half_life/60,
                     bgp_damp_cfg.reuse_limit,
                     bgp_damp_cfg.suppress_value,
                     bgp_damp_cfg.max_suppress_time/60,
                     VTY_NEWLINE);
        return 1;
    }
    return 0;
}

int
Bgp::bgp_damp_info_print (struct vty *vty, struct bgp_info *bgp_info)
{
    struct bgp_damp_info *bdi;
    time_t t_now;
    char timebuf[BGP_UPTIME_LEN];

    if ((bdi = bgp_info->bgp_damp_info) == NULL)
        return CMD_WARNING;
    
    double simulation_time;
    simulation_time = Scheduler::instance().clock();
    t_now = start_time + (int) simulation_time;

    vty_out (zlog_default,LOG_DEBUG, "      Dampinfo: penalty %d, flapped %d times in %s",
             (int)(bdi->penalty * bgp_damp_get_decay(t_now - bdi->t_updated)),
             bdi->flap, peer_uptime (bdi->start_time, timebuf, BGP_UPTIME_LEN));
    if (CHECK_FLAG (bdi->bgp_info->flags, BGP_INFO_DAMPED)
        && ! CHECK_FLAG (bdi->bgp_info->flags, BGP_INFO_HISTORY))
        vty_out (zlog_default,LOG_DEBUG, ", reuse in 00:00:00");
    vty_out (zlog_default,LOG_DEBUG, "%s", VTY_NEWLINE);

    return CMD_SUCCESS;
}
#endif

////////////////////////////////////////////////
////////////////////////////////////////////////
/////////////////////bgp_debug.c////////////////
////////////////////////////////////////////////

/* Dump attribute. */
void
Bgp::bgp_dump_attr (struct peer *peer, struct attr *attr, char *buf, size_t size)
{
    if (attr == NULL)
        return;

    snprintf (buf, size, "nexthop %s", inet_ntoa (attr->nexthop));
    snprintf (buf + strlen (buf), size - strlen (buf), ", origin %s",
              bgp_origin_str[attr->origin]);


    if (peer_sort (peer) == BGP_PEER_IBGP)
    {
        snprintf (buf + strlen (buf), size - strlen (buf), ", localpref %d",
                  attr->local_pref);
    }

    if (attr->med)
    {
        snprintf (buf + strlen (buf), size - strlen (buf), ", metric %d",
                  attr->med);
    }

    if (attr->community)
    {
        snprintf (buf + strlen (buf), size - strlen (buf), ", community%s",
                  community_print (attr->community));
    }

    if (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_ATOMIC_AGGREGATE))
        snprintf (buf + strlen (buf), size - strlen (buf), ", atomic-aggregate");

    if (attr->aggregator_as)
    {
        snprintf (buf + strlen (buf), size - strlen (buf), ", aggregated by %d %s",
                  attr->aggregator_as, inet_ntoa (attr->aggregator_addr));
    }

    if (attr->flag & ATTR_FLAG_BIT (BGP_ATTR_ORIGINATOR_ID))
    {
        snprintf (buf + strlen (buf), size - strlen (buf), ", originator %s",
                  inet_ntoa (attr->originator_id));
    }

    if (attr->flag & ATTR_FLAG_BIT (BGP_ATTR_CLUSTER_LIST))
    {
        int i;

        snprintf (buf + strlen (buf), size - strlen (buf), ", clusterlist ");
        for (i = 0; i < attr->cluster->length / 4; i++)
            snprintf (buf + strlen (buf), size - strlen (buf), "%s",
                      inet_ntoa (attr->cluster->list[i]));
    }

    if (attr->aspath)
    {
        snprintf (buf + strlen (buf), size - strlen (buf), ", path %s",
                  aspath_print (attr->aspath));
    }
}

/* dump notify packet */
void
Bgp::bgp_notify_print(struct peer *peer, struct bgp_notify *bgp_notify, char *direct)
{
    char *subcode_str;

    subcode_str = "";

    switch (bgp_notify->code)
    {
    case BGP_NOTIFY_HEADER_ERR:
        subcode_str = LOOKUP (bgp_notify_head_msg, bgp_notify->subcode);
        break;
    case BGP_NOTIFY_OPEN_ERR:
        subcode_str = LOOKUP (bgp_notify_open_msg, bgp_notify->subcode);
        break;
    case BGP_NOTIFY_UPDATE_ERR:
        subcode_str = LOOKUP (bgp_notify_update_msg, bgp_notify->subcode);
        break;
    case BGP_NOTIFY_HOLD_ERR:
        subcode_str = "";
        break;
    case BGP_NOTIFY_FSM_ERR:
        subcode_str = "";
        break;
    case BGP_NOTIFY_CEASE:
        subcode_str = "";
        break;
    }
    if (BGP_DEBUG (normal, NORMAL))
        plog_info (peer->log, "%s %s NOTIFICATION %d/%d (%s%s) %d bytes %s\n",
                   peer ? peer->host : "",
                   direct, bgp_notify->code, bgp_notify->subcode,
                   LOOKUP (bgp_notify_msg, bgp_notify->code),
                   subcode_str, bgp_notify->length,
                   bgp_notify->data ? bgp_notify->data : "");
}

#if 0
/* Open packet dump */
void
bgp_open_dump (struct bgp_open *bgp_open, struct peer *peer, int direct)
{
    /* decide whether dump or not */
    if (direct == PACKET_RECV &&
        IS_SET(dump_open, DUMP_SEND))
    {

        if (IS_SET(dump_open, DUMP_DETAIL))
        {
            /* detail */
            zlog (peer->log, LOG_INFO, "Open: peer(%s) version(%d) AS(%d) holdtime(%d)"
                  "      ident(%lu) optlen(%d)\n",
                  peer->host,
                  bgp_open->version, bgp_open->asno, bgp_open->holdtime,
                  bgp_open->ident, bgp_open->optlen);
        } else
        {
            /* normal */
            zlog (peer->log, LOG_INFO, "Open: peer(%s)\n", peer->host);
        }
    }
}
#endif

/* Dump BGP open packet. */
void
Bgp::bgp_packet_open_dump (struct stream *s)
{
    printf ("BGP open ");
    printf ("version: %d ", stream_getc (s));
    printf ("as: %d ", stream_getw (s));
    printf ("holdtime: %d ", stream_getw (s));
    printf ("ident: %d\n", stream_getl (s));

    /* Open message option. */
    printf ("opt parm len: %d\n", stream_getc (s));
}

void
Bgp::bgp_packet_notify_dump (struct stream *s)
{
    struct bgp_notify bgp_notify;

    bgp_notify.code = stream_getc (s);
    bgp_notify.subcode = stream_getc (s);
    bgp_notify_print (NULL, &bgp_notify, "received");
}

/* Dump bgp update packet. */
void
Bgp::bgp_update_dump (struct stream *s)
{
    u_char *endp;
    bgp_size_t unfeasible_len;
    bgp_size_t attr_total_len;

    unfeasible_len = stream_getw (s);
    printf ("Unfeasible length: %d\n", unfeasible_len);

    stream_forward (s, unfeasible_len);

    attr_total_len = stream_getw (s);
    printf ("Attribute length: %d\n", attr_total_len);

    endp = STREAM_PNT (s) + attr_total_len;

    while (STREAM_PNT (s) < endp)
    {
        u_char flag;
        u_char type;
        bgp_size_t length;

        flag = stream_getc (s);
        type = stream_getc (s);

        printf ("flag: %d\n", flag);
        printf ("type: %d\n", type);

        if (flag & BGP_ATTR_FLAG_EXTLEN)
            length = stream_getw (s);
        else
            length = stream_getc (s);
#if 0
        printf ("length %d\n", length);

        stream_forward (s, length);
#else 
        {
            int p1;
            printf ("length %d // ", length);
            for (p1=length; p1 ; p1--)
            {
                printf("0x%02x ",(unsigned char)  stream_getc (s) );
            }
            printf("\n");
        }
#endif
    }
	
}
/* Debug dump of bgp packet. */
void
Bgp::bgp_packet_dump (struct stream *s)
{
    int i;
    u_char type;
    u_int16_t size;
    unsigned long sp;

    /* Preserve pointer. */
    sp = stream_get_getp (s);
    stream_set_getp (s, 0);

    /* Marker dump. */
    printf ("BGP packet marker : ");
    for (i = 0; i < BGP_MARKER_SIZE; i++)
        printf ("%x ", stream_getc (s));
    printf ("\n");

    /* BGP packet size. */
    size = stream_getw (s);
    printf ("BGP packet size : %d\n", size);

    /* BGP packet type. */
    type = stream_getc (s);
    printf ("BGP packet type : %s (%d)\n", bgp_type_str[type], type);

    switch (type)
    {
    case BGP_MSG_OPEN:
        bgp_packet_open_dump (s);
        break;
    case BGP_MSG_KEEPALIVE:
        assert (size == BGP_HEADER_SIZE);
        return;
        break;
    case BGP_MSG_UPDATE:
        bgp_update_dump (s);
        break;
    case BGP_MSG_NOTIFY:
        bgp_packet_notify_dump (s);
        break;
    }
    stream_set_getp (s, sp);
}


DEFUN (debug_bgp_fsm,
       debug_bgp_fsm_cmd,
       "debug bgp fsm",
       DEBUG_STR
       BGP_STR
       "BGP Finite State Machine\n")
{
    if (vty->node == CONFIG_NODE)
        DEBUG_ON (fsm, FSM);
    else
    {
        TERM_DEBUG_ON (fsm, FSM);
        vty_out (zlog_default,LOG_DEBUG, "BGP fsm debugging is on%s", VTY_NEWLINE);
    }
    return CMD_SUCCESS;
}

DEFUN (no_debug_bgp_fsm,
       no_debug_bgp_fsm_cmd,
       "no debug bgp fsm",
       NO_STR
       DEBUG_STR
       BGP_STR
       "Finite State Machine\n")
{
    if (vty->node == CONFIG_NODE)
        DEBUG_OFF (fsm, FSM);
    else
    {
        TERM_DEBUG_OFF (fsm, FSM);
        vty_out (zlog_default,LOG_DEBUG, "BGP fsm debugging is off%s", VTY_NEWLINE);
    }
    return CMD_SUCCESS;
}

DEFUN (debug_bgp_events,
       debug_bgp_events_cmd,
       "debug bgp events",
       DEBUG_STR
       BGP_STR
       "BGP events\n")
{
    if (vty->node == CONFIG_NODE)
        DEBUG_ON (events, EVENTS);
    else
    {
        TERM_DEBUG_ON (events, EVENTS);
        vty_out (zlog_default,LOG_DEBUG, "BGP events debugging is on%s", VTY_NEWLINE);
    }
    return CMD_SUCCESS;
}

DEFUN (no_debug_bgp_events,
       no_debug_bgp_events_cmd,
       "no debug bgp events",
       NO_STR
       DEBUG_STR
       BGP_STR
       "BGP events\n")
{
    if (vty->node == CONFIG_NODE)
        DEBUG_OFF (events, EVENTS);
    else
    {
        TERM_DEBUG_OFF (events, EVENTS);
        vty_out (zlog_default,LOG_DEBUG, "BGP events debugging is off%s", VTY_NEWLINE);
    }
    return CMD_SUCCESS;
}


DEFUN (debug_bgp_filter,
       debug_bgp_filter_cmd,
       "debug bgp filters",
       DEBUG_STR
       BGP_STR
       "BGP filters\n")
{
    if (vty->node == CONFIG_NODE)
        DEBUG_ON (filter, FILTER);
    else
    {
        TERM_DEBUG_ON (filter, FILTER);
        vty_out (zlog_default,LOG_DEBUG, "BGP filters debugging is on%s", VTY_NEWLINE);
    }
    return CMD_SUCCESS;
}

DEFUN (no_debug_bgp_filter,
       no_debug_bgp_filter_cmd,
       "no debug bgp filters",
       NO_STR
       DEBUG_STR
       BGP_STR
       "BGP filters\n")
{
    if (vty->node == CONFIG_NODE)
        DEBUG_OFF (filter, FILTER);
    else
    {
        TERM_DEBUG_OFF (filter, FILTER);
        vty_out (zlog_default,LOG_DEBUG, "BGP filters debugging is off%s", VTY_NEWLINE);
    }
    return CMD_SUCCESS;
}


DEFUN (debug_bgp_keepalive,
       debug_bgp_keepalive_cmd,
       "debug bgp keepalives",
       DEBUG_STR
       BGP_STR
       "BGP keepalives\n")
{
    if (vty->node == CONFIG_NODE)
        DEBUG_ON (keepalive, KEEPALIVE);
    else
    {
        TERM_DEBUG_ON (keepalive, KEEPALIVE);
        vty_out (zlog_default,LOG_DEBUG, "BGP keepalives debugging is on%s", VTY_NEWLINE);
    }
    return CMD_SUCCESS;
}

DEFUN (no_debug_bgp_keepalive,
       no_debug_bgp_keepalive_cmd,
       "no debug bgp keepalives",
       NO_STR
       DEBUG_STR
       BGP_STR
       "BGP keepalives\n")
{
    if (vty->node == CONFIG_NODE)
        DEBUG_OFF (keepalive, KEEPALIVE);
    else
    {
        TERM_DEBUG_OFF (keepalive, KEEPALIVE);
        vty_out (zlog_default,LOG_DEBUG, "BGP keepalives debugging is off%s", VTY_NEWLINE);
    }
    return CMD_SUCCESS;
}


DEFUN (debug_bgp_update,
       debug_bgp_update_cmd,
       "debug bgp updates",
       DEBUG_STR
       BGP_STR
       "BGP updates\n")
{
    if (vty->node == CONFIG_NODE)
    {
        DEBUG_ON (update, UPDATE_IN);
        DEBUG_ON (update, UPDATE_OUT);
    } else
    {
        TERM_DEBUG_ON (update, UPDATE_IN);
        TERM_DEBUG_ON (update, UPDATE_OUT);
        vty_out (zlog_default,LOG_DEBUG, "BGP updates debugging is on%s", VTY_NEWLINE);
    }
    return CMD_SUCCESS;
}

DEFUN (debug_bgp_update_direct,
       debug_bgp_update_direct_cmd,
       "debug bgp updates (in|out)",
       DEBUG_STR
       BGP_STR
       "BGP updates\n"
       "Inbound updates\n"
       "Outbound updates\n")
{
    if (vty->node == CONFIG_NODE)
    {
        if (strncmp ("i", argv[0], 1) == 0)
        {
            DEBUG_OFF (update, UPDATE_OUT);
            DEBUG_ON (update, UPDATE_IN);
        } else
        {
            DEBUG_OFF (update, UPDATE_IN);
            DEBUG_ON (update, UPDATE_OUT);
        }
    } else
    {
        if (strncmp ("i", argv[0], 1) == 0)
        {
            TERM_DEBUG_OFF (update, UPDATE_OUT);
            TERM_DEBUG_ON (update, UPDATE_IN);
            vty_out (zlog_default,LOG_DEBUG, "BGP updates debugging is on (inbound)%s", VTY_NEWLINE);
        } else
        {
            TERM_DEBUG_OFF (update, UPDATE_IN);
            TERM_DEBUG_ON (update, UPDATE_OUT);
            vty_out (zlog_default,LOG_DEBUG, "BGP updates debugging is on (outbound)%s", VTY_NEWLINE);
        }
    }
    return CMD_SUCCESS;
}

DEFUN (no_debug_bgp_update,
       no_debug_bgp_update_cmd,
       "no debug bgp updates",
       NO_STR
       DEBUG_STR
       BGP_STR
       "BGP updates\n")
{
    if (vty->node == CONFIG_NODE)
    {
        DEBUG_OFF (update, UPDATE_IN);
        DEBUG_OFF (update, UPDATE_OUT);
    } else
    {
        TERM_DEBUG_OFF (update, UPDATE_IN);
        TERM_DEBUG_OFF (update, UPDATE_OUT);
        vty_out (zlog_default,LOG_DEBUG, "BGP updates debugging is off%s", VTY_NEWLINE);
    }
    return CMD_SUCCESS;
}


DEFUN (debug_bgp_normal,
       debug_bgp_normal_cmd,
       "debug bgp",
       DEBUG_STR
       BGP_STR)
{
    if (vty->node == CONFIG_NODE)
        DEBUG_ON (normal, NORMAL);
    else
    {
        TERM_DEBUG_ON (normal, NORMAL);
        vty_out (zlog_default,LOG_DEBUG, "BGP debugging is on%s", VTY_NEWLINE);
    }
    return CMD_SUCCESS;
}

DEFUN (no_debug_bgp_normal,
       no_debug_bgp_normal_cmd,
       "no debug bgp",
       NO_STR
       DEBUG_STR
       BGP_STR)
{
    if (vty->node == CONFIG_NODE)
        DEBUG_OFF (normal, NORMAL);
    else
    {
        TERM_DEBUG_OFF (normal, NORMAL);
        vty_out (zlog_default,LOG_DEBUG, "BGP debugging is off%s", VTY_NEWLINE);
    }
    return CMD_SUCCESS;
}


DEFUN (no_debug_bgp_all,
       no_debug_bgp_all_cmd,
       "no debug all bgp",
       NO_STR
       DEBUG_STR
       "Enable all debugging\n"
       BGP_STR)
{
    TERM_DEBUG_OFF (normal, NORMAL);
    TERM_DEBUG_OFF (events, EVENTS);
    TERM_DEBUG_OFF (keepalive, KEEPALIVE);
    TERM_DEBUG_OFF (update, UPDATE_IN);
    TERM_DEBUG_OFF (update, UPDATE_OUT);
    TERM_DEBUG_OFF (fsm, FSM);
    TERM_DEBUG_OFF (filter, FILTER);
    vty_out (zlog_default,LOG_DEBUG, "All possible debugging has been turned off%s", VTY_NEWLINE);

    return CMD_SUCCESS;
}


DEFUN (show_debugging_bgp,
       show_debugging_bgp_cmd,
       "show debugging bgp",
       SHOW_STR
       DEBUG_STR
       BGP_STR)
{
    vty_out (zlog_default,LOG_DEBUG, "BGP debugging status:%s", VTY_NEWLINE);

    if (BGP_DEBUG (normal, NORMAL))
        vty_out (zlog_default,LOG_DEBUG, "  BGP debugging is on%s", VTY_NEWLINE);
    if (BGP_DEBUG (events, EVENTS))
        vty_out (zlog_default,LOG_DEBUG, "  BGP events debugging is on%s", VTY_NEWLINE);
    if (BGP_DEBUG (keepalive, KEEPALIVE))
        vty_out (zlog_default,LOG_DEBUG, "  BGP keepalives debugging is on%s", VTY_NEWLINE);
    if (BGP_DEBUG (update, UPDATE_IN) && BGP_DEBUG (update, UPDATE_OUT))
        vty_out (zlog_default,LOG_DEBUG, "  BGP updates debugging is on%s", VTY_NEWLINE);
    else if (BGP_DEBUG (update, UPDATE_IN))
        vty_out (zlog_default,LOG_DEBUG, "  BGP updates debugging is on (inbound)%s", VTY_NEWLINE);
    else if (BGP_DEBUG (update, UPDATE_OUT))
        vty_out (zlog_default,LOG_DEBUG, "  BGP updates debugging is on (outbound)%s", VTY_NEWLINE);
    if (BGP_DEBUG (fsm, FSM))
        vty_out (zlog_default,LOG_DEBUG, "  BGP fsm debugging is on%s", VTY_NEWLINE);
    if (BGP_DEBUG (filter, FILTER))
        vty_out (zlog_default,LOG_DEBUG, "  BGP filter debugging is on%s", VTY_NEWLINE);
    vty_out (zlog_default,LOG_DEBUG, "%s", VTY_NEWLINE);
    return CMD_SUCCESS;
}

void
Bgp::bgp_debug_init ()
{
    install_element (CONFIG_NODE, &show_debugging_bgp_cmd);
    install_element (CONFIG_NODE, &debug_bgp_fsm_cmd);
    install_element (CONFIG_NODE, &debug_bgp_events_cmd);
    install_element (CONFIG_NODE, &debug_bgp_filter_cmd);
    install_element (CONFIG_NODE, &debug_bgp_keepalive_cmd);
    install_element (CONFIG_NODE, &debug_bgp_update_cmd);
    install_element (CONFIG_NODE, &debug_bgp_update_direct_cmd);
    install_element (CONFIG_NODE, &debug_bgp_normal_cmd);
    install_element (CONFIG_NODE, &undebug_bgp_fsm_cmd);
    install_element (CONFIG_NODE, &no_debug_bgp_fsm_cmd);
    install_element (CONFIG_NODE, &undebug_bgp_events_cmd);
    install_element (CONFIG_NODE, &no_debug_bgp_events_cmd);
    install_element (CONFIG_NODE, &undebug_bgp_filter_cmd);
    install_element (CONFIG_NODE, &no_debug_bgp_filter_cmd);
    install_element (CONFIG_NODE, &undebug_bgp_keepalive_cmd);
    install_element (CONFIG_NODE, &no_debug_bgp_keepalive_cmd);
    install_element (CONFIG_NODE, &undebug_bgp_update_cmd);
    install_element (CONFIG_NODE, &no_debug_bgp_update_cmd);
    install_element (CONFIG_NODE, &undebug_bgp_normal_cmd);
    install_element (CONFIG_NODE, &no_debug_bgp_normal_cmd);
    install_element (CONFIG_NODE, &no_debug_bgp_all_cmd);
    install_element (CONFIG_NODE, &undebug_bgp_all_cmd);
}


////////////////////////////////////////////////
////////////////////////////////////////////////
/////////////////////bgp_dump.c/////////////////
////////////////////////////////////////////////

/* Some define for BGP packet dump. */
FILE *
Bgp::bgp_dump_open_file (struct bgp_dump *bgp_dump)
{
    int ret;
    time_t clock; 
      
    char fullpath[MAXPATHLEN];
    char realpath[MAXPATHLEN];

    double simulation_time;
    simulation_time = Scheduler::instance().clock();

    clock = (int)simulation_time + start_time;

    if (bgp_dump->filename[0] != DIRECTORY_SEP)
    {
        sprintf (fullpath, "%s/%s", getcwd (NULL, MAXPATHLEN), bgp_dump->filename);
        ret = strftime (realpath, MAXPATHLEN, fullpath, localtime(&clock));

    } else
        ret = strftime (realpath, MAXPATHLEN, bgp_dump->filename,localtime(&clock));

    if (ret == 0)
    {
        zlog_warn ("bgp_dump_open_file: strftime error\n");
        return NULL;
    }

    if (bgp_dump->fp)
        fclose (bgp_dump->fp);


    bgp_dump->fp = fopen (realpath, "w");

    if (bgp_dump->fp == NULL)
        return NULL;

    return bgp_dump->fp;
}

int
Bgp::bgp_dump_interval_add (struct bgp_dump *bgp_dump, int interval)
{

  bgp_dump->t_interval = thread_add_timer (master, &Bgp::bgp_dump_interval_func, 
                                             bgp_dump, interval);
  return 0;
}

/* Dump common header. */
void
Bgp::bgp_dump_header (struct stream *obuf, int type, int subtype)
{
    time_t now;
    double simulation_time;
    simulation_time = Scheduler::instance().clock();


    /* Set header. */
    now = start_time + (int)simulation_time;

    /* Put dump packet header. */
    stream_putl (obuf, now); 
    stream_putw (obuf, type);
    stream_putw (obuf, subtype);

    stream_putl (obuf, 0);   /* len */
}

void
Bgp::bgp_dump_set_size (struct stream *s, int type)
{
    stream_putl_at (s, 8, stream_get_putp (s) - BGP_DUMP_HEADER_SIZE);
}

void
Bgp::bgp_dump_routes_entry (struct prefix *p, struct bgp_info *info, int afi,
                            int type, unsigned int seq)
{
    struct stream *obuf;
    struct attr *attr;
    struct peer *peer;
    int plen;
    int safi = 0;

    /* Make dump stream. */
    obuf = bgp_dump_obuf;
    stream_reset (obuf);

    attr = info->attr;
    peer = info->peer;

    /* We support MRT's old format. */
    if (type == MSG_TABLE_DUMP)
    {
        bgp_dump_header (obuf, MSG_TABLE_DUMP, afi);
        stream_putw (obuf, 0);   /* View # */
        stream_putw (obuf, seq); /* Sequence number. */
    } else
    {
        bgp_dump_header (obuf, MSG_PROTOCOL_BGP4MP, BGP4MP_ENTRY);

        stream_putl (obuf, info->uptime); /* Time Last Change */
        stream_putw (obuf, afi); /* Address Family */
        stream_putc (obuf, safi);    /* SAFI */
    }

    if (afi == AFI_IP)
    {
        if (type == MSG_TABLE_DUMP)
        {
            /* Prefix */
            stream_put_in_addr (obuf, &p->u.prefix4);
            stream_putc (obuf, p->prefixlen);

            /* Status */
            stream_putc (obuf, 1);

            /* Originated */
            stream_putl (obuf, info->uptime);

            /* Peer's IP address */
            stream_put_in_addr (obuf, &peer->su.sin.sin_addr);

            /* Peer's AS number. */
            stream_putw (obuf, peer->as);

            /* Dump attribute. */
            bgp_dump_routes_attr (obuf, attr);
        } else
        {
            /* Next-Hop-Len */
            stream_putc (obuf, IPV4_MAX_BYTELEN);
            stream_put_in_addr (obuf, &attr->nexthop);
            stream_putc (obuf, p->prefixlen);
            plen = PSIZE (p->prefixlen);
            stream_put (obuf, &p->u.prefix4, plen);
            bgp_dump_routes_attr (obuf, attr);
        }
    }

    /* Set length. */
    bgp_dump_set_size (obuf, type);

    fwrite (STREAM_DATA (obuf), stream_get_putp (obuf), 1, bgp_dump_routes.fp);
    fflush (bgp_dump_routes.fp);
}

/* Runs under child process. */
void
Bgp::bgp_dump_routes_func (int afi)
{
    struct stream *obuf;
    struct bgp_node *rn;
    struct bgp_info *info;
    struct bgp *bgp;
    struct bgp_table *table;
    unsigned int seq = 0;

    obuf = bgp_dump_obuf;

    bgp = bgp_get_default ();
    if (!bgp)
        return;

    if (bgp_dump_routes.fp == NULL)
        return;

    /* Walk down each BGP route. */
    table = bgp->rib[afi][SAFI_UNICAST];
 
    for (rn = route_top (table); rn; rn = route_next (rn))
        for (info = ( bgp_info * ) rn->info; info; info = ( bgp_info *)  info->next)
            bgp_dump_routes_entry (&rn->p, info, afi, MSG_TABLE_DUMP, seq++);
}

int
Bgp::bgp_dump_interval_func (struct thread *t)
{
    struct bgp_dump *bgp_dump;

    bgp_dump = ( struct bgp_dump * ) THREAD_ARG (t);
    bgp_dump->t_interval = NULL;

    if (bgp_dump_open_file (bgp_dump) == NULL)
        return 0;

    /* In case of bgp_dump_routes, we need special route dump function. */
    if (bgp_dump->type == BGP_DUMP_ROUTES)
    {
        bgp_dump_routes_func (AFI_IP);
	//    bgp_dump_routes_func (AFI_IP6);
    }

    bgp_dump_interval_add (bgp_dump, bgp_dump->interval);

    return 0;
}

/* Dump common information. */
void
Bgp::bgp_dump_common (struct stream *obuf, struct peer *peer)
{
    char empty[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};

    /* Source AS number and Destination AS number. */
    stream_putw (obuf, peer->as);
    stream_putw (obuf, peer->local_as);

    if (peer->afc[AFI_IP][SAFI_UNICAST])
    {
        stream_putw (obuf, AFI_IP);

        stream_put (obuf, &peer->su.sin.sin_addr, IPV4_MAX_BYTELEN);

        if (peer->su_local)
            stream_put (obuf, &peer->su_local->sin.sin_addr, IPV4_MAX_BYTELEN);
        else
            stream_put (obuf, empty, IPV4_MAX_BYTELEN);
    }

}

/* Dump BGP status change. */
void
Bgp::bgp_dump_state (struct peer *peer, int status_old, int status_new)
{
    struct stream *obuf;

    /* If dump file pointer is disabled return immediately. */
    if (bgp_dump_all.fp == NULL)
        return;

    /* Make dump stream. */
    obuf = bgp_dump_obuf;
    stream_reset (obuf);

    bgp_dump_header (obuf, MSG_PROTOCOL_BGP4MP, BGP4MP_STATE_CHANGE);
    bgp_dump_common (obuf, peer);

    stream_putw (obuf, status_old);
    stream_putw (obuf, status_new);

    /* Set length. */
    bgp_dump_set_size (obuf, MSG_PROTOCOL_BGP4MP);

    /* Write to the stream. */
    fwrite (STREAM_DATA (obuf), stream_get_putp (obuf), 1, bgp_dump_all.fp);
    fflush (bgp_dump_all.fp);
}

void
Bgp::bgp_dump_packet_func (struct bgp_dump *bgp_dump, struct peer *peer,
                           struct stream *packet)
{
    struct stream *obuf;

    /* If dump file pointer is disabled return immediately. */
    if (bgp_dump->fp == NULL)
        return;

    /* Make dump stream. */
    obuf = bgp_dump_obuf;
    stream_reset (obuf);

    /* Dump header and common part. */
    bgp_dump_header (obuf, MSG_PROTOCOL_BGP4MP, BGP4MP_MESSAGE);
    bgp_dump_common (obuf, peer);

    /* Packet contents. */
    stream_put (obuf, STREAM_DATA (packet), stream_get_endp (packet));

    /* Set length. */
    bgp_dump_set_size (obuf, MSG_PROTOCOL_BGP4MP);

    /* Write to the stream. */
    fwrite (STREAM_DATA (obuf), stream_get_putp (obuf), 1, bgp_dump->fp);
    fflush (bgp_dump->fp);
}

/* Called from bgp_packet.c when BGP packet is received. */
void
Bgp::bgp_dump_packet (struct peer *peer, int type, struct stream *packet)
{
    /* bgp_dump_all. */
    bgp_dump_packet_func (&bgp_dump_all, peer, packet);

    /* bgp_dump_updates. */
    if (type == BGP_MSG_UPDATE)
        bgp_dump_packet_func (&bgp_dump_updates, peer, packet);
}

unsigned int
Bgp::bgp_dump_parse_time (char *str)
{
    int i;
    int len;
    int seen_h;
    int seen_m;
    int time;
    unsigned int total;

    time = 0;
    total = 0;
    seen_h = 0;
    seen_m = 0;
    len = strlen (str);

    for (i = 0; i < len; i++)
    {
        if (isdigit ((int) str[i]))
        {
            time *= 10;
            time += str[i] - '0';
        } else if (str[i] == 'H' || str[i] == 'h')
        {
            if (seen_h)
                return 0;
            if (seen_m)
                return 0;
            total += time * 60 *60;
            time = 0;
            seen_h = 1;
        } else if (str[i] == 'M' || str[i] == 'm')
        {
            if (seen_m)
                return 0;
            total += time * 60;
            time = 0;
            seen_h = 1;
        } else
            return 0;
    }
    return total + time;
}

int
Bgp::bgp_dump_set (struct vty *vty, struct bgp_dump *bgp_dump, int type,
                   char *path, char *interval_str)
{
    if (interval_str)
    {
        unsigned int interval;

        /* Check interval string. */
        interval = bgp_dump_parse_time (interval_str);
        if (interval == 0)
        {
            vty_out (zlog_default,LOG_DEBUG, "Malformed interval string%s", VTY_NEWLINE);
            return CMD_WARNING;
        }
        /* Set interval. */
        bgp_dump->interval = interval;
        if (bgp_dump->interval_str)
            free (bgp_dump->interval_str);
        bgp_dump->interval_str = strdup (interval_str);

        /* Create interval thread. */
        bgp_dump_interval_add (bgp_dump, interval);
    }

    /* Set type. */
    bgp_dump->type = ( bgp_dump_type ) type;

    /* Set file name. */
    if (bgp_dump->filename)
        free (bgp_dump->filename);
    bgp_dump->filename = strdup (path);

    /* This should be called when interval is expired. */
    bgp_dump_open_file (bgp_dump);

    return CMD_SUCCESS;
}

int
Bgp::bgp_dump_unset (struct vty *vty, struct bgp_dump *bgp_dump)
{
    /* Set file name. */
    if (bgp_dump->filename)
    {
        free (bgp_dump->filename);
        bgp_dump->filename = NULL;
    }

    /* This should be called when interval is expired. */
    if (bgp_dump->fp)
    {
        fclose (bgp_dump->fp);
        bgp_dump->fp = NULL;
    }

    /* Create interval thread. */
    if (bgp_dump->t_interval)
    {
        thread_cancel (bgp_dump->t_interval);
        bgp_dump->t_interval = NULL;
    }

    bgp_dump->interval = 0;

    if (bgp_dump->interval_str)
    {
        free (bgp_dump->interval_str);
        bgp_dump->interval_str = NULL;
    }


    return CMD_SUCCESS;
}

DEFUN (dump_bgp_all,
       dump_bgp_all_cmd,
       "dump bgp all PATH",
       "Dump packet\n"
       "BGP packet dump\n"
       "Dump all BGP packets\n"
       "Output filename\n")
{
    return bgp_dump_set (vty, &bgp_dump_all, BGP_DUMP_ALL, argv[0], NULL);
}

DEFUN (dump_bgp_all_interval,
       dump_bgp_all_interval_cmd,
       "dump bgp all PATH INTERVAL",
       "Dump packet\n"
       "BGP packet dump\n"
       "Dump all BGP packets\n"
       "Output filename\n"
       "Interval of output\n")
{
    return bgp_dump_set (vty, &bgp_dump_all, BGP_DUMP_ALL, argv[0], argv[1]);
}

DEFUN (no_dump_bgp_all,
       no_dump_bgp_all_cmd,
       "no dump bgp all [PATH] [INTERVAL]",
       NO_STR
       "Dump packet\n"
       "BGP packet dump\n"
       "Dump all BGP packets\n")
{
    return bgp_dump_unset (vty, &bgp_dump_all);
}

DEFUN (dump_bgp_updates,
       dump_bgp_updates_cmd,
       "dump bgp updates PATH",
       "Dump packet\n"
       "BGP packet dump\n"
       "Dump BGP updates only\n"
       "Output filename\n")
{
    return bgp_dump_set (vty, &bgp_dump_updates, BGP_DUMP_UPDATES, argv[0], NULL);
}

DEFUN (dump_bgp_updates_interval,
       dump_bgp_updates_interval_cmd,
       "dump bgp updates PATH INTERVAL",
       "Dump packet\n"
       "BGP packet dump\n"
       "Dump BGP updates only\n"
       "Output filename\n"
       "Interval of output\n")
{
    return bgp_dump_set (vty, &bgp_dump_updates, BGP_DUMP_UPDATES, argv[0], argv[1]);
}

DEFUN (no_dump_bgp_updates,
       no_dump_bgp_updates_cmd,
       "no dump bgp updates [PATH] [INTERVAL]",
       NO_STR
       "Dump packet\n"
       "BGP packet dump\n"
       "Dump BGP updates only\n")
{
    return bgp_dump_unset (vty, &bgp_dump_updates);
}

DEFUN (dump_bgp_routes_interval,
       dump_bgp_routes_interval_cmd,
       "dump bgp routes-mrt PATH INTERVAL",
       "Dump packet\n"
       "BGP packet dump\n"
       "Dump whole BGP routing table\n"
       "Output filename\n"
       "Interval of output\n")
{
    return bgp_dump_set (vty, &bgp_dump_routes, BGP_DUMP_ROUTES, argv[0], argv[1]);
}

DEFUN (no_dump_bgp_routes,
       no_dump_bgp_routes_cmd,
       "no dump bgp routes-mrt [PATH] [INTERVAL]",
       NO_STR
       "Dump packet\n"
       "BGP packet dump\n"
       "Dump whole BGP routing table\n")
{
    return bgp_dump_unset (vty, &bgp_dump_routes);
}

/* Initialize BGP packet dump functionality. */
void
Bgp::bgp_dump_init ()
{
    memset (&bgp_dump_all, 0, sizeof (struct bgp_dump));
    memset (&bgp_dump_updates, 0, sizeof (struct bgp_dump));
    memset (&bgp_dump_routes, 0, sizeof (struct bgp_dump));

    bgp_dump_obuf = stream_new (BGP_MAX_PACKET_SIZE + BGP_DUMP_HEADER_SIZE);

    if(cmdvec_init) install_element (CONFIG_NODE, &dump_bgp_all_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &dump_bgp_all_interval_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &no_dump_bgp_all_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &dump_bgp_updates_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &dump_bgp_updates_interval_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &no_dump_bgp_updates_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &dump_bgp_routes_interval_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &no_dump_bgp_routes_cmd);
}



////////////////////////////////////////////////
////////////////////////////////////////////////
/////////////////bgp_ecommunity.c///////////////
////////////////////////////////////////////////


struct ecommunity *
Bgp::ecommunity_new ()
{
    struct ecommunity *New;

    New = (ecommunity * ) XMALLOC (MTYPE_ECOMMUNITY, sizeof (struct ecommunity));
    memset (New, 0, sizeof (struct ecommunity));
    return New;
}

void
Bgp::ecommunity_free (struct ecommunity *ecom)
{
    if (ecom->val)
        XFREE (MTYPE_ECOMMUNITY_VAL, ecom->val);
    XFREE (MTYPE_ECOMMUNITY, ecom);
}

struct ecommunity *
Bgp::ecommunity_parse (char *pnt, u_short length)
{
    struct ecommunity tmp;
    struct ecommunity *find;
    struct ecommunity *New;

    if (length % 8)
        return NULL;

    tmp.size = length / 8;
    tmp.val = ( u_char * )  pnt;

    find = (struct ecommunity *) hash_search (ecomhash, &tmp);
    if (find)
    {
        find->refcnt++;
        return find;
    }

    New = ecommunity_new ();

    New->refcnt = 1;
    New->size = length / 8;
    New->val = ( u_char * ) XMALLOC (MTYPE_ECOMMUNITY_VAL, length);
    memcpy (New->val, pnt, length);

    hash_push (ecomhash, New);

    return New;
}

struct ecommunity *
Bgp::ecommunity_dup (struct ecommunity *ecom)
{
    struct ecommunity *New;

    New = ( ecommunity * ) XMALLOC (MTYPE_ECOMMUNITY, sizeof (struct ecommunity));
    memset (New, 0, sizeof (struct ecommunity));
    New->size = ecom->size;
    if (New->size)
    {
        New->val = ( u_char * ) XMALLOC (MTYPE_ECOMMUNITY_VAL, ecom->size * 8);
        memcpy (New->val, ecom->val, ecom->size * 8);
    } else
        New->val = NULL;
    return New;
}

struct ecommunity *
Bgp::ecommunity_merge (struct ecommunity *ecom1, struct ecommunity *ecom2)
{
    if (ecom1->val)
        ecom1->val = ( u_char * ) XREALLOC (MTYPE_ECOMMUNITY_VAL, ecom1->val, 
                                            (ecom1->size + ecom2->size) * 8);
    else
        ecom1->val = ( u_char * ) XMALLOC (MTYPE_ECOMMUNITY_VAL,
                                           (ecom1->size + ecom2->size) * 8);

    memcpy (ecom1->val + (ecom1->size * 8), ecom2->val, ecom2->size * 8);
    ecom1->size += ecom2->size;

    return ecom1;
}

struct ecommunity *
Bgp::ecommunity_intern (struct ecommunity *ecom)
{
    struct ecommunity *find;

    assert (ecom->refcnt == 0);

    find = (struct ecommunity *) hash_search (ecomhash, ecom);
    if (find)
    {
        ecommunity_free (ecom);
        find->refcnt++;
        return find;
    }

    ecom->refcnt = 1;
    hash_push (ecomhash, ecom);
    return ecom;
}

void
Bgp::ecommunity_unintern (struct ecommunity *ecom)
{
    if (ecom->refcnt)
        ecom->refcnt--;

    if (ecom->refcnt == 0)
    {
        struct ecommunity *ret;

        ret = (struct ecommunity *) hash_pull (ecomhash, ecom);
        assert (ret != NULL);

        ecommunity_free (ecom);
    }
}

unsigned int
Bgp::ecommunity_hash_make (struct ecommunity *ecom)
{
    int c;
    unsigned int key;
    unsigned char *pnt;

    key = 0;
    pnt = (unsigned char *)ecom->val;

    for (c = 0; c < ecom->size * 8; c++)
        key += pnt[c];

    return key %= HASHTABSIZE;
}

int
Bgp::ecommunity_cmp (struct ecommunity *ecom1, struct ecommunity *ecom2)
{
    if (ecom1->size == ecom2->size)
        if (memcmp (ecom1->val, ecom2->val, ecom1->size * 8) == 0)
            return 1;
    return 0;
}

/* Initialize Extended Comminities related hash. */
void
Bgp::ecommunity_init ()
{
    ecomhash = hash_new (HASHTABSIZE);
    ecomhash->hash_key = (unsigned int (*)(void * )  ) &Bgp::ecommunity_hash_make;
    ecomhash->hash_cmp = ( int (*) ( void * , void * ) ) &Bgp::ecommunity_cmp;
}


/* Get next Extended Communities token from the string. */
u_char *
Bgp::ecommunity_gettoken (char *buf, enum ecommunity_token *token,
                          struct ecommunity_as *eas, struct ecommunity_ip *eip)
{
    int dot = 0;
    int separator = 0;
    u_int32_t community_low = 0;
    u_int32_t community_high = 0;
    char *p = buf;
    struct in_addr ip;
    char ipstr[INET_ADDRSTRLEN + 1];
    int ret;

    /* Skip white space. */
    while (isspace ((int) *p))
        p++;

    /* Check the end of the line. */
    if (*p == '\0')
        return NULL;

    /* Community value. */
    if (isdigit ((int) *p))
    {
        while (isdigit ((int) *p) || *p == ':' || *p == '.')
        {
            if (*p == ':')
            {
                if (separator)
                {
                    *token = ecommunity_token_unknown;
                    return((u_char *) p);
                } else
                {
                    separator = 1;

                    if (dot)
                    {
                        if ((p - buf) > INET_ADDRSTRLEN)
                        {
                            *token = ecommunity_token_unknown;
                            return((u_char * ) p) ; 
                        }
                        memset (ipstr, 0, INET_ADDRSTRLEN + 1);
                        memcpy (ipstr, buf, p - buf);
                        ret = inet_aton (ipstr, &ip);
                        if (ret == 0)
                        {
                            *token = ecommunity_token_unknown;
                            return(u_char * ) p;
                        }
                    } else
                        community_high = community_low;

                    community_low = 0;
                }
            } else if (*p == '.')
            {
                if (separator)
                {
                    *token = ecommunity_token_unknown;
                    return((u_char * ) p) ;
                }

                dot++;

                if (dot > 4)
                {
                    *token = ecommunity_token_unknown;
                    return(( u_char * ) p ) ;
                }
            } else
            {
                community_low *= 10;
                community_low += (*p - '0');
            }
            p++;
        }

        if (dot)
        {
            eip->ip = ip;
            eip->val = community_low;
            *token = ecommunity_token_ip;
        } else
        {
            eas->as = community_high;
            eas->val = community_low;
            *token = ecommunity_token_as;
        }
        return(( u_char * ) p) ;
    }

    *token = ecommunity_token_unknown;
    return(( u_char * ) p ) ;
}

void
Bgp::ecommunity_add_val (struct ecommunity *ecom, int type, 
                         enum ecommunity_token token, 
                         struct ecommunity_as *eas, struct ecommunity_ip *eip)
{
    u_char *pnt;

    ecom->size++;

    if (ecom->val)
        ecom->val = ( u_char * ) XREALLOC (MTYPE_ECOMMUNITY_VAL, ecom->val, ecom_length (ecom));
    else
        ecom->val = ( u_char * ) XMALLOC (MTYPE_ECOMMUNITY_VAL, ecom_length (ecom));

    pnt = ecom->val + ((ecom->size - 1) * 8);

    if (token == ecommunity_token_as)
        *pnt = ECOMMUNITY_ENCODE_AS;
    else if (token == ecommunity_token_ip)
        *pnt = ECOMMUNITY_ENCODE_IP;
    pnt++;

    if (type == ECOMMUNITY_ROUTE_TARGET)
        *pnt = ECOMMUNITY_ROUTE_TARGET;
    else if (type == ECOMMUNITY_SITE_ORIGIN)
        *pnt = ECOMMUNITY_SITE_ORIGIN;
    pnt++;

    if (token == ecommunity_token_as)
    {
        *pnt++ = (u_char) (eas->as >> 8);
        *pnt++ = (u_char) (eas->as);
        *pnt++ = (u_char) (eas->val >> 24);
        *pnt++ = (u_char) (eas->val >> 16);
        *pnt++ = (u_char) (eas->val >> 8);
        *pnt++ = (u_char) (eas->val);
    } else if (token == ecommunity_token_ip)
    {
        memcpy (pnt, &eip->ip, 4);
        pnt += 4;
        *pnt++ = (u_char) (eip->val >> 8);
        *pnt++ = (u_char) (eip->val);
    }
}

struct ecommunity *
Bgp::ecommunity_str2com (int type, char *str)
{
    struct ecommunity *ecom = NULL;
    struct ecommunity_as eas;
    struct ecommunity_ip eip;
    enum ecommunity_token token;

    while ((str = (char * ) ecommunity_gettoken (str, &token, &eas, &eip)))
    {
        switch (token)
        {
        case ecommunity_token_as:
        case ecommunity_token_ip:
            if (ecom == NULL)
                ecom = ecommunity_new ();
            ecommunity_add_val (ecom, type, token, &eas, &eip);
            break;
        case ecommunity_token_unknown:
        default:
            if (ecom)
                ecommunity_free (ecom);
            return NULL;
            break;
        }
    }
    return ecom;
}

void
Bgp::ecommunity_print (struct ecommunity *ecom)
{
    int i;
    u_char *pnt;
    struct ecommunity_as eas;
    struct ecommunity_ip eip;
    int encode = 0;
    int type = 0;

    for (i = 0; i < ecom->size; i++)
    {
        pnt = ecom->val + (i * 8);

        /* High-order octet of type. */
        if (*pnt == ECOMMUNITY_ENCODE_AS)
            encode = ECOMMUNITY_ENCODE_AS;
        else if (*pnt == ECOMMUNITY_ENCODE_IP)
            encode = ECOMMUNITY_ENCODE_IP;
        pnt++;

        /* Low-order octet of type. */
        if (*pnt == ECOMMUNITY_ROUTE_TARGET)
        {
            if (type != ECOMMUNITY_ROUTE_TARGET)
                printf (" RT:");
            type = ECOMMUNITY_ROUTE_TARGET;
        } else if (*pnt == ECOMMUNITY_SITE_ORIGIN)
        {
            if (type != ECOMMUNITY_SITE_ORIGIN)
                printf (" SOO:");
            type = ECOMMUNITY_SITE_ORIGIN;
        }
        pnt++;

        if (encode == ECOMMUNITY_ENCODE_AS)
        {
            eas.as = (*pnt++ << 8);
            eas.as |= (*pnt++);

            eas.val = (*pnt++ << 24);
            eas.val |= (*pnt++ << 16);
            eas.val |= (*pnt++ << 8);
            eas.val |= (*pnt++);

            printf ("%d:%d", eas.as, eas.val);
        } else if (encode == ECOMMUNITY_ENCODE_IP)
        {
            memcpy (&eip.ip, pnt, 4);
            pnt += 4;
            eip.val = (*pnt++ << 8);
            eip.val |= (*pnt++);

            printf ("%s:%d", inet_ntoa (eip.ip), eip.val);
        }
    }

    printf ("\n");
}

void
Bgp::ecommunity_vty_out (struct ecommunity *ecom)
{
    int i;
    u_char *pnt;
    struct ecommunity_as eas;
    struct ecommunity_ip eip;
    int encode = 0;
    int type = 0;

    for (i = 0; i < ecom->size; i++)
    {
        pnt = ecom->val + (i * 8);

        /* High-order octet of type. */
        if (*pnt == ECOMMUNITY_ENCODE_AS)
            encode = ECOMMUNITY_ENCODE_AS;
        else if (*pnt == ECOMMUNITY_ENCODE_IP)
            encode = ECOMMUNITY_ENCODE_IP;
        pnt++;

        /* Low-order octet of type. */
        if (*pnt == ECOMMUNITY_ROUTE_TARGET)
        {
            if (type != ECOMMUNITY_ROUTE_TARGET)
                vty_out (zlog_default,LOG_DEBUG, " RT:");
            type = ECOMMUNITY_ROUTE_TARGET;
        } else if (*pnt == ECOMMUNITY_SITE_ORIGIN)
        {
            if (type != ECOMMUNITY_SITE_ORIGIN)
                vty_out (zlog_default,LOG_DEBUG, " SOO:");
            type = ECOMMUNITY_SITE_ORIGIN;
        }
        pnt++;

        if (encode == ECOMMUNITY_ENCODE_AS)
        {
            eas.as = (*pnt++ << 8);
            eas.as |= (*pnt++);

            eas.val = (*pnt++ << 24);
            eas.val |= (*pnt++ << 16);
            eas.val |= (*pnt++ << 8);
            eas.val |= (*pnt++);

            vty_out (zlog_default,LOG_DEBUG, "%d:%d", eas.as, eas.val);
        } else if (encode == ECOMMUNITY_ENCODE_IP)
        {
            memcpy (&eip.ip, pnt, 4);
            pnt += 4;
            eip.val = (*pnt++ << 8);
            eip.val |= (*pnt++);

            vty_out (zlog_default,LOG_DEBUG, "%s:%d", inet_ntoa (eip.ip), eip.val);
        }
    }
}

#ifdef TEST
void
ecommunity_test ()
{
    struct ecommunity *com1;
    struct ecommunity *com2;

    com1 = ecommunity_str2com (ECOMMUNITY_ROUTE_TARGET, "65535:1");
    com2 = ecommunity_str2com (ECOMMUNITY_SITE_ORIGIN, "1.1.1.1:1");

    ecommunity_print (com1);
    ecommunity_print (com2);

    /*
    if (com2 == NULL)
      printf ("errror\n");
    else
      ecommunity_print (com2);
    */

    /* printf ("%s\n", ecommunity_print (com1)); */
    {
        int i;

        u_char *pnt = com2->val;

        for (i = 0; i < 8; i ++)
        {
            printf ("[%d] %d\n", i, pnt[i]);
        }
    }
}
#endif /* TEST */


////////////////////////////////////////////////
////////////////////////////////////////////////
/////////////////////bgp_filter.c///////////////
////////////////////////////////////////////////


/* Allocate New AS filter. */
struct as_filter *
Bgp::as_filter_new ()
{
    struct as_filter *New;

    New = ( as_filter * ) XMALLOC (MTYPE_AS_FILTER, sizeof (struct as_filter));
    memset (New, 0, sizeof (struct as_filter));
    return New;
}

/* Free allocated AS filter. */
void
Bgp::as_filter_free (struct as_filter *asfilter)
{
    if (asfilter->reg)
        bgp_regex_free (asfilter->reg);
    if (asfilter->reg_str)
        XFREE (MTYPE_AS_FILTER_STR, asfilter->reg_str);
    XFREE (MTYPE_AS_FILTER, asfilter);
}

/* Make New AS filter. */
struct as_filter *
Bgp::as_filter_make (regex_t *reg, char *reg_str, enum as_filter_type type)
{
    struct as_filter *asfilter;

    asfilter = as_filter_new ();
    asfilter->reg = reg;
    asfilter->type = type;
    asfilter->reg_str = XSTRDUP (MTYPE_AS_FILTER_STR, reg_str);

    return asfilter;
}

struct as_filter *
Bgp::as_filter_lookup (struct as_list *aslist, char *reg_str,
                       enum as_filter_type type)
{
    struct as_filter *asfilter;

    for (asfilter = aslist->head; asfilter; asfilter = asfilter->next)
        if (strcmp (reg_str, asfilter->reg_str) == 0)
            return asfilter;
    return NULL;
}

void
Bgp::as_list_filter_add (struct as_list *aslist, struct as_filter *asfilter)
{
    asfilter->next = NULL;
    asfilter->prev = aslist->tail;

    if (aslist->tail)
        aslist->tail->next = asfilter;
    else
        aslist->head = asfilter;
    aslist->tail = asfilter;
}

/* Lookup as_list from list of as_list by name. */
struct as_list *
Bgp::as_list_lookup (char *name)
{
    struct as_list *aslist;

    if (name == NULL)
        return NULL;

    for (aslist = as_list_master.num.head; aslist; aslist = aslist->next)
        if (strcmp (aslist->name, name) == 0)
            return aslist;

    for (aslist = as_list_master.str.head; aslist; aslist = aslist->next)
        if (strcmp (aslist->name, name) == 0)
            return aslist;

    return NULL;
}

struct as_list *
Bgp::as_list_new ()
{
    struct as_list *New;

    New = ( struct as_list * ) XMALLOC (MTYPE_AS_LIST, sizeof (struct as_list));
    memset (New, 0, sizeof (struct as_list));
    return New;
}

void
Bgp::as_list_free (struct as_list *aslist)
{
    XFREE (MTYPE_AS_LIST, aslist);
}

/* Insert New AS list to list of as_list.  Each as_list is sorted by
   the name. */
struct as_list *
Bgp::as_list_insert (char *name)
{
    int i;
    long number;
    struct as_list *aslist;
    struct as_list *point;
    struct as_list_list *list;

    /* Allocate New access_list and copy given name. */
    aslist = as_list_new ();
    aslist->name = strdup (name);

    /* If name is made by all digit character.  We treat it as
       number. */
    for (number = 0, i = 0; i < strlen (name); i++)
    {
        if (isdigit ((int) name[i]))
            number = (number * 10) + (name[i] - '0');
        else
            break;
    }

    /* In case of name is all digit character */
    if (i == strlen (name))
    {
        aslist->type = ACCESS_TYPE_NUMBER;

        /* Set access_list to number list. */
        list = &as_list_master.num;

        for (point = list->head; point; point = point->next)
            if (atol (point->name) >= number)
                break;
    } else
    {
        aslist->type = ACCESS_TYPE_STRING;

        /* Set access_list to string list. */
        list = &as_list_master.str;

        /* Set point to insertion point. */
        for (point = list->head; point; point = point->next)
            if (strcmp (point->name, name) >= 0)
                break;
    }

    /* In case of this is the first element of master. */
    if (list->head == NULL)
    {
        list->head = list->tail = aslist;
        return aslist;
    }

    /* In case of insertion is made at the tail of access_list. */
    if (point == NULL)
    {
        aslist->prev = list->tail;
        list->tail->next = aslist;
        list->tail = aslist;
        return aslist;
    }

    /* In case of insertion is made at the head of access_list. */
    if (point == list->head)
    {
        aslist->next = list->head;
        list->head->prev = aslist;
        list->head = aslist;
        return aslist;
    }

    /* Insertion is made at middle of the access_list. */
    aslist->next = point;
    aslist->prev = point->prev;

    if (point->prev)
        point->prev->next = aslist;
    point->prev = aslist;

    return aslist;
}

struct as_list *
Bgp::as_list_get (char *name)
{
    struct as_list *aslist;

    aslist = as_list_lookup (name);
    if (aslist == NULL)
    {
        aslist = as_list_insert (name);

        /* Run hook function. */
        if (as_list_master.add_hook)
            (this->*as_list_master.add_hook) ();
    }

    return aslist;
}

char *
Bgp::filter_type_str (enum as_filter_type type)
{
    switch (type)
    {
    case AS_FILTER_PERMIT:
        return "permit";
        break;
    case AS_FILTER_DENY:
        return "deny";
        break;
    default:
        return "";
        break;
    }
}

void
Bgp::as_list_print (struct as_list *aslist)
{
    struct as_filter *asfilter;

    for (asfilter = aslist->head; asfilter; asfilter = asfilter->next)
        printf ("regexp %s %s\n", asfilter->reg_str, 
                filter_type_str (asfilter->type));
}

void
Bgp::as_list_print_all ()
{
    struct as_list *aslist;

    for (aslist = as_list_master.num.head; aslist; aslist = aslist->next)
        as_list_print (aslist);
    for (aslist = as_list_master.str.head; aslist; aslist = aslist->next)
        as_list_print (aslist);
}

void
Bgp::as_list_delete (struct as_list *aslist)
{
    struct as_list_list *list;
    struct as_filter *filter, *next;

    for (filter = aslist->head; filter; filter = next)
    {
        next = filter->next;
        as_filter_free (filter);
    }

    if (aslist->type == ACCESS_TYPE_NUMBER)
        list = &as_list_master.num;
    else
        list = &as_list_master.str;

    if (aslist->next)
        aslist->next->prev = aslist->prev;
    else
        list->tail = aslist->prev;

    if (aslist->prev)
        aslist->prev->next = aslist->next;
    else
        list->head = aslist->next;

    as_list_free (aslist);
}

int
Bgp::as_list_empty (struct as_list *aslist)
{
    if (aslist->head == NULL && aslist->tail == NULL)
        return 1;
    else
        return 0;
}

void
Bgp::as_list_filter_delete (struct as_list *aslist, struct as_filter *asfilter)
{
    if (asfilter->next)
        asfilter->next->prev = asfilter->prev;
    else
        aslist->tail = asfilter->prev;

    if (asfilter->prev)
        asfilter->prev->next = asfilter->next;
    else
        aslist->head = asfilter->next;

    as_filter_free (asfilter);


    /* If access_list becomes empty delete it from access_master. */
    if (as_list_empty (aslist))
        as_list_delete (aslist);

    /* Run hook function. */
    if (as_list_master.delete_hook)
        (this->*as_list_master.delete_hook) ();
}

int
Bgp::as_filter_match (struct as_filter *asfilter, struct aspath *aspath)
{
    if (bgp_regexec (asfilter->reg, aspath) != REG_NOMATCH)
        return 1;
    return 0;
}

/* Apply AS path filter to AS. */
enum as_filter_type
Bgp::as_list_apply (struct as_list *aslist, void *object)
{
    struct as_filter *asfilter;
    struct aspath *aspath;

    aspath = (struct aspath *) object;

    if (aslist == NULL)
        return AS_FILTER_DENY;

    for (asfilter = aslist->head; asfilter; asfilter = asfilter->next)
    {
        if (as_filter_match (asfilter, aspath))
            return asfilter->type;
    }
    return AS_FILTER_DENY;
}

/* Add hook function. */
void
Bgp::as_list_add_hook (void (Bgp::*func) ())
{
    as_list_master.add_hook = func;
}

/* Delete hook function. */
void
Bgp::as_list_delete_hook (void (Bgp::*func) ())
{
    as_list_master.delete_hook = func;
}

int
Bgp::as_list_dup_check (struct as_list *aslist, struct as_filter *New)
{
    struct as_filter *asfilter;

    for (asfilter = aslist->head; asfilter; asfilter = asfilter->next)
    {
        if (asfilter->type == New->type
            && strcmp (asfilter->reg_str, New->reg_str) == 0)
            return 1;
    }
    return 0;
}

DEFUN (ip_as_path, 
       ip_as_path_cmd,
       "ip as-path access-list WORD (deny|permit) .LINE",
       IP_STR
       "BGP autonomous system path filter\n"
       "Specify an access list name\n"
       "Regular expression access list name\n"
       "Specify packets to reject\n"
       "Specify packets to forward\n"
       "A regular-expression to match the BGP AS paths\n")
{
    enum as_filter_type type;
    struct as_filter *asfilter;
    struct as_list *aslist;
    regex_t *regex;
    struct buffer *b;
    int i;
    char *regstr;
    int first = 0;

    /* Check the filter type. */
    if (strncmp (argv[1], "p", 1) == 0)
        type = AS_FILTER_PERMIT;
    else if (strncmp (argv[1], "d", 1) == 0)
        type = AS_FILTER_DENY;
    else
    {
        vty_out (zlog_default,LOG_DEBUG, "filter type must be [permit|deny]%s", VTY_NEWLINE);
        return CMD_WARNING;
    }

    /* Check AS path regex. */
    b = buffer_new (1024);
    for (i = 2; i < argc; i++)
    {
        if (first)
            buffer_putc (b, ' ');
        else
            first = 1;

        buffer_putstr ((buffer * ) b,(u_char * )  argv[i]);
    }
    buffer_putc (b, '\0');

    regstr = buffer_getstr (b);
    buffer_free (b);

    regex = bgp_regcomp (regstr);
    if (!regex)
    {
        free (regstr);
        vty_out (zlog_default,LOG_DEBUG, "can't compile regexp %s%s", argv[0],
                 VTY_NEWLINE);
        return CMD_WARNING;
    }

    asfilter = as_filter_make (regex, regstr, type);

    free (regstr);

    /* Install New filter to the access_list. */
    aslist = as_list_get (argv[0]);

    /* Duplicate insertion check. */

;
    if (as_list_dup_check (aslist, asfilter))
        as_filter_free (asfilter);
    else
        as_list_filter_add (aslist, asfilter);

    return CMD_SUCCESS;
}

DEFUN (no_ip_as_path,
       no_ip_as_path_cmd,
       "no ip as-path access-list WORD (deny|permit) .LINE",
       NO_STR
       IP_STR
       "BGP autonomous system path filter\n"
       "Specify an access list name\n"
       "Regular expression access list name\n"
       "Specify packets to reject\n"
       "Specify packets to forward\n"
       "A regular-expression to match the BGP AS paths\n")
{
    enum as_filter_type type;
    struct as_filter *asfilter;
    struct as_list *aslist;
    struct buffer *b;
    int i;
    int first = 0;
    char *regstr;
    regex_t *regex;

    /* Lookup AS list from AS path list. */
    aslist = as_list_lookup (argv[0]);
    if (aslist == NULL)
    {
        vty_out (zlog_default,LOG_DEBUG, "ip as-path access-list %s doesnt exist%s", argv[0],
                 VTY_NEWLINE);
        return CMD_WARNING;
    }

    /* Check the filter type. */
    if (strncmp (argv[1], "p", 1) == 0)
        type = AS_FILTER_PERMIT;
    else if (strncmp (argv[1], "d", 1) == 0)
        type = AS_FILTER_DENY;
    else
    {
        vty_out (zlog_default,LOG_DEBUG, "filter type must be [permit|deny]%s", VTY_NEWLINE);
        return CMD_WARNING;
    }

    /* Compile AS path. */
    b = buffer_new (1024);
    for (i = 2; i < argc; i++)
    {
        if (first)
            buffer_putc (b, ' ');
        else
            first = 1;

        buffer_putstr ((buffer * ) b,( u_char * )  argv[i]);
    }
    buffer_putc (b, '\0');

    regstr = buffer_getstr (b);
    buffer_free (b);

    regex = bgp_regcomp (regstr);
    if (!regex)
    {
        free (regstr);
        vty_out (zlog_default,LOG_DEBUG, "can't compile regexp %s%s", argv[0],
                 VTY_NEWLINE);
        return CMD_WARNING;
    }

    /* Lookup asfilter. */
    asfilter = as_filter_lookup (aslist, regstr, type);

    free (regstr);
    bgp_regex_free (regex);

    if (asfilter == NULL)
    {
        vty_out (zlog_default,LOG_DEBUG, "%s", VTY_NEWLINE);
        return CMD_WARNING;
    }

    as_list_filter_delete (aslist, asfilter);

    return CMD_SUCCESS;
}

DEFUN (no_ip_as_path_all,
       no_ip_as_path_all_cmd,
       "no ip as-path access-list WORD",
       NO_STR
       IP_STR
       "BGP autonomous system path filter\n"
       "Specify an access list name\n"
       "Regular expression access list name\n")
{
    struct as_list *aslist;

    aslist = as_list_lookup (argv[0]);
    if (aslist == NULL)
    {
        vty_out (zlog_default,LOG_DEBUG, "ip as-path access-list %s doesnt exist%s", argv[0],
                 VTY_NEWLINE);
        return CMD_WARNING;
    }

    as_list_delete (aslist);

    return CMD_SUCCESS;
}

/* Register functions. */
void
Bgp::bgp_filter_init ()
{
    install_element (CONFIG_NODE, &ip_as_path_cmd);
    install_element (CONFIG_NODE, &no_ip_as_path_cmd);
    install_element (CONFIG_NODE, &no_ip_as_path_all_cmd);
}

/* For test. */
void
Bgp::bgp_filter_test ()
{
    regex_t *regex;
    struct as_list *aslist;
    struct as_filter *asfilter;

    char buf[] = "1 2";

    regex = bgp_regcomp (buf);
    if (regex == NULL)
        fprintf (stderr, "aspath regex compile errror\n");

    /* ip as-path access-list 1 permit AS1. */
    aslist = as_list_get ("1");
    asfilter = as_filter_make (regex, buf, AS_FILTER_PERMIT);
    as_list_filter_add (aslist, asfilter);

    as_list_print_all ();
}



////////////////////////////////////////////////
////////////////////////////////////////////////
//////////////////bgp_fsm.c/////////////////////
////////////////////////////////////////////////

/* BGP FSM (finite state machine) has three types of functions.  Type
   one is thread functions.  Type two is event functions.  Type three
   is FSM functions.  Timer functions are set by bgp_timer_set
   function. */




/* BGP start timer jitter. */
double
Bgp::bgp_start_jitter (int time)
{
  return ((time + 1) - (time / 2))*((double)rand()/(double)RAND_MAX);
}

/* Hook function called after bgp event is occered.  And vty's
   neighbor command invoke this function after making neighbor
   structure. */
void
Bgp::bgp_timer_set (struct peer *peer)
{
    double jitter = 0;
    switch (peer->status)
    {
    case Idle:
        /* First entry point of peer's finite state machine.  In Idle
       status start timer is on unless peer is shutdown or peer is
       inactive.  All other timer must be turned off */
        if (CHECK_FLAG (peer->flags, PEER_FLAG_SHUTDOWN)
            || CHECK_FLAG (peer->sflags, PEER_STATUS_PREFIX_OVERFLOW)
            || ! peer_active (peer))
        {
            BGP_TIMER_OFF (peer->t_start);
        } else
        {
            jitter = bgp_start_jitter (peer->v_start);
            BGP_TIMER_ON ( peer->t_start, &Bgp::bgp_start_timer,
                           peer,peer->v_start + jitter);
        }
        BGP_TIMER_OFF (peer->t_connect);
        BGP_TIMER_OFF (peer->t_holdtime);
        BGP_TIMER_OFF (peer->t_keepalive);
        BGP_TIMER_OFF (peer->t_asorig);
        BGP_TIMER_OFF (peer->t_routeadv);
#ifndef HAVE_ZEBRA_93b
	bgp_mrai_timers_off(peer);
#endif	

        return;

    case Connect:
        /* After start timer is expired, the peer moves to Connnect
       status.  Make sure start timer is off and connect timer is
       on. */
        BGP_TIMER_OFF (peer->t_start);
        BGP_TIMER_ON (peer->t_connect, &Bgp::bgp_connect_timer,peer, peer->v_connect);
        BGP_TIMER_OFF (peer->t_holdtime);
        BGP_TIMER_OFF (peer->t_keepalive);
        BGP_TIMER_OFF (peer->t_asorig);
        BGP_TIMER_OFF (peer->t_routeadv);
#ifndef HAVE_ZEBRA_93b
	bgp_mrai_timers_off(peer);
#endif	

        return;

    case Active:
        /* Active is waiting connection from remote peer.  And if
       connect timer is expired, change status to Connect. */
        BGP_TIMER_OFF (peer->t_start);
        /* If peer is passive mode, do not set connect timer. */
        if (CHECK_FLAG (peer->flags, PEER_FLAG_PASSIVE))
        {
            BGP_TIMER_OFF (peer->t_connect);
        } else
        {

            BGP_TIMER_ON (peer->t_connect, &Bgp::bgp_connect_timer,
			  peer, peer->v_connect);
        }
        if (0) printf("%s: In bgp set timer case Active",name()); 

        BGP_TIMER_OFF (peer->t_holdtime);
        BGP_TIMER_OFF (peer->t_keepalive);
        BGP_TIMER_OFF (peer->t_asorig);
        BGP_TIMER_OFF (peer->t_routeadv);
#ifndef HAVE_ZEBRA_93b
	bgp_mrai_timers_off(peer);
#endif	
        return;

    case OpenSent:
        /* OpenSent status. */
        BGP_TIMER_OFF (peer->t_start);
        BGP_TIMER_OFF (peer->t_connect);
        if (peer->v_holdtime != 0)
        {
            BGP_TIMER_ON (peer->t_holdtime, &Bgp::bgp_holdtime_timer, 
                          peer,peer->v_holdtime);
        } else
        {
            BGP_TIMER_OFF (peer->t_holdtime);
        }
        BGP_TIMER_OFF (peer->t_keepalive);
        BGP_TIMER_OFF (peer->t_asorig);
        BGP_TIMER_OFF (peer->t_routeadv);
#ifndef HAVE_ZEBRA_93b
	bgp_mrai_timers_off(peer);
#endif	
        return;

    case OpenConfirm:
        /* OpenConfirm status. */
        BGP_TIMER_OFF (peer->t_start);
        BGP_TIMER_OFF (peer->t_connect);

        /* If the negotiated Hold Time value is zero, then the Hold Time
       timer and KeepAlive timers are not started. */
        if (peer->v_holdtime == 0)
        {
            BGP_TIMER_OFF (peer->t_holdtime);
            BGP_TIMER_OFF (peer->t_keepalive);
        } else
        {
            BGP_TIMER_ON (peer->t_holdtime, &Bgp::bgp_holdtime_timer,
                          peer, peer->v_holdtime);
            BGP_TIMER_ON (peer->t_keepalive, &Bgp::bgp_keepalive_timer, 
                          peer, peer->v_keepalive);
        }
        BGP_TIMER_OFF (peer->t_asorig);
        BGP_TIMER_OFF (peer->t_routeadv);
#ifndef HAVE_ZEBRA_93b
	bgp_mrai_timers_off(peer);
#endif	
        return;

    case Established:
        /* In Established status start and connect timer is turned
       off. */
        BGP_TIMER_OFF (peer->t_start);
        BGP_TIMER_OFF (peer->t_connect);

        /* Same as OpenConfirm, if holdtime is zero then both holdtime
       and keepalive must be turned off. */
        if (peer->v_holdtime == 0)
        {
            BGP_TIMER_OFF (peer->t_holdtime);
            BGP_TIMER_OFF (peer->t_keepalive);
        } else
        {
            BGP_TIMER_ON (peer->t_holdtime, &Bgp::bgp_holdtime_timer,
                          peer, peer->v_holdtime);
            BGP_TIMER_ON (peer->t_keepalive, &Bgp::bgp_keepalive_timer,
                          peer, peer->v_keepalive);
        }
        BGP_TIMER_OFF (peer->t_asorig);
        return;
    }
}

/* BGP start timer.  This function set BGP_Start event to thread value
   and process event. */
int
Bgp::bgp_start_timer (struct thread *thread)
{
    struct peer *peer;
    peer = ( struct peer* ) THREAD_ARG (thread);
    peer->t_start = NULL;

    if (BGP_DEBUG (fsm, FSM))
        zlog (peer->log, LOG_DEBUG,
              "%s [FSM] Timer (start timer expire).\n", peer->host);

    THREAD_VAL (thread) = BGP_Start;
    bgp_event (thread);

    return 0;
}

/* BGP connect retry timer. */
int
Bgp::bgp_connect_timer (struct thread *thread)
{
    struct peer *peer;

    peer = ( struct peer * ) THREAD_ARG (thread);
    peer->t_connect = NULL;

    if (BGP_DEBUG (fsm, FSM))
        zlog (peer->log, LOG_DEBUG, "%s [FSM] Timer (connect timer expire)\n",
              peer->host);

    THREAD_VAL (thread) = ConnectRetry_timer_expired;
    bgp_event (thread);

    return 0;
}

/* BGP holdtime timer. */
int
Bgp::bgp_holdtime_timer (struct thread *thread)
{
    struct peer *peer;

    peer = ( struct peer * ) THREAD_ARG (thread);
    peer->t_holdtime = NULL;

    if (BGP_DEBUG (fsm, FSM))
        zlog (peer->log, LOG_DEBUG,
              "%s [FSM] Timer (holdtime timer expire)\n",
              peer->host);

    THREAD_VAL (thread) = Hold_Timer_expired;
    bgp_event (thread);

    return 0;
}

/* BGP keepalive fire ! */
int
Bgp::bgp_keepalive_timer (struct thread *thread)
{
    struct peer *peer;

    peer = (struct  peer * )  THREAD_ARG (thread);
    peer->t_keepalive = NULL;

    if (BGP_DEBUG (fsm, FSM))
        zlog (peer->log, LOG_DEBUG,
              "%s [FSM] Timer (keepalive timer expire)\n",
              peer->host);

    THREAD_VAL (thread) = KeepAlive_timer_expired;
    bgp_event (thread);

    return 0;
}

/* Reset bgp update timer */
void
Bgp::bgp_uptime_reset (struct peer *peer)
{
  double simulation_time;
  simulation_time = Scheduler::instance().clock();
  time_t clock = (int)simulation_time + start_time;
  peer->uptime = clock;
}

/* Administrative BGP peer stop event. */
int
Bgp::bgp_stop (struct peer *peer)
{
    if (0) printf("\n%s: BGP STOP",name());
    /* Need of clear of peer. */
#ifndef HAVE_ZEBRA_93b
    bgp_route_clear (peer);
#else 
    if (peer->status == Established)
      bgp_clear_route_all (peer);
#endif


    bgp_uptime_reset (peer);

    /* Stop read thread when exists. */
    BGP_READ_OFF (peer->t_read);

    /* Stream reset. */
    peer->packet_size = 0;
    if (peer->ibuf)
        stream_reset (peer->ibuf);

    /* Stop all timers. */
    BGP_TIMER_OFF (peer->t_start);
    BGP_TIMER_OFF (peer->t_connect);
    BGP_TIMER_OFF (peer->t_holdtime);
    BGP_TIMER_OFF (peer->t_keepalive);
    BGP_TIMER_OFF (peer->t_asorig);
    BGP_TIMER_OFF (peer->t_routeadv);
    
#ifndef HAVE_ZEBRA_93b
	bgp_mrai_timers_off(peer);
#endif	
    /* Delete all existing events of the peer. */
    BGP_EVENT_DELETE (peer);                      

    /* Clear output buffer. */
    stream_fifo_free (peer->obuf);

    /* Close Tcp Connection. */
    if (peer->LocalAgent != NULL)
    {
      // Clear list of msg for this connection
      Agent2MsgListMap_t::iterator itr ;
      struct agent_index rindex = GetRemoteIndex(peer->LocalAgent);

      for(itr = m_msgs.begin();itr != m_msgs.end();++itr) 
	if(memcmp(&itr->first,&rindex,sizeof(struct agent_index))==0) { 
	  m_msgs.erase(itr);
	  break;
	}

      if(!(peer->LocalAgent->state() == TCPS_LAST_ACK || 
	   peer->LocalAgent->state() == TCPS_CLOSED   ||
	   peer->LocalAgent->state() == TCPS_CLOSE_WAIT)) 
	{ 
	  Tcl& tcl = Tcl::instance();
	  tcl.evalf("%s close", peer->LocalAgent->name());
	  
	  //peer->LocalAgent->usrclosed() Shouldn't be protected,
	  //so we would avoid doing the expensive tcl call.
	  
	}
    }

    peer->LocalAgent = NULL;

    /* Connection information. */
    if (peer->su_local)
    {
        XFREE (MTYPE_TMP, peer->su_local);
        peer->su_local = NULL;
    }

    if (peer->su_remote)
    {
        XFREE (MTYPE_TMP, peer->su_remote);
        peer->su_remote = NULL;
    }

    /* Clear remote router-id. */
    peer->remote_id.s_addr = 0;

    /* Reset all negotiated variables */
    peer->afc_nego[AFI_IP][SAFI_UNICAST] = 0;
    //peer->afc_nego[AFI_IP][SAFI_MULTICAST] = 0;
    //  peer->afc_nego[AFI_IP6][SAFI_UNICAST] = 0;
    //peer->afc_nego[AFI_IP6][SAFI_MULTICAST] = 0;
    peer->afc_adv[AFI_IP][SAFI_UNICAST] = 0;
    //    peer->afc_adv[AFI_IP][SAFI_MULTICAST] = 0;
    //peer->afc_adv[AFI_IP6][SAFI_UNICAST] = 0;
    //peer->afc_adv[AFI_IP6][SAFI_MULTICAST] = 0;
    peer->afc_recv[AFI_IP][SAFI_UNICAST] = 0;
    //    peer->afc_recv[AFI_IP][SAFI_MULTICAST] = 0;
    //peer->afc_recv[AFI_IP6][SAFI_UNICAST] = 0;
    //peer->afc_recv[AFI_IP6][SAFI_MULTICAST] = 0;

    /* Reset route refresh flag. */
    peer->refresh_adv = 0;
    peer->refresh_nego_old = 0;
    peer->refresh_nego_new = 0;

    /* Reset keepalive and holdtime */
    if (peer->config & PEER_CONFIG_TIMER)
    {
        peer->v_keepalive = peer->keepalive;
        peer->v_holdtime = peer->holdtime;
    } else
    {
        peer->v_keepalive = peer->global_keepalive;
        peer->v_holdtime = peer->global_holdtime;
    }

    /* Increment Dropped count. */
    if (peer->status == Established)
    {
        peer->dropped++;
        fsm_change_status (peer, Idle);
    }

    peer->update_time = 0;

    return 0;
}

/* BGP peer is stoped by the error. */
int
Bgp::bgp_stop_with_error (struct peer *peer)
{
    /* Double start timer. */
    peer->v_start *= 2;

    /* Overflow check. */
    if (peer->v_start >= (60 * 2))
        peer->v_start = (60 * 2);

    bgp_stop (peer);

    return 0;
}

/* TCP connection open.  Next we send open message to remote peer. And
   add read thread for reading open message. */
int
Bgp::bgp_connect_success (struct peer *peer)
{
  if (0) printf("\n%s: BGP CONNECT SUCCESS",name());
  BGP_READ_ON (peer->t_read, &Bgp::bgp_read,(Agent*)peer->LocalAgent);
  bgp_getsockname (peer); 
  
  if (! CHECK_FLAG (peer->sflags, PEER_STATUS_ACCEPT_PEER))
    bgp_open_send (peer);
  return 0;
}

/* TCP connect fail */
int
Bgp::bgp_connect_fail (struct peer *peer)
{
    bgp_stop (peer);
    return 0;
}

/* This function is the first starting point of all BGP connection. It
   try to connect to remote peer with non-blocking IO. */
int
Bgp::bgp_start (struct peer *peer)
{
    int status;
    if (0) printf("\n%s: BGP START",name());
    
    /* If the peer is passive mode, force to move to Active mode. */
    if (CHECK_FLAG (peer->flags, PEER_FLAG_PASSIVE))
    {
        BGP_EVENT_ADD (peer, TCP_connection_open_failed);
        return 0;
    }

    status = bgp_connect (peer);

    switch (status)
    {
    case connect_error:
        if (BGP_DEBUG (fsm, FSM))
            plog_info (peer->log, "%s [FSM] Connect error\n", peer->host);
        BGP_EVENT_ADD (peer, TCP_connection_open_failed);
        break;
    case connect_success:
        if (BGP_DEBUG (fsm, FSM))
            plog_info (peer->log, "%s [FSM] Connect immediately success\n",
                       peer->host);
        BGP_EVENT_ADD (peer, TCP_connection_open);
        break;
    case connect_in_progress:
      
      if (BGP_DEBUG (fsm, FSM))
        plog_info (peer->log, "%s [FSM] Non blocking connect waiting result\n",
                   peer->host);
      
      BGP_READ_ON (peer->t_read, &Bgp::bgp_read,(Agent*)peer->LocalAgent);
      break;

    }
    return 0;
}

/* Connect retry timer is expired when the peer status is Connect. */
int
Bgp::bgp_reconnect (struct peer *peer)
{
    bgp_stop (peer);
    bgp_start (peer);
    return 0;
}

int
Bgp::fsm_open (struct peer *peer)
{
    if (0) printf("\n%s: FSM OPEN",name());
    /* Send keepalive and make keepalive timer */
    bgp_keepalive_send (peer);

    /* Reset holdtimer value. */
    BGP_TIMER_OFF (peer->t_holdtime);

    return 0;
}

/* Called after event occured, this function change status and reset
   read/write and timer thread. */
void
Bgp::fsm_change_status (struct peer *peer, int status)
{
    bgp_dump_state (peer, peer->status, status);

    /* Preserve old status and change into New status. */
    peer->ostatus = peer->status;
    peer->status = status;
}

/* Keepalive send to peer. */
int
Bgp::fsm_keepalive_expire (struct peer *peer)
{
    bgp_keepalive_send (peer);
    return 0;
}

/* Hold timer expire.  This is error of BGP connection. So cut the
   peer and change to Idle status. */
int
Bgp::fsm_holdtime_expire (struct peer *peer)
{
    if (BGP_DEBUG (fsm, FSM))
        zlog (peer->log, LOG_DEBUG, "%s [FSM] Hold timer expire\n", peer->host);

    /* Send notify to remote peer. */
    bgp_notify_send (peer, BGP_NOTIFY_HOLD_ERR, 0);

    /* Sweep if it is temporary peer. */
    if (CHECK_FLAG (peer->sflags, PEER_STATUS_ACCEPT_PEER))
    {
        zlog_info ("%s [Event] Accepting BGP peer is deleted\n", peer->host);
        peer_delete (peer);
        return -1;
    }

    return 0;
}

/* Status goes to Established.  Send keepalive packet then make first
   update information. */
int
Bgp::bgp_establish (struct peer *peer)
{
    struct bgp_notify *notify;

    /* Reset capability open status flag. */
    if (! CHECK_FLAG (peer->sflags, PEER_STATUS_CAPABILITY_OPEN))
        SET_FLAG (peer->sflags, PEER_STATUS_CAPABILITY_OPEN);

    /* Clear last notification data. */
    notify = &peer->notify;
    if (notify->data)
        XFREE (MTYPE_TMP, notify->data);
    memset (notify, 0, sizeof (struct bgp_notify));

    /* Clear start timer value to default. */
    peer->v_start = BGP_INIT_START_TIMER;

    /* Increment established count. */
    peer->established++;
    fsm_change_status (peer, Established);

    /* Reset uptime, send keepalive, send current table. */
    bgp_uptime_reset (peer);

    if (peer->v_keepalive)
        bgp_keepalive_send (peer);

#ifndef HAVE_ZEBRA_93b
    bgp_announce_table (peer);
#else 
    bgp_announce_route_all(peer);

    BGP_TIMER_ON (peer->t_routeadv, &Bgp::bgp_routeadv_timer, 
		  peer,1);

#endif
    return 0;
}

/* Keepalive packet is received. */
int
Bgp::fsm_keepalive (struct peer *peer)
{
    /* peer count update */
    peer->keepalive_in++;

    BGP_TIMER_OFF (peer->t_holdtime);
    return 0;
}

/* Update packet is received. */
int
Bgp::fsm_update (struct peer *peer)
{
    BGP_TIMER_OFF (peer->t_holdtime);
    return 0;
}

/* This is empty event. */
int
Bgp::bgp_ignore (struct peer *peer)
{
    if (BGP_DEBUG (fsm, FSM))
        zlog (peer->log, LOG_DEBUG, "%s [FSM] bgp_ignore called\n", peer->host);
    return 0;
}
/* Execute event process. */
int
Bgp::bgp_event (struct thread *thread)
{
    if (0) printf("\n%s: BGP EVENT",name());
    int ret;
    int event;
    int next;
    struct peer *peer;

    peer = ( struct peer * ) THREAD_ARG (thread);
    event = THREAD_VAL (thread);
    /* Logging this event. */
    next = FSM [peer->status -1][event - 1].next_state;
    if (BGP_DEBUG (fsm, FSM))
        plog_info (peer->log, "%s [FSM] %s (%s->%s)\n", peer->host, 
                   bgp_event_str[event],
                   LOOKUP (bgp_status_msg, peer->status),
                   LOOKUP (bgp_status_msg, next));
    if (BGP_DEBUG (normal, NORMAL)
        && strcmp (LOOKUP (bgp_status_msg, peer->status), LOOKUP (bgp_status_msg, next)))
        zlog_info ("%s went from %s to %s\n",
                   peer->host,
                   LOOKUP (bgp_status_msg, peer->status),
                   LOOKUP (bgp_status_msg, next));

    /* Call function. */
    if (0) printf("\n%s: Current  Status: %d  Event  %d",name(),peer->status,event);

    ret = (*this.*(FSM [peer->status - 1][event - 1].func))(peer);
    /* When function do not want proceed next job return -1. */
    if (ret < 0)
        return ret;
    /* If status is changed. */
    if (next != peer->status)
        fsm_change_status (peer, next);
    /* Make sure timer is set. */
    bgp_timer_set (peer);
    if (0) printf("\n%s: Next  Status: %d  Event  %d",name(),peer->status,event);

    return 0;
}


////////////////////////////////////////////////
////////////////////////////////////////////////
//////////////////bgp_network.c/////////////////
////////////////////////////////////////////////

/* BGP try to connect to the peer.  */
int
Bgp::bgp_connect (struct peer *peer)
{
  
  char buf[SU_ADDRSTRLEN];
  char str[INET_ADDRSTRLEN];
  if (0) printf("\n%s: BGP CONNECT",name());
  
  // Get connecting bgp instance pointer
  Bgp* rPeer = Bgp::Ip2BgpMap->FindBySu(peer->su);

  if (0) if(!rPeer) cout<<"NO local peer found"<<endl;
#ifdef HAVE_PDNS_BGP 
  /*
    When using pdns we also check if the peer is in remote machine.
    A peer considered to be is a remore machine if it configured
    in the BGP registry (with the bgp-router) command, but its not 
    in the local system (FindBySu fails).
  */
  InterfaceList_t *InterfaceListPointer = NULL;
  InterfaceList_t::iterator iter;			

  
  if(!rPeer) {
    InterfaceListPointer = Bgp::Ip2BgpMap->FindPdnsNeighbor(string(peer->host));
    
    if (InterfaceListPointer) {    
      peer->is_peer_remote = true;
      if(0)cout<<"peer with ip "<<peer->host<<" is on remote federate"<<endl<<flush;
    } else {
      cout<<"No interface was found in Pdns Registry for peer "<<peer->host<<" check your configuration"<<endl;
      exit(1);
    }
  }
  
#endif
  if (!rPeer 
#ifdef HAVE_PDNS_BGP 
      && !InterfaceListPointer
#endif      
      )
    {
      struct bgp *bgp = bgp_get_default();
      
      if (1) printf("At %lf: Connect warning (from bgp_connect()): peer %s couldnt be found in Registry, Local id: %s\n",
		    NOW,inet_sutop (&peer->su, buf),Bgp::inet_ntop(AF_INET,&bgp->id,str,sizeof(str)));
      return connect_error;
    }
  
  struct bgp* bgp = bgp_get_default();
  
  if (BGP_DEBUG (events, EVENTS))
      plog_info (peer->log, "%s [Event] Connect start to %s\n",
		 peer->host, peer->host);
  
  /* Create new agents for this connection */
  
  Tcl& tcl = Tcl::instance();
  
  tcl.evalc("new Agent/TCP/FullTcp");
  peer->LocalAgent = (FullTcpAgent*)TclObject::lookup(tcl.result());
  peer->LocalAgent->bgp_app_ = 1;
  peer->LocalAgent->use_bgp_header();
  attachAgent(peer->LocalAgent);
  
  if (peer->LocalAgent == NULL)
    {
      /*this cant happen but just in case*/
      printf("%s: Fatal Error connect and listen agents for "
             "peer are not initiated ... connection aborted",name());
      return connect_error;
    }
    
#ifndef HAVE_PDNS_BGP  
  
  if (rPeer->ServAgent == NULL)
    {
      printf("%s: Fatal Error Remote peer %s has no server agents",name(),rPeer->name());
      return connect_error; 
    }    
  
  //Connect the Agents;
  //The agent in the other end of the Tcp Connection
  //is the ServAgent agent of the remote bgp instance
  
  tcl.evalf("[Simulator instance] connect %s %s",
	    peer->LocalAgent->name(),rPeer->ServAgent->name());
  
#else /*HAVE_PDNS_BGP*/
  

  //Determine the destination IP address
  string dst_ipaddr;
  if(!peer->is_peer_remote) { 
    /*rename*/
    ipaddr_t dst_ip_hbo;
    char dst_ip_str[INET_ADDRSTRLEN];
    
    tcl.evalf("lindex [lindex [ %s ipaddrlist ] 0 ] 0",rPeer->pNode->name());
    
    dst_ip_hbo= atol(tcl.result());
    
    ipaddr_t dst_ip_nbo = htonl(dst_ip_hbo);
    dst_ipaddr = Bgp::inet_ntop(AF_INET,(void*)&dst_ip_nbo,dst_ip_str,sizeof(dst_ip_str));
    
    if(0)cout<<"Debug info (from bgp_connect()): Connect to peer interface with ipaddr: "
	     <<dst_ip_str<<" Local Router id: "
	     <<Bgp::inet_ntop(AF_INET,&bgp->id,str,sizeof(str))<<endl<<flush; 
    
  } else {

    if(InterfaceListPointer->empty()) {
      cout<<"Error no interface IP address(es) associated with peer: "
	  <<inet_sutop (&peer->su, buf)<<" check your BGP registry configuration,"
	  <<"local router id: "<<Bgp::inet_ntop(AF_INET,&bgp->id,str,sizeof(str))<<endl; 
      
      return connect_error;      
    } else {

      //Read peer pdns IP address from registry
      iter = InterfaceListPointer->begin();
      dst_ipaddr = iter->first;
      
      if(0)cout<<"Debug info (from bgp_connect()): Connect to remote peer interface with ipaddr: "
	       <<iter->first.c_str()<<" Local Router id: "
	     <<Bgp::inet_ntop(AF_INET,&bgp->id,str,sizeof(str))<<endl<<flush; 
    }
  }
  
  //allocate an available port and bind it
  tcl.evalf("%s bind %s %d",pNode->name(),peer->LocalAgent->name(),0);


  //Connect to agent 
  tcl.evalf("[Simulator instance] ip-connect %s %s %d",
	    peer->LocalAgent->name(),dst_ipaddr.c_str(),BGP_PORT_DEFAULT);    


#endif /*HAVE_PDNS_BGP*/

  // Initiate the three way hand-shake
  peer->LocalAgent->connect();

  //Create a  msg list for this peer-connection
  //a msg list is a stucture that holds the actual
  //data that are transfered. This is required  because 
  //ns doesnt support transfer of content.

  pair<int,RMsgList_t> AgentMsgList ;
  RMsgList_t MsgList ;               
                                    
  AgentMsgList.first  = 0 ;        //pending bytes
  AgentMsgList.second = MsgList ;  //msg list
  struct agent_index index = GetLocalIndex(peer->LocalAgent);

  if(0)cout<<"bgp_connect() got local index "<<endl;

#ifdef HAVE_PDNS_BGP
  if(!peer->is_peer_remote) { 
#endif    
    if(0)cout<<"Initiating peer's msg list with index addr: "<<index.port<<
	   " and index port: "<<index.port<<endl<<flush; 

    rPeer->m_msgs.push_back(pair<struct agent_index,
			    pair<int,RMsgList_t> > (index,AgentMsgList));
#ifdef HAVE_PDNS_BGP
  }
  else 
    SendBgpOOB(RTI_BgpInitMsgList,bgp->su,peer->su,index);
  
  //Store the local interface(target) that will be used 
  //to reach the peer  
  //peer->target = peer_2_target_link(rPeer);

#endif

#ifndef HAVE_PDNS_BGP

  //Create new server agents for the remote peer , this is necessary 
  //because we just used its current server Agents to initiate a Tcp
  //connection.
  
  tcl.evalc("new Agent/TCP/FullTcp");
  rPeer->ServAgent  = (FullTcpAgent*) TclObject::lookup(tcl.result());
  rPeer->attachAgent(rPeer->ServAgent);
  rPeer->ServAgent->bgp_app_ = 1; 
  rPeer->ServAgent->use_bgp_header();
  tcl.evalf("%s listen", rPeer->ServAgent->name());
  
  /* Add  server thread */
  rPeer->thread_add_read (rPeer->master, &Bgp::bgp_accept, 
			  NULL,(Agent*)rPeer->ServAgent);
#endif  
  return connect_in_progress;
}

struct agent_index 
Bgp::GetLocalIndex(FullTcpAgent *tcp) {
  struct agent_index index;

  Tcl& tcl = Tcl::instance();

#ifdef HAVE_PDNS_BGP
  if(is_session_local(tcp)) {       
#endif /*HAVE_PDNS_BGP*/
    
    tcl.evalf("%s set agent_addr_",tcp->name());	
    index.addr= atol(tcl.result());
    tcl.evalf("%s set agent_port_",tcp->name());	
    index.port= atol(tcl.result());
    
    u_int32_t addr = htonl(index.addr);
    if(0)cout<<"GetLocalIndex: Tcp Agent ("<<tcp<<") with ip: "
	     <<index.addr<<"and port: "<<index.port<<endl; 
    
    return index;
#ifdef HAVE_PDNS_BGP  
  } else { 
  
    tcl.evalf("%s set my_ipaddr_",tcp->name());	
    index.addr= atol(tcl.result());

    tcl.evalf("%s set my_port_",tcp->name());	
    index.port= atol(tcl.result());
    
    if(0)cout<<"GetLocalIndex: Tcp Agent ("<<tcp<<") is remote with ip: "
	     <<index.addr<<"and port: "<<index.port<<endl; 
    
    return index;    
  }
#endif /*HAVE_PDNS_BGP*/
}

struct agent_index 
Bgp::GetRemoteIndex(FullTcpAgent *tcp) {
  struct agent_index index;

  Tcl& tcl = Tcl::instance();

#ifdef HAVE_PDNS_BGP
  if(is_session_local(tcp)){       
#endif /*HAVE_PDNS_BGP*/

    tcl.evalf("%s set dst_addr_",tcp->name());	
    index.addr= atol(tcl.result());
    tcl.evalf("%s set dst_port_",tcp->name());	
    index.port= atol(tcl.result());
  
    u_int32_t addr = htonl(index.addr);
    if(0)cout<<"GetRemoteIndex: Tcp Agent ("<<tcp<<")with ip: "
	     <<index.addr<<"and port: "<<index.port<<endl; 
  
  return index;
 
#ifdef HAVE_PDNS_BGP    
  } else {


    tcl.evalf("%s set dst_ipaddr_",tcp->name());	
    index.addr= atol(tcl.result());

    tcl.evalf("%s set dst_ipport_",tcp->name());	
    index.port= atol(tcl.result());
    
    if(0)cout<<"GetRemoteIndex: Tcp Agent ("<<tcp<<") is remote with ip: "
	<<index.addr<<"and port: "<<index.port<<endl; 
  
    return index;
  }
#endif
}

/* Given a agent index it returns a pointer
   to the bgp instance that this agent 
   is attached. Limitations:  This function 
   works correct for indexes that refer to agents
   that reside in the local system.
*/

Bgp*
Bgp::Index2Bgp ( struct agent_index* index ) {
  Tcl& tcl = Tcl::instance();
  FullTcpAgent* tcp_agent = NULL;
  NsObject*  node = NULL;

  //get: node by addr, agent by node & port, BGP* by agent
  tcl.evalf("catch { [Simulator instance] get-node-by-addr %d }",index->addr);	
  
  //if no exception happend get node-by-addr again.
  //we do this because get-node-by-addr throws
  //an error if no node is found.

  if(!atoi((char*)tcl.result())) { 
    
    tcl.evalf("[Simulator instance] get-node-by-addr %d",index->addr);	
    node =  (NsObject*) TclObject::lookup(tcl.result());

    if(node) {     
      tcl.evalf("%s agent %d",node->name(),index->port);
      tcp_agent =  (FullTcpAgent*) TclObject::lookup(tcl.result());
      if(tcp_agent)     
	return (Bgp*)tcp_agent->target_app() ;
    }
  }

  return NULL; 
}

#ifdef HAVE_PDNS_BGP
/*
  Utility function, checks to see if the other end of the tcp 
  session is on this system or not
*/
bool
Bgp::is_session_local(FullTcpAgent *tcp) {
  
#define DEFAULT_DST_IPADDR 0
#define DEFAULT_DST_IPPORT -1
#define DEFAULT_MY_IPADDR 0
#define DEFAULT_MY_PORT -1

  // We check if the rti dst addr 
  // var of the agent has the default value. If so 
  // the agent is considered local. If not, we then check if the 
  // set value is in this system.
  
  Tcl& tcl = Tcl::instance();

  ipaddr_t pdns_dst_ipaddr_;  
  tcl.evalf("%s set dst_ipaddr_",tcp->name());	
  pdns_dst_ipaddr_= atol(tcl.result());

  if(pdns_dst_ipaddr_== DEFAULT_DST_IPADDR) return true;
  
  NsObject *p = NULL;
  
  p = GetLocalIP(pdns_dst_ipaddr_);
  
  if (p) return true;

  return false;
}
#endif /*HAVE_PDNS_BGP*/ 

/* Accept bgp connection. */
int
Bgp::bgp_accept (struct thread *thread)
{
    union sockunion peer_su;
    struct peer *peer;
    struct peer *peer1;
    struct peer *me ;
    char buf[SU_ADDRSTRLEN];
    bool found = false;
#ifdef HAVE_PDNS_BGP
    bool is_remote = false;
#endif /*HAVE_PDNS_BGP*/

    /*get local agent, that is accepting the connection*/
    FullTcpAgent *lagent = (FullTcpAgent *) thread->u.ListenAgent;

    Tcl& tcl = Tcl::instance();

    /* first create index for remote agent*/
    struct agent_index rindex;
    rindex = GetRemoteIndex(lagent);

    Bgp *Peer = Index2Bgp(&rindex);
    if(Peer) { 
      
      struct bgp *rbgp = Peer->bgp_get_default();
      peer_su = rbgp->su;
      found = true;
#ifdef HAVE_PDNS_BGP
    } else { 
      //we check if the rindex belongs to 
      //to a bgp agent that resides in some other federate.

      string *IpStrPointer = NULL; //ip of remote bgp instance

      char str[INET_ADDRSTRLEN];
      u_int32_t addr = htonl(rindex.addr);

      IpStrPointer = Bgp::Ip2BgpMap->FindPdnsPeerByInterface
	(string(Bgp::inet_ntop(AF_INET,(void*)&addr,str,sizeof(str))));

      if(IpStrPointer) { 
	/*Convert string to sockunion */
	inet_pton (AF_INET, IpStrPointer->c_str(), &peer_su.sin.sin_addr);
	peer_su.sin.sin_family = AF_INET;
	is_remote = true;
	found = true;
      }
      
#endif /*HAVE_PDNS_BGP*/
    }
      if(!found) { 	
	printf("Error (from bgp_accept()): Unknown connecting agent\n");
	return -1;
      }    
      
      if (BGP_DEBUG (events, EVENTS))
	zlog_info ("[Event] BGP connection from host %s\n", inet_sutop (&peer_su, buf));
      
      /* Check remote IP address */
      peer1 = peer_lookup_by_su (&peer_su);
      if (! peer1 || peer1->status == Idle)
	{
	  if (BGP_DEBUG (events, EVENTS))
	    {
	      if (! peer1)
		{
		  if (0) printf("\n%s: Closing connection to remote host, host not found ",name());
		  zlog_info ("[Event] BGP connection IP address %s is not configured\n",
			     inet_sutop (&peer_su, buf));
		} 
	      else
		{
		  if (0) printf("\n%s: Closing connection to remote host, peer status Idle",name());
		  zlog_info ("[Event] BGP connection IP address %s is Idle state\n",
			     inet_sutop (&peer_su, buf));
		}
	    }
	  /* If the connection is not closing, close it */
	  if(!(lagent->state() == TCPS_LAST_ACK ||
	       lagent->state() == TCPS_CLOSED   ||
	       lagent->state() == TCPS_CLOSE_WAIT) )
	    {
	      Tcl& tcl = Tcl::instance();
	      zlog_info ("[Event] BGP closing TCP connection to IP address %s \n",
			 inet_sutop (&peer_su, buf));
	      tcl.evalf("%s close", lagent->name());
	    }
	  
	  /* We need to delete those agents ??????????*/	 
	  return -1;
	}
      
      /* Make dummy peer until read Open packet. */
      if (BGP_DEBUG (events, EVENTS))
        zlog_info ("[Event] Make dummy peer structure until read Open packet\n");
      
      {
        char buf[SU_ADDRSTRLEN + 1];
	
	//create dummy peer 
        peer = peer_create_accept ();
        SET_FLAG (peer->sflags, PEER_STATUS_ACCEPT_PEER);
        peer->su = peer_su;
        peer->status = Active;
        peer->local_id = peer1->local_id;

	// Store Tcp Agent pointer
        peer->LocalAgent  = lagent;

        //Initiate msg list for this connection
        pair<int,RMsgList_t> AgentMsgList ;
        RMsgList_t MsgList ;
        AgentMsgList.first = 0 ;
        AgentMsgList.second = MsgList ;
	struct agent_index index = GetLocalIndex(peer->LocalAgent);

#ifdef HAVE_PDNS_BGP
	peer->is_peer_remote = is_remote;
	
	if(!peer->is_peer_remote) {
#endif 
	  pair<agent_index,pair<int,RMsgList_t> >  tmp(index,AgentMsgList);
	  Peer->m_msgs.push_back(tmp);

#ifdef HAVE_PDNS_BGP
	} 
	else { 
	  //send oob msg
	  struct bgp *bgp = bgp_get_default();
	  SendBgpOOB(RTI_BgpInitMsgList,bgp->su,peer_su,index);
	}
#endif
        /* Make peer's address string. */
        sockunion2str (&peer_su, buf, SU_ADDRSTRLEN);
        peer->host = strdup (buf);
    }

    BGP_EVENT_ADD (peer, TCP_connection_open);
    return 0;
}

/* Make bgpd's server socket. */
void
Bgp::bgp_serv_sock_family ()
{
    int ret;
    int bgp_sock;
    union sockunion su;
    
    /*
      Create server listening Agent
    */
    Tcl& tcl = Tcl::instance();
#ifdef HAVE_PDNS_BGP 
    //Attention: the Bgp Tcp Listener must be used with agents that have 
    //ip addresses associated with them.
    tcl.evalc("new Agent/TCP/Listener/BGP");
    ServAgent  = (FullTcpAgent*) TclObject::lookup(tcl.result());

    ServAgent->use_bgp_header();

    //Attach Bgp Tcp Listener to node
    tcl.evalf("[Simulator instance] attach-agent %s %s ; %s attach-agent %s ; %s bind %s %d ; %s set table_size_ %d",
	      pNode->name(), ServAgent->name(),name(),ServAgent->name(),pNode->name(),
	      ServAgent->name(),BGP_PORT_DEFAULT,ServAgent->name(),INT_MAX);

    // attach bgp instance to agent 
    //tcl.evalf("%s attach-agent %s",name(),ServAgent->name());

    //Bind to well known port
    //tcl.evalf("%s bind %s %d",pNode->name(),
    //ServAgent->name(),BGP_PORT_DEFAULT);
    //tcl.evalf("%s set table_size_ %d",ServAgent->name(),INT_MAX);
    if(0) tcl.evalf("%s set debug_ 3",ServAgent->name());
    if(0) zlog_info ("Created server agent: %s\n", ServAgent->name());


    //set the BGP pointer of the server agent
    ((BgpTcpListenerAgent*)ServAgent)->setbgp(this);

#else    

    tcl.evalc("new Agent/TCP/FullTcp");
    ServAgent  = (FullTcpAgent*) TclObject::lookup(tcl.result());
    attachAgent(ServAgent);
    ServAgent->bgp_app_  = 1;
    ServAgent->use_bgp_header();
    tcl.evalf("%s listen", ServAgent->name());
    thread_add_read (master, &Bgp::bgp_accept, NULL,(Agent*)ServAgent);

#endif /* HAVE_PDNS_BGP */
}

/* After TCP connection is established.  Get local address and port. */
void
Bgp::bgp_getsockname (struct peer *peer)
{
    if (peer->su_local)
    {
        XFREE (MTYPE_TMP, peer->su_local);
        peer->su_local = NULL;
    }

    if (peer->su_remote)
    {
        XFREE (MTYPE_TMP, peer->su_remote);
        peer->su_remote = NULL;
    }

    struct bgp *bgp = bgp_get_default();
    
    peer->su_local  = ( union sockunion *) XMALLOC (MTYPE_TMP, sizeof (union sockunion));
    memcpy ( peer->su_local, &bgp->su, sizeof (struct sockaddr_in));

    peer->su_remote = ( union sockunion *) XMALLOC (MTYPE_TMP, sizeof (union sockunion));
    memcpy (peer->su_remote, &peer->su, sizeof (struct sockaddr_in));

    if (peer->su_local && peer->su_remote && (peer->su_local->sa.sa_family == AF_INET))
      {
	peer->nexthop.v4 = peer->su_local->sin.sin_addr;
      }
    peer->nexthop.ifp = NULL;
}

////////////////////////////////////////////////
/////////////bgp_open.c/////////////////////////
////////////////////////////////////////////////
////////////////////////////////////////////////

/* For debug purpose. */
void
Bgp::bgp_capability_mp_log (struct peer *peer, struct capability *cap, char *direct)
{
    if (BGP_DEBUG (normal, NORMAL))
    {
        zlog_info ("%s OPEN has CAPABILITY code: %u, length %u\n",
                   peer->host, cap->code, cap->length);
        zlog_info ("%s OPEN has MP_EXT CAP for afi/safi: %u/%u\n",
                   peer->host, ntohs(cap->mpc.afi) , cap->mpc.safi);
    }
}

void
Bgp::bgp_capability_vty_out (struct vty *vty, struct peer *peer)
{
    u_char *pnt;
    u_char *end;
    struct capability cap;

    pnt = ( u_char * ) peer->notify.data;
    end = pnt + peer->notify.length;

    while (pnt < end)
    {
        memcpy(&cap, pnt, sizeof(struct capability));

        if (pnt + 2 > end)
            return;
        if (pnt + (cap.length + 2) > end)
            return;

        if (cap.code == CAPABILITY_CODE_MP)
        {
            vty_out (zlog_default,LOG_DEBUG, "  Capability error for: Multi protocol ");

            switch (ntohs (cap.mpc.afi))
            {
            case AFI_IP:
                vty_out (zlog_default,LOG_DEBUG, "AFI IPv4, ");
                break;
		//case AFI_IP6:
                //vty_out (zlog_default,LOG_DEBUG, "AFI IPv6, ");
                //break;
            default:
                vty_out (zlog_default,LOG_DEBUG, "AFI Unknown %d, ", ntohs (cap.mpc.afi));
                break;
            }
            switch (cap.mpc.safi)
            {
            case SAFI_UNICAST:
                vty_out (zlog_default,LOG_DEBUG, "SAFI Unicast");
                break;
//             case SAFI_MULTICAST:
//                 vty_out (zlog_default,LOG_DEBUG, "SAFI Multicast");
                break;
            case SAFI_UNICAST_MULTICAST:
                vty_out (zlog_default,LOG_DEBUG, "SAFI Unicast Multicast");
                break;

            default:
                vty_out (zlog_default,LOG_DEBUG, "SAFI Unknown %d ", cap.mpc.safi);
                break;
            }
            vty_out (zlog_default,LOG_DEBUG, "%s", VTY_NEWLINE);
        } else if (cap.code >= 128)
            vty_out (zlog_default,LOG_DEBUG, "  Capability error: vendor specific capability code %d",
                     cap.code);
        else
            vty_out (zlog_default,LOG_DEBUG, "  Capability error: unknown capability code %d", 
                     cap.code);

        pnt += cap.length + 2;
    }
}

/* Set negotiated capability value. */
int
Bgp::bgp_capability_mp (struct peer *peer, struct capability *cap)
{
    if (ntohs (cap->mpc.afi) == AFI_IP)
    {
        if (cap->mpc.safi == SAFI_UNICAST)
        {
            peer->afc_recv[AFI_IP][SAFI_UNICAST] = 1;

            if (peer->afc[AFI_IP][SAFI_UNICAST])
                peer->afc_nego[AFI_IP][SAFI_UNICAST] = 1;
            else
                return -1;
	    //        } 
	//else if (cap->mpc.safi == SAFI_MULTICAST)
	//        {
	  //peer->afc_recv[AFI_IP][SAFI_MULTICAST] = 1;

	  ///if (peer->afc[AFI_IP][SAFI_MULTICAST])
	      //peer->afc_nego[AFI_IP][SAFI_MULTICAST] = 1;
	      //            else
	    //      return -1;
        } else
            return -1;
    }
    else
    {
        /* Unknown Address Family. */
        return -1;
    }

    return 0;
}

/* Parse given capability. */
int
Bgp::bgp_capability_parse (struct peer *peer, u_char *pnt, u_char length,
                           u_char **error)
{
    int ret;
    u_char *end;
    struct capability cap;

    end = pnt + length;

    while (pnt < end)
    {
        /* Fetch structure to the byte stream. */
        memcpy(&cap, pnt, sizeof(struct capability));

        /* We need at least capability code and capability length. */
        if (pnt + 2 > end)
        {
            zlog_info ("%s Capability length error\n", peer->host);
            bgp_notify_send (peer, BGP_NOTIFY_CEASE, 0);
            return -1;
        }

        /* Capability length check. */
        if (pnt + (cap.length + 2) > end)
        {
            zlog_info ("%s Capability length error\n", peer->host);
            bgp_notify_send (peer, BGP_NOTIFY_CEASE, 0);
            return -1;
        }

        /* We know MP Capability Code. */
        if (cap.code == CAPABILITY_CODE_MP)
        {
            /* For debug purpose. */
            bgp_capability_mp_log (peer, &cap, "RECV");

            /* Ignore capability when override-capability is set. */
            if (! CHECK_FLAG (peer->flags, PEER_FLAG_OVERRIDE_CAPABILITY))
            {
                /* Set negotiated value. */
                ret = bgp_capability_mp (peer, &cap);

                /* Unsupported Capability. */
                if (ret < 0)
                {
                    /* Store return data. */
                    memcpy (*error, &cap, cap.length + 2);
                    *error += cap.length + 2;
                }
            }
        } else if (cap.code == CAPABILITY_CODE_REFRESH ||
                   cap.code == CAPABILITY_CODE_REFRESH_01)
        {
            if (BGP_DEBUG (normal, NORMAL))
                zlog_info ("%s OPEN has CAPABILITY code: %d, length %d\n",
                           peer->host, cap.code, cap.length);

            /* Check length. */
            if (cap.length != 0)
            {
                zlog_info ("%s Route Refresh Capability length error %d\n",
                           peer->host, cap.length);
                bgp_notify_send (peer, BGP_NOTIFY_CEASE, 0);
                return -1;
            }

            if (BGP_DEBUG (normal, NORMAL))
                zlog_info ("%s OPEN has ROUTE-REFRESH capability(%s) for all address-families\n",
                           peer->host,
                           cap.code == CAPABILITY_CODE_REFRESH ? "old" : "New");

            /* BGP refresh capability */
            if (cap.code == CAPABILITY_CODE_REFRESH)
                peer->refresh_nego_old = 1;
            else
                peer->refresh_nego_new = 1;
        } else if (cap.code > 128)
        {
            /* We ignore sending Nofify's for vendor specific
               capabilities. Seems reasonable for now...  */
            zlog_warn ("%s Vendor specific capability %d\n",
                       peer->host, cap.code);
        } else
        {
            zlog_warn ("%s unrecognized capability code: %d - ignored\n",
                       peer->host, cap.code);
            memcpy (*error, &cap, cap.length + 2);
            *error += cap.length + 2;
        }

        pnt += cap.length + 2;
    }
    return 0;
}

int
Bgp::bgp_auth_parse (struct peer *peer, u_char *pnt, size_t length)
{
    bgp_notify_send (peer, 
                     BGP_NOTIFY_OPEN_ERR, 
                     BGP_NOTIFY_OPEN_AUTH_FAILURE); 
    return -1;
}

int
Bgp::strict_capability_same (struct peer *peer)
{
    int i, j;

    for (i = AFI_IP; i < AFI_MAX; i++)
        for (j = SAFI_UNICAST; j < SAFI_MAX; j++)
            if (peer->afc[i][j] != peer->afc_nego[i][j])
                return 0;
    return 1;
}

/* Parse open option */
int
Bgp::bgp_open_option_parse (struct peer *peer, u_char length, int *capability)
{
    int ret;
    u_char *end;
    u_char opt_type;
    u_char opt_length;
    u_char *pnt;
    u_char *error;
    u_char error_data[BGP_MAX_PACKET_SIZE];

    /* Fetch pointer. */
    pnt = stream_pnt (peer->ibuf);

    ret = 0;
    opt_type = 0;
    opt_length = 0;
    end = pnt + length;
    error = error_data;

    if (BGP_DEBUG (normal, NORMAL))
        zlog_info ("%s rcv OPEN w/ OPTION parameter len: %u\n",
                   peer->host, length);

    while (pnt < end)
    {
        /* Check the length. */
        if (pnt + 2 > end)
        {
            zlog_info ("%s Option length error\n", peer->host);
            bgp_notify_send (peer, BGP_NOTIFY_CEASE, 0);
            return -1;
        }

        /* Fetch option type and length. */
        opt_type = *pnt++;
        opt_length = *pnt++;

        /* Option length check. */
        if (pnt + opt_length > end)
        {
            zlog_info ("%s Option length error\n", peer->host);
            bgp_notify_send (peer, BGP_NOTIFY_CEASE, 0);
            return -1;
        }

        if (BGP_DEBUG (normal, NORMAL))
            zlog_info ("%s rcvd OPEN w/ optional parameter type %u (%s) len %u\n",
                       peer->host, opt_type,
                       opt_type == BGP_OPEN_OPT_AUTH ? "Authentication" :
                       opt_type == BGP_OPEN_OPT_CAP ? "Capability" : "Unknown",
                       opt_length);

        switch (opt_type)
        {
        case BGP_OPEN_OPT_AUTH:
            ret = bgp_auth_parse (peer, pnt, opt_length);
            break;
        case BGP_OPEN_OPT_CAP:
            ret = bgp_capability_parse (peer, pnt, opt_length, &error);
            *capability = 1;
            break;
        default:
            bgp_notify_send (peer, 
                             BGP_NOTIFY_OPEN_ERR, 
                             BGP_NOTIFY_OPEN_UNSUP_PARAM); 
            ret = -1;
            break;
        }

        /* Parse error.  To accumulate all unsupported capability codes,
           bgp_capability_parse does not return -1 when encounter
           unsupported capability code.  To detect that, please check
           error and erro_data pointer, like below.  */
        if (ret < 0)
            return -1;

        /* Forward pointer. */
        pnt += opt_length;
    }

    /* All OPEN option is parsed.  Check capability when strict compare
       flag is enabled.*/
    if (CHECK_FLAG (peer->flags, PEER_FLAG_STRICT_CAP_MATCH))
    {
        /* If Unsupported Capability exists. */
        if (error != error_data)
        {
            bgp_notify_send_with_data (peer, 
                                       BGP_NOTIFY_OPEN_ERR, 
                                       BGP_NOTIFY_OPEN_UNSUP_CAPBL, 
                                       error_data, error - error_data);
            return -1;
        }

        /* Check local capability does not negotiated with remote
           peer. */
        if (! strict_capability_same (peer))
        {
            bgp_notify_send (peer, 
                             BGP_NOTIFY_OPEN_ERR, 
                             BGP_NOTIFY_OPEN_UNSUP_CAPBL);
            return -1;
        }
    }

    /* Check there is no common capability send Unsupported Capability
       error. */
    if (*capability && ! CHECK_FLAG (peer->flags, PEER_FLAG_OVERRIDE_CAPABILITY))
    {
        if (! peer->afc_nego[AFI_IP][SAFI_UNICAST] 
            //&& ! peer->afc_nego[AFI_IP][SAFI_MULTICAST]
	    //            && ! peer->afc_nego[AFI_IP6][SAFI_UNICAST]
	    //            && ! peer->afc_nego[AFI_IP6][SAFI_MULTICAST]
	    )
        {
            plog_err (peer->log, "%s [Error] No common capability\n", peer->host);

            if (error != error_data)

                bgp_notify_send_with_data (peer, 
                                           BGP_NOTIFY_OPEN_ERR, 
                                           BGP_NOTIFY_OPEN_UNSUP_CAPBL, 
                                           error_data, error - error_data);
            else
                bgp_notify_send (peer, 
                                 BGP_NOTIFY_OPEN_ERR, 
                                 BGP_NOTIFY_OPEN_UNSUP_CAPBL);
            return -1;
        }
    }
    return 0;
}

/* Fill in capability open option to the packet. */
void
Bgp::bgp_open_capability (struct stream *s, struct peer *peer)
{
    u_char len;
    unsigned long cp;

    /* Remember current pointer for Opt Parm Len. */
    cp = stream_get_putp (s);

    /* Opt Parm Len. */
    stream_putc (s, 0);

    /* Do not send capability. */
    if (! CHECK_FLAG (peer->sflags, PEER_STATUS_CAPABILITY_OPEN) 
        || CHECK_FLAG (peer->flags, PEER_FLAG_DONT_CAPABILITY))
        return;

    /* When the peer is IPv4 unicast only, do not send capability. */
    if (
	//  ! peer->afc[AFI_IP][SAFI_MULTICAST] 
	//        && ! peer->afc[AFI_IP6][SAFI_UNICAST] 
	//        && ! peer->afc[AFI_IP6][SAFI_MULTICAST]
        ! CHECK_FLAG (peer->flags, PEER_FLAG_CAPABILITY_ROUTE_REFRESH))
        return;

    /* IPv4 unicast. */
    if (peer->afc[AFI_IP][SAFI_UNICAST])
    {
        peer->afc_adv[AFI_IP][SAFI_UNICAST] = 1;
        stream_putc (s, BGP_OPEN_OPT_CAP);
        stream_putc (s, CAPABILITY_CODE_MP_LEN + 2);
        stream_putc (s, CAPABILITY_CODE_MP);
        stream_putc (s, CAPABILITY_CODE_MP_LEN);
        stream_putw (s, AFI_IP);
        stream_putc (s, 0);
        stream_putc (s, SAFI_UNICAST);
    }
    /* IPv4 multicast. */
    /*
    if (peer->afc[AFI_IP][SAFI_MULTICAST])
    {
        peer->afc_adv[AFI_IP][SAFI_MULTICAST] = 1;
        stream_putc (s, BGP_OPEN_OPT_CAP);
        stream_putc (s, CAPABILITY_CODE_MP_LEN + 2);
        stream_putc (s, CAPABILITY_CODE_MP);
        stream_putc (s, CAPABILITY_CODE_MP_LEN);
        stream_putw (s, AFI_IP);
        stream_putc (s, 0);
        stream_putc (s, SAFI_MULTICAST);
    }
    */
    /* Route refresh. (OLD) */
    if (CHECK_FLAG (peer->flags, PEER_FLAG_CAPABILITY_ROUTE_REFRESH))
    {
        peer->refresh_adv = 1;
        stream_putc (s, BGP_OPEN_OPT_CAP);
        stream_putc (s, CAPABILITY_CODE_REFRESH_LEN + 2);
        stream_putc (s, CAPABILITY_CODE_REFRESH);
        stream_putc (s, CAPABILITY_CODE_REFRESH_LEN);
    }

    /* Route refresh. (New) */
    if (CHECK_FLAG (peer->flags, PEER_FLAG_CAPABILITY_ROUTE_REFRESH))
    {
        peer->refresh_adv = 1;
        stream_putc (s, BGP_OPEN_OPT_CAP);
        stream_putc (s, CAPABILITY_CODE_REFRESH_LEN + 2);
        stream_putc (s, CAPABILITY_CODE_REFRESH_01);
        stream_putc (s, CAPABILITY_CODE_REFRESH_LEN);
    }

    /* Total Opt Parm Len. */
    len = stream_get_putp (s) - cp - 1;
    stream_putc_at (s, cp, len);
}



////////////////////////////////////////////////
////////////////////////////////////////////////
////bgp_packet.c////////////////////////////////
////////////////////////////////////////////////

/* Set up BGP packet marker and packet type. */
int
Bgp::bgp_packet_set_marker (struct stream *s, u_char type)
{
    int i;

    /* Fill in marker. */
    for (i = 0; i < BGP_MARKER_SIZE; i++)
        stream_putc (s, 0xff);

    /* Dummy total length. This field is should be filled in later on. */
    stream_putw (s, 0);

    /* BGP packet type. */
    stream_putc (s, type);

    /* Return current stream size. */
    return stream_get_putp (s);
}

/* Set BGP packet header size entry.  If size is zero then use current
   stream size. */
int
Bgp::bgp_packet_set_size (struct stream *s, bgp_size_t size)
{
    int cp;

    /* Preserve current pointer. */
    cp = stream_get_putp (s);
    stream_set_putp (s, BGP_MARKER_SIZE);

    /* If size is specifed use it. */
    if (size)
        stream_putw (s, size);
    else
        stream_putw (s, cp);

    /* Write back current pointer. */
    stream_set_putp (s, cp);

    return cp;
}

/* Add New packet to the peer. */
void
Bgp::bgp_packet_add (struct peer *peer, struct stream *s)
{
    /* Add packet to the end of list. */
    stream_fifo_push (peer->obuf, s);
}

/* Free first packet. */
void
Bgp::bgp_packet_delete (struct peer *peer)
{
    stream_free (stream_fifo_pop (peer->obuf));
}

/* Duplicate packet. */
struct stream *
Bgp::bgp_packet_dup (struct stream *s)
{
    struct stream *New;

    New = stream_new (stream_get_endp (s));

    New->endp = s->endp;
    New->putp = s->putp;
    New->getp = s->getp;

    memcpy (New->data, s->data, stream_get_endp (s));

    return New;
}

#ifdef HAVE_ZEBRA_93b
/* Write packet to the peer. */
int
Bgp::bgp_write (struct thread *thread)
{
  struct peer *peer;
  u_char type;
  struct stream *s; 
  int num;
  int count = 0;

  /* Yes first of all get peer pointer. */
  peer = (struct peer*) THREAD_ARG (thread);
  peer->t_write = NULL;

  /* For non-blocking IO check. */
  if (peer->status == Connect)
    {
      return 0;
    }

    /* Nonblocking write until TCP output buffer is full.  */
  while (1)
    {
      int writenum;

      s = bgp_write_packet (peer);
      if (! s)
	return 0;

      /* Number of bytes to be sent.  */
      writenum = stream_get_endp (s) - stream_get_getp (s);

      /* Call write() syem call.  */
      num = peer_writen (peer, (char*) STREAM_PNT (s), writenum);
      if (num <= 0)
	{
	  bgp_stop (peer);
	  peer->status = Idle;
	  bgp_timer_set (peer);
	  return 0;
	}
      if (num != writenum)
	{
	  printf("bgp_write() error: this shouldn't happen\n");
	}

      /* Retrieve BGP packet type. */
      stream_set_getp (s, BGP_MARKER_SIZE + 2);
      type = stream_getc (s);

      switch (type)
	{
	case BGP_MSG_OPEN:
	  peer->open_out++;
	  break;
	case BGP_MSG_UPDATE:
	  peer->update_out++;
          Bgp::last_update_time_ = NOW;
	  break;
	case BGP_MSG_NOTIFY:
	  peer->notify_out++;
	  /* Double start timer. */
	  peer->v_start *= 2;

	  /* Overflow check. */
	  if (peer->v_start >= (60 * 2))
	    peer->v_start = (60 * 2);

	  /* BGP_EVENT_ADD (peer, BGP_Stop); */
	  bgp_stop (peer);
	  peer->status = Idle;
	  bgp_timer_set (peer);
	  return 0;
	  break;
	case BGP_MSG_KEEPALIVE:
	  peer->keepalive_out++;
	  break;
	case BGP_MSG_ROUTE_REFRESH:
	case BGP_MSG_ROUTE_REFRESH_01:
	  peer->refresh_out++;
	  break;
	}

      /* OK we send packet so delete it. */
      bgp_packet_delete (peer);

      if (++count >= BGP_WRITE_PACKET_MAX)
	break;
    }
  
  if (bgp_write_proceed (peer))
    BGP_WRITE_ON (peer->t_write, &Bgp::bgp_write);
  
  return 0;
}
#else 
/* Write packet to the peer. */
int
Bgp::bgp_write (struct thread *thread)
{
  
  struct peer *peer;
  u_char type;
  struct stream *s; 
  int ret;
  
  /* Yes first of all get peer pointer. */
  peer = ( struct peer * ) THREAD_ARG (thread);
  peer->t_write = NULL;
  
  if (peer->status == Connect)
    {
      return 0;
    }
  
  /* There should be at least one packet. */
  
  s = stream_fifo_head (peer->obuf);

  if (!s)
    return 0;
  assert (stream_get_endp (s) >= BGP_HEADER_SIZE);
  
  ret = peer_writen (peer, (char * )STREAM_DATA (s), stream_get_endp (s));
  
  if (ret <= 0)
    {
      bgp_stop (peer);
      peer->status = Idle;
      if(0)cout <<"Peer_written failed, changing status to Idle"<<endl;
      bgp_timer_set (peer);
      return 0;
    }
  
  /* Retrieve BGP packet type. */
  stream_set_getp (s, BGP_MARKER_SIZE + 2);
  type = stream_getc (s);
  
  switch (type)
    {
    case BGP_MSG_OPEN:
      peer->open_out++;
      break;
    case BGP_MSG_UPDATE:
      peer->update_out++;
      break;
    case BGP_MSG_NOTIFY:
      peer->notify_out++;
      /* Double start timer. */
      peer->v_start *= 2;
      
      /* Overflow check. */
      if (peer->v_start >= (60 * 2))
	peer->v_start = (60 * 2);
      
      /* BGP_EVENT_ADD (peer, BGP_Stop); */
      bgp_stop (peer);
      if(0)cout <<"notify msg rcvd .. changing status to Idle"<<endl;
      peer->status = Idle;
      bgp_timer_set (peer);
      return 0;
      break;
    case BGP_MSG_KEEPALIVE:
      peer->keepalive_out++;
      break;
    case BGP_MSG_ROUTE_REFRESH:
    case BGP_MSG_ROUTE_REFRESH_01:
      peer->refresh_out++;
      break;
    }
  
  /* OK we send packet so delete it. */
  bgp_packet_delete (peer);
  
  
  /* If there is a packet still need bgp write thread. */
  if (stream_fifo_head (peer->obuf))
    BGP_WRITE_ON (peer->t_write, &Bgp::bgp_write);
  
  /* 
     For per peer MRAI, if there are any supressed msgs
     we send them here. 
  */

  if ((mrai_type == MRAI_PER_PEER)
      && peer->top_adv
      &&(!peer->t_routeadv)) {

    /* add write thread for the next supressed msg */
    bgp_update_send(peer->top_adv->conf,peer,peer->top_adv->p,&peer->top_adv->attribute,peer->top_adv->afi,
                    peer->top_adv->safi,peer->top_adv->from,peer->top_adv->prd,peer->top_adv->tag);
  
    bgp_adj_set (peer->adj_out[peer->top_adv->afi][peer->top_adv->safi], peer->top_adv->p,
		 &peer->top_adv->attribute, peer->top_adv->prd, peer->top_adv->safi);

    /* rm from supressed list */
    bgp_advertise_remove(peer,peer->top_adv);
    
    /* If no more updates to send restart routeadv timer */
    if (!peer->top_adv) { 
      BGP_TIMER_ON (peer->t_routeadv, &Bgp::bgp_routeadv_timer, 
		    peer, peer->v_routeadv);
    }
      
  }
  return 0;
}
#endif
/* This is only for sending NOTIFICATION message to neighbor. */
int
Bgp::bgp_write_notify (struct peer *peer)
{
    int ret;
    u_char type;
    struct stream *s; 
    if (0) printf("\n%s: WRITE NOTIFY",name());
    /* There should be at least one packet. */
    s = stream_fifo_head (peer->obuf);
    if (!s)
        return 0;
    assert (stream_get_endp (s) >= BGP_HEADER_SIZE);

    /* I'm not sure fd is writable. */
    ret = peer_writen (peer, ( char * ) STREAM_DATA (s), stream_get_endp (s));
    //    This is never sent since the connection is closed right after 
    if (ret <= 0)
      {
	bgp_stop (peer);
	peer->status = Idle;
	bgp_timer_set (peer);
	  return 0;
      }
    
    /* Retrieve BGP packet type. */
    stream_set_getp (s, BGP_MARKER_SIZE + 2);
    type = stream_getc (s);

    assert (type == BGP_MSG_NOTIFY);

    /* Type should be notify. */
    peer->notify_out++;

    /* Double start timer. */
    peer->v_start *= 2;

    /* Overflow check. */
    if (peer->v_start >= (60 * 2))
        peer->v_start = (60 * 2);

    /* We don't call event manager at here for avoiding other events. */
    bgp_stop (peer);
    peer->status = Idle;
    bgp_timer_set (peer);

    return 0;
}

#ifdef HAVE_ZEBRA_93b
/* Get next packet to be written.  */
struct stream *
Bgp::bgp_write_packet (struct peer *peer)
{
  afi_t afi;
  safi_t safi;
  struct stream *s = NULL;
  struct bgp_advertise *adv;

  s = stream_fifo_head (peer->obuf);
  if (s)
    return s;

  for (afi = AFI_IP; afi < AFI_MAX; afi++)
    for (safi = SAFI_UNICAST; safi < SAFI_MAX; safi++)
      {
	adv = FIFO_HEAD (&peer->sync[afi][safi]->withdraw);
	if (adv)
	  {
	    s = bgp_withdraw_packet (peer, afi, safi);
	    if (s)
	      return s;
	  }
      }
    
  for (afi = AFI_IP; afi < AFI_MAX; afi++)
    for (safi = SAFI_UNICAST; safi < SAFI_MAX; safi++)
      {
	adv = FIFO_HEAD (&peer->sync[afi][safi]->update);
	if (adv)
	  {
            if (adv->binfo && adv->binfo->uptime < peer->synctime)
              s = bgp_update_packet (peer, afi, safi);

	    if (s)
	      return s;
	  }
      }

  return NULL;
}

/* Make BGP update packet.  */
struct stream *
Bgp::bgp_update_packet (struct peer *peer, afi_t afi, safi_t safi)
{
  struct stream *s;
  struct bgp_adj_out *adj;
  struct bgp_advertise *adv;
  struct stream *packet;
  struct bgp_node *rn = NULL;
  struct bgp_info *binfo = NULL;
  bgp_size_t total_attr_len = 0;
  unsigned long pos;
  char buf[BUFSIZ];
  struct prefix_rd *prd = NULL;
  u_char *tag = NULL;
  struct peer_conf* conf;
  struct listnode *nn;

  s = peer->work;
  stream_reset (s);

  adv = FIFO_HEAD (&peer->sync[afi][safi]->update);

  while (adv)
    {
      if (adv->rn)
        rn = adv->rn;
      adj = adv->adj;
      if (adv->binfo)
        binfo = adv->binfo;

      /* When remaining space can't include NLRI and it's length.  */
      if (rn && STREAM_REMAIN (s) <= BGP_NLRI_LENGTH + PSIZE (rn->p.prefixlen))
	break;

      /* If packet is empty, set attribute. */
      if (stream_empty (s))
	{
	  bgp_packet_set_marker (s, BGP_MSG_UPDATE);
	  stream_putw (s, 0);		
	  pos = stream_get_putp (s);
	  stream_putw (s, 0);
	  
	  for (nn = peer->conf->head; nn; nn = nn->next)
	    if ((conf = ( struct peer_conf * ) nn->data) != NULL)
	      total_attr_len = bgp_packet_attribute (conf, peer, s,
						     adv->baa->attr,
						     &rn->p, afi, safi,
						     binfo->peer, prd, tag);

	  stream_putw_at (s, pos, total_attr_len);
	}

      if (afi == AFI_IP && safi == SAFI_UNICAST)
	stream_put_prefix (s, &rn->p);
      
      if (BGP_DEBUG (update, UPDATE_OUT))
	zlog (peer->log, LOG_INFO, "%s send UPDATE %s/%d\n",
	      peer->host,
	      inet_ntop (rn->p.family, &(rn->p.u.prefix), buf, BUFSIZ),
	      rn->p.prefixlen);

      /* Synchnorize attribute.  */
      if (adj->attr)
	bgp_attr_unintern (adj->attr);
      
      adj->attr = bgp_attr_intern (adv->baa->attr);

      adv = bgp_advertise_clean (peer, adj, afi, safi);

      if (! (afi == AFI_IP && safi == SAFI_UNICAST))
	break;
    }
	 
  if (! stream_empty (s))
    {
      bgp_packet_set_size (s,0);
      packet = bgp_packet_dup (s);
      bgp_packet_add (peer, packet);
      BGP_WRITE_ON (peer->t_write, &Bgp::bgp_write);
      stream_reset (s);
      return packet;
    }
  return NULL;

}


#endif

/* Make keepalive packet and send it to the peer. */
void
Bgp::bgp_keepalive_send (struct peer *peer)
{
    struct stream *s;
    int length;

    s = stream_new (BGP_MAX_PACKET_SIZE);

    /* Make keepalive packet. */
    bgp_packet_set_marker (s, BGP_MSG_KEEPALIVE);

    /* Set packet size. */
    length = bgp_packet_set_size (s, 0);

    /* Dump packet if debug option is set. */
    /* bgp_packet_dump (s); */

    if (BGP_DEBUG (keepalive, KEEPALIVE))
        zlog_info ("%s sending KEEPALIVE\n", peer->host);
    if (BGP_DEBUG (normal, NORMAL))
        zlog_info ("%s send message type %d, length (incl. header) %d\n",
                   peer->host, BGP_MSG_KEEPALIVE, length);

    /* Add packet to the peer. */
    bgp_packet_add (peer, s);

    BGP_WRITE_ON (peer->t_write, &Bgp::bgp_write);
}

/* Make open packet and send it to the peer. */
void
Bgp::bgp_open_send (struct peer *peer)
{
    if (0) printf("\n%s: BGP OPEN SEND",name());
    struct stream *s;
    int length;
    u_int16_t send_holdtime;
    if (peer->config & PEER_CONFIG_TIMER)
        send_holdtime = peer->holdtime;
    else
        send_holdtime = peer->global_holdtime;
    s = stream_new (BGP_MAX_PACKET_SIZE);

    /* Make open packet. */
    bgp_packet_set_marker (s, BGP_MSG_OPEN);

    /* Set open packet values. */
    stream_putc (s, BGP_VERSION_4);        /* BGP version */
    stream_putw (s, peer->local_as);   /* My Autonomous System*/
    stream_putw (s, send_holdtime);        /* Hold Time */
    stream_put_in_addr (s, &peer->local_id); /* BGP Identifier */

    /* Set capability code. */
    bgp_open_capability (s, peer);

    /* Set BGP packet length. */
    length = bgp_packet_set_size (s, 0);

    if (BGP_DEBUG (normal, NORMAL))
        zlog_info ("%s sending OPEN, version %d, my as %d, holdtime %d, id %s\n", 
                   peer->host, BGP_VERSION_4, peer->local_as,
                   send_holdtime, inet_ntoa (peer->local_id));

    if (BGP_DEBUG (normal, NORMAL))
        zlog_info ("%s send message type %d, length (incl. header) %d\n",
                   peer->host, BGP_MSG_OPEN, length);

    /* Dump packet if debug option is set. */
    //   bgp_packet_dump (s); 

    /* Add packet to the peer. */
    bgp_packet_add (peer, s);

    BGP_WRITE_ON (peer->t_write, &Bgp::bgp_write);

}

/* Send BGP notify packet with data potion. */
void
Bgp::bgp_notify_send_with_data (struct peer *peer, u_char code, u_char sub_code,
                                u_char *data, size_t datalen)
{
    struct stream *s;
    int length;

    /* Allocate New stream. */
    s = stream_new (BGP_MAX_PACKET_SIZE);

    /* Make nitify packet. */
    bgp_packet_set_marker (s, BGP_MSG_NOTIFY);

    /* Set notify packet values. */
    stream_putc (s, code);        /* BGP notify code */
    stream_putc (s, sub_code);    /* BGP notify sub_code */

    /* If notify data is present. */
    if (data)
        stream_write (s, data, datalen);

    /* Set BGP packet length. */
    length = bgp_packet_set_size (s, 0);

    /* Add packet to the peer. */
    stream_fifo_free (peer->obuf);
    bgp_packet_add (peer, s);

    /* For debug */
    {
        struct bgp_notify bgp_notify;
        int first = 0;
        int i;
        char c[4];

        bgp_notify.code = code;
        bgp_notify.subcode = sub_code;
        bgp_notify.data = NULL;
        bgp_notify.length = length - BGP_MSG_NOTIFY_MIN_SIZE;

        if (bgp_notify.length)
        {
            bgp_notify.data = ( char * ) XMALLOC (MTYPE_TMP, bgp_notify.length * 3);
            for (i = 0; i < bgp_notify.length; i++)
                if (first)
                {
                    sprintf (c, " %02x", data[i]);
                    strcat (bgp_notify.data, c);
                } else
                {
                    first = 1;
                    sprintf (c, "%02x", data[i]);
                    strcpy (bgp_notify.data, c);
                }
        }
        bgp_notify_print (peer, &bgp_notify, "sending");
        if (bgp_notify.data)
            XFREE (MTYPE_TMP, bgp_notify.data);
    }

    if (BGP_DEBUG (normal, NORMAL))
        zlog_info ("%s send message type %d, length (incl. header) %d\n",
                   peer->host, BGP_MSG_NOTIFY, length);

    /* Call imidiately. */
    BGP_WRITE_OFF (peer->t_write);

    bgp_write_notify (peer);
}

/* Send BGP notify packet. */
void
Bgp::bgp_notify_send (struct peer *peer, u_char code, u_char sub_code)
{
    bgp_notify_send_with_data (peer, code, sub_code, NULL, 0);
}

/* Send BGP update packet. */
void
Bgp::bgp_update_send (struct peer_conf *conf, struct peer *peer,
                      struct prefix *p, struct attr *attr, afi_t afi, safi_t safi,
                      struct peer *from, struct prefix_rd *prd, u_char *tag)
{
    struct stream *s;
    struct stream *packet;
    unsigned long pos;
    bgp_size_t total_attr_len;
    char attrstr[BUFSIZ];
    char buf[BUFSIZ];
    string ip_prefix;
    int i,found = 0;
#ifdef DISABLE_BGP_ANNOUNCE
    return;
#endif /* DISABLE_BGP_ANNOUNCE */

    /* Increment the network queue used for convergence detection in NS2 
	Create object if there wasn't one */

    ip_prefix = inet_ntoa(p->u.prefix4);
    //print_event_prefixes();
    for (i = 0; i < total_events; i++)
    {
	if (event_prefix[i] == ip_prefix)
	{
		found = 1;
		break;
	}
    }
    if (!found)
    {
	total_events++;
	event_prefix[i] = ip_prefix;
	ls_array[i] = new struct logical_stamp;
	ls_array[i]->network_queue[peer->as]++;
	#if CONV_DET_DEBUG
	printf("\n DEBUG: Object created and network queue of AS %d incremented to %d",peer->as, ls_array[i]->network_queue[peer->as]);
	#endif
    } else
    {
	ls_array[i]->network_queue[peer->as]++;
	#if CONV_DET_DEBUG
	printf("\n DEBUG: OnSend network queue of AS %d incremented to %d",peer->as, ls_array[i]->network_queue[peer->as]);
	#endif
    } 		
    
    /* Make attribute dump string. */
    bgp_dump_attr (peer, attr, attrstr, BUFSIZ);

    if (BGP_DEBUG (update, UPDATE_OUT))
        zlog (peer->log, LOG_INFO, "%s send UPDATE %s/%d %s\n",
              peer->host, Bgp::inet_ntop(p->family, &(p->u.prefix), buf, BUFSIZ),
              p->prefixlen, attrstr);

    s = stream_new (BGP_MAX_PACKET_SIZE);

    /* Make BGP update packet. */
    bgp_packet_set_marker (s, BGP_MSG_UPDATE);

    /* Unfeasible Routes Length. */
    stream_putw (s, 0);       

    /* Make place for total attribute length.  */
    pos = stream_get_putp (s);
    stream_putw (s, 0);
    total_attr_len = bgp_packet_attribute (conf, peer, s, attr, p, afi, safi, from, prd, tag);

    /* Set Total Path Attribute Length. */
    stream_putw_at (s, pos, total_attr_len);

    /* NLRI set. */
    if (p->family == AF_INET && safi == SAFI_UNICAST)
        stream_put_prefix (s, p);

    /* Set size. */
    bgp_packet_set_size (s, 0);

    packet = bgp_packet_dup (s);
    stream_free (s);

    /* Dump packet if debug option is set. */
#ifdef DEBUG
    bgp_packet_dump (packet);
#endif /* DEBUG */
    //bgp_packet_dump (packet);


    /* Add packet to the peer. */
    bgp_packet_add (peer, packet);

    BGP_WRITE_ON (peer->t_write, &Bgp::bgp_write);
}

#ifdef HAVE_ZEBRA_93b
/* Make BGP withdraw packet.  */
struct stream *
Bgp::bgp_withdraw_packet (struct peer *peer, afi_t afi, safi_t safi)
{
  struct stream *s;
  struct stream *packet;
  struct bgp_adj_out *adj;
  struct bgp_advertise *adv;
  struct bgp_node *rn;
  unsigned long pos;
  bgp_size_t unfeasible_len;
  bgp_size_t total_attr_len;
  char buf[BUFSIZ];
  struct prefix_rd *prd = NULL;
  struct listnode *nm;
  struct peer_conf *conf;
  s = peer->work;
  stream_reset (s);

  while ((adv = FIFO_HEAD (&peer->sync[afi][safi]->withdraw)) != NULL)
    {
      adj = adv->adj;
      rn = adv->rn;

      if (STREAM_REMAIN (s) 
	  <= (BGP_NLRI_LENGTH + BGP_TOTAL_ATTR_LEN + PSIZE (rn->p.prefixlen)))
	break;

      if (stream_empty (s))
	{
	  bgp_packet_set_marker (s, BGP_MSG_UPDATE);
	  stream_putw (s, 0);
	}

      if (afi == AFI_IP && safi == SAFI_UNICAST)
	stream_put_prefix (s, &rn->p);
      else
	{
	  pos = stream_get_putp (s);
	  stream_putw (s, 0);
	  total_attr_len
	    = bgp_packet_withdraw (peer, s, &rn->p, afi, safi, prd, NULL);
      
	  /* Set total path attribute length. */
	  stream_putw_at (s, pos, total_attr_len);
	}

      if (BGP_DEBUG (update, UPDATE_OUT))
	zlog (peer->log, LOG_INFO, "%s send UPDATE %s/%d -- unreachable\n",
	      peer->host,
	      inet_ntop (rn->p.family, &(rn->p.u.prefix), buf, BUFSIZ),
	      rn->p.prefixlen);
      
      //       for (nm = peer->conf->head; nm; nm = nm->next)
      // 	if ((conf = ( struct peer_conf * ) nm->data) != NULL)
      // 	  conf->scount[afi][safi]--;

      bgp_adj_out_remove (rn, adj, peer, afi, safi);
      route_unlock_node (rn);

      if (! (afi == AFI_IP && safi == SAFI_UNICAST))
	break;
    }

  if (! stream_empty (s))
    {
      if (afi == AFI_IP && safi == SAFI_UNICAST)
	{
	  unfeasible_len 
	    = stream_get_putp (s) - BGP_HEADER_SIZE - BGP_UNFEASIBLE_LEN;
	  stream_putw_at (s, BGP_HEADER_SIZE, unfeasible_len);
	  stream_putw (s, 0);
	}
      bgp_packet_set_size (s,0);
      packet = bgp_packet_dup (s);
      bgp_packet_add (peer, packet);
      stream_reset (s);
      return packet;
    }

  return NULL;
}
/* Is there partially written packet or updates we can send right
   now.  */
int
Bgp::bgp_write_proceed (struct peer *peer)
{
  afi_t afi;
  safi_t safi;
  struct bgp_advertise *adv;

  if (stream_fifo_head (peer->obuf))
    return 1;

  for (afi = AFI_IP; afi < AFI_MAX; afi++)
    for (safi = SAFI_UNICAST; safi < SAFI_MAX; safi++)
      if (FIFO_HEAD (&peer->sync[afi][safi]->withdraw))
	return 1;

  for (afi = AFI_IP; afi < AFI_MAX; afi++)
    for (safi = SAFI_UNICAST; safi < SAFI_MAX; safi++)
      if ((adv = FIFO_HEAD (&peer->sync[afi][safi]->update)) != NULL)
	if (adv->binfo->uptime < peer->synctime)
	  return 1;

  return 0;
}

#endif
/* Send BGP update packet. */
void
Bgp::bgp_withdraw_send (struct peer *peer, struct prefix *p, afi_t afi, safi_t safi,
                        struct prefix_rd *prd, u_char *tag)
{
    struct stream *s;
    struct stream *packet;
    unsigned long pos;
    unsigned long cp;
    bgp_size_t unfeasible_len;
    bgp_size_t total_attr_len;
    char buf[BUFSIZ];
    string ip_prefix;
    int i,found = 0;

#ifdef DISABLE_BGP_ANNOUNCE
    return;
#endif /* DISABLE_BGP_ANNOUNCE */

    total_attr_len = 0;
    pos = 0;

    /* Increment the network queue used for convergence detection in NS2 
	Create object if there wasn't one */
    ip_prefix = inet_ntoa(p->u.prefix4);
    //print_event_prefixes();
    for (i = 0; i < total_events; i++)
    {
 	if (event_prefix[i] == ip_prefix)
	{
		found = 1;
		break;
	}
    }
    if (!found)
    {
	total_events++;
	event_prefix[i] = ip_prefix;
	ls_array[i] = new struct logical_stamp;
	ls_array[i]->network_queue[peer->as]++;
	#if CONV_DET_DEBUG
	printf("\n DEBUG: Object created and network queue of AS %d incremented to %d",peer->as, ls_array[i]->network_queue[peer->as]);
	#endif
    } else
    {
	ls_array[i]->network_queue[peer->as]++;
	#if CONV_DET_DEBUG
	printf("\n DEBUG: OnSend network queue of AS %d incremented to %d",peer->as, ls_array[i]->network_queue[peer->as]);
	#endif
    } 		

    if (BGP_DEBUG (update, UPDATE_OUT))
        zlog (peer->log, LOG_INFO, "%s send UPDATE %s/%d -- unreachable\n",
              peer->host, Bgp::inet_ntop(p->family, &(p->u.prefix), buf, BUFSIZ),
              p->prefixlen);

    s = stream_new (BGP_MAX_PACKET_SIZE);

    /* Make BGP update packet. */
    bgp_packet_set_marker (s, BGP_MSG_UPDATE);

    /* Unfeasible Routes Length. */

;
    cp = stream_get_putp (s);
    stream_putw (s, 0);

    /* Withdrawn Routes. */
    if (p->family == AF_INET && safi == SAFI_UNICAST)
    {
        stream_put_prefix (s, p);

        unfeasible_len = stream_get_putp (s) - cp - 2;

        /* Set unfeasible len.  */
        stream_putw_at (s, cp, unfeasible_len);

        /* Set total path attribute length. */
        stream_putw (s, 0);
    } else
    {
        pos = stream_get_putp (s);
        stream_putw (s, 0);
        total_attr_len = bgp_packet_withdraw (peer, s, p, afi, safi, prd, tag);

        /* Set total path attribute length. */
        stream_putw_at (s, pos, total_attr_len);
    }

    bgp_packet_set_size (s, 0);

    packet = bgp_packet_dup (s);
    stream_free (s);

    /* Add packet to the peer. */
    bgp_packet_add (peer, packet);

    BGP_WRITE_ON (peer->t_write, &Bgp::bgp_write);
}

char *
Bgp::afi2str (afi_t afi)
{
    if (afi == AFI_IP)
        return "AFI_IP";
    //    else if (afi == AFI_IP6)
    //        return "AFI_IP6";
    else
        return "Unknown AFI";
}

char *
Bgp::safi2str (safi_t safi)
{
    if (safi == SAFI_UNICAST)
        return "SAFI_UNICAST";
    //else if (safi == SAFI_MULTICAST)
    //return "SAFI_MULTICAST";
    else
        return "Unknown SAFI";
}

/* Send route refresh message to the peer. */
void
Bgp::bgp_route_refresh_send (struct peer *peer, afi_t afi, safi_t safi)
{
    struct stream *s;
    struct stream *packet;
    int length;

#ifdef DISABLE_BGP_ANNOUNCE
    return;
#endif /* DISABLE_BGP_ANNOUNCE */

    s = stream_new (BGP_MAX_PACKET_SIZE);

    /* Make BGP update packet. */
    if (peer->refresh_nego_new)
        bgp_packet_set_marker (s, BGP_MSG_ROUTE_REFRESH_01);
    else
        bgp_packet_set_marker (s, BGP_MSG_ROUTE_REFRESH);

    /* Encode Route Refresh message. */
    stream_putw (s, afi);
    stream_putc (s, 0);
    stream_putc (s, safi);

    /* Set packet size. */
    length = bgp_packet_set_size (s, 0);

    if (BGP_DEBUG (normal, NORMAL))
    {
        zlog_info ("%s sending REFRESH_REQ for afi/safi: %d/%d\n", 
                   peer->host, afi, safi);
        zlog_info ("%s send message type %d, length (incl. header) %d\n",
                   peer->host, peer->refresh_nego_new ?
                   BGP_MSG_ROUTE_REFRESH_01 : BGP_MSG_ROUTE_REFRESH, length);
    }

    /* Make real packet. */
    packet = bgp_packet_dup (s);
    stream_free (s);

    /* Add packet to the peer. */
    bgp_packet_add (peer, packet);

    BGP_WRITE_ON (peer->t_write, &Bgp::bgp_write);
}

/* RFC1771 6.8 Connection collision detection. */
int
Bgp::bgp_collision_detect (struct peer *New, struct in_addr remote_id)
{
    struct peer *peer;
    struct listnode *nn;

    /* Upon receipt of an OPEN message, the local system must examine
       all of its connections that are in the OpenConfirm state.  A BGP
       speaker may also examine connections in an OpenSent state if it
       knows the BGP Identifier of the peer by means outside of the
       protocol.  If among these connections there is a connection to a
       remote BGP speaker whose BGP Identifier equals the one in the
       OPEN message, then the local system performs the following
       collision resolution procedure: */
    for (nn = peer_list->head; nn; nn  = nn->next)
        if ((peer = ( struct peer * ) nn->data) != NULL)
        {
            /* Under OpenConfirm status, local peer structure already hold
               remote router ID. */

	  if (peer != New
	      && (peer->status == OpenConfirm || peer->status == OpenSent)
	      && sockunion_same (&peer->su, &New->su))
            {
                /* 1. The BGP Identifier of the local system is compared to
                   the BGP Identifier of the remote system (as specified in
                   the OPEN message). */

                if (ntohl (peer->local_id.s_addr) < ntohl (remote_id.s_addr))
                {
		  /* 2. If the value of the local BGP Identifier is less
                   than the remote one, the local system closes BGP
                   connection that already exists (the one that is
                   already in the OpenConfirm state), and accepts BGP
                   connection initiated by the remote system. */
		  //		  if (peer->LocalAgent->state() == TCPS_ESTABLISHED)
		  // bgp_notify_send (peer, BGP_NOTIFY_CEASE, 0);
		  return 1;
                } else
                {
                    /* 3. Otherwise, the local system closes newly created
                   BGP connection (the one associated with the newly
                   received OPEN message), and continues to use the
                   existing one (the one that is already in the
                   OpenConfirm state). */
		  //		  if (New->LocalAgent->state() == TCPS_ESTABLISHED)
		  //   bgp_notify_send (New, BGP_NOTIFY_CEASE, 0);
		  return -1;
                }
            }
        }
    return 0;
}

int
Bgp::bgp_open_receive (struct peer *peer, bgp_size_t size)
{
    int ret;
    u_char version;
    u_char optlen;
    u_int16_t holdtime;
    u_int16_t send_holdtime;
    as_t remote_as;
    struct peer *realpeer;
    struct in_addr remote_id;
    int capability;
    char notify_data_remote_as[2];
    char notify_data_remote_id[4];
    if (0) printf("%s: BGP OPEN RECEIVED",name());
    realpeer = NULL;

    /* Parse open packet. */
    version = stream_getc (peer->ibuf);
    memcpy (notify_data_remote_as, stream_pnt (peer->ibuf), 2);
    remote_as  = stream_getw (peer->ibuf);
    holdtime = stream_getw (peer->ibuf);
    memcpy (notify_data_remote_id, stream_pnt (peer->ibuf), 4);
    remote_id.s_addr = stream_get_ipv4 (peer->ibuf);

    /* Receive OPEN message log  */
    if (BGP_DEBUG (normal, NORMAL))
        zlog_info ("%s rcv OPEN, version %d, remote-as %d, holdtime %d, id %s\n",
                   peer->host, version, remote_as, holdtime,
                   inet_ntoa (remote_id));

    /* Lookup peer from Open packet. */
    if (CHECK_FLAG (peer->sflags, PEER_STATUS_ACCEPT_PEER))
    {
        int as = 0;

        realpeer = peer_lookup_with_open (&peer->su, remote_as, &remote_id, &as);


        if (! realpeer)
        {
            /* Peer's source IP address is check in bgp_accept(), so this
               must be AS number mismatch or remote-id configuration
               mismatch. */
            if (as)
            {
                if (BGP_DEBUG (normal, NORMAL))
                    zlog_info ("%s bad OPEN, wrong router identifier %s\n",
                               peer->host, inet_ntoa (remote_id));
                bgp_notify_send_with_data (peer, 
                                           (unsigned char ) BGP_NOTIFY_OPEN_ERR, 
                                           ( unsigned char ) BGP_NOTIFY_OPEN_BAD_BGP_IDENT,
                                           ( u_char * ) notify_data_remote_id, 4);
            } else
            {
                if (BGP_DEBUG (normal, NORMAL))
                    zlog_info ("%s bad OPEN, remote AS is %d, expected %d\n",
                               peer->host, remote_as, peer->as);
                bgp_notify_send_with_data (peer, 
                                           ( unsigned char ) BGP_NOTIFY_OPEN_ERR, 
                                           ( unsigned char ) BGP_NOTIFY_OPEN_BAD_PEER_AS,
                                           ( u_char * ) notify_data_remote_as, 2);
            }
            return -1;
        }
    }

    /* When collision is detected and this peer is closed.  Retrun
       immidiately. */
    ret = bgp_collision_detect (peer, remote_id);
    if (0) printf("\n%s: After Collission Detection %s",name(),(ret<0)?"Connection Rejected":"Connection Accepted");
    if (ret < 0) { 
      if (BGP_DEBUG (normal, NORMAL))
	zlog_info ("%s rcv OPEN, collision detected %s\n",
		   peer->host, inet_ntoa (remote_id));
      return ret;
    }

    /* Hack part. */
    if (CHECK_FLAG (peer->sflags, PEER_STATUS_ACCEPT_PEER))
    {
        if (ret == 0 && realpeer->status != Active
            && realpeer->status != OpenSent
            && realpeer->status != OpenConfirm)
        {
            if (BGP_DEBUG (events, EVENTS))
                zlog_info ("%s [Event] peers status is %s close connection\n",
                           realpeer->host, LOOKUP (bgp_status_msg, peer->status));
            return -1;
        }

        if (BGP_DEBUG (events, EVENTS))
            zlog_info ("%s [Event] Transfer temporary BGP peer to existing one\n",
                       peer->host);

        bgp_stop (realpeer);

        /* Transfer file descriptor. */
        realpeer->LocalAgent = peer->LocalAgent;
#ifdef HAVE_PDNS_BGP	
	realpeer->is_peer_remote = peer->is_peer_remote;
#endif /*HAVE_PDNS_BGP*/
        peer->LocalAgent = NULL;

        /* Transfer input buffer. */
        stream_free (realpeer->ibuf);
        realpeer->ibuf = peer->ibuf;
        realpeer->packet_size = peer->packet_size;
        peer->ibuf = NULL;

        /* Transfer status. */
	if(0) cout <<"Transfer status after open msg"<<endl;
        realpeer->status = peer->status;
        bgp_stop (peer);

        /* peer pointer change. Open packet send to neighbor. */
        peer = realpeer;
        bgp_open_send (peer);
        if (peer->LocalAgent->state() != TCPS_ESTABLISHED)
        {
            zlog_err ("bgp_open_receive peers tcp status is not establised \n");
            return -1;
        }
        BGP_READ_ON (peer->t_read, &Bgp::bgp_read,(Agent*)peer->LocalAgent);
    }

    /* remote router-id check. */
    if (remote_id.s_addr == 0
        || ntohl (remote_id.s_addr) >= 0xe0000000
        || ntohl (peer->local_id.s_addr) == ntohl (remote_id.s_addr))
    {
        if (BGP_DEBUG (normal, NORMAL))
            zlog_info ("%s bad OPEN, wrong router identifier %s\n",
                       peer->host, inet_ntoa (remote_id));
        bgp_notify_send_with_data (peer, 
                                   BGP_NOTIFY_OPEN_ERR, 
                                   BGP_NOTIFY_OPEN_BAD_BGP_IDENT,
                                   (u_char * ) notify_data_remote_id, 4);
        return -1;
    }

    /* Set remote router-id */
    peer->remote_id = remote_id;

    /* Peer BGP version check. */
    if (version != BGP_VERSION_4)
    {
        if (BGP_DEBUG (normal, NORMAL))
            zlog_info ("%s bad protocol version, remote requested %d, local request %d\n",
                       peer->host, version, BGP_VERSION_4);
        bgp_notify_send_with_data (peer, 
                                   BGP_NOTIFY_OPEN_ERR, 
                                   BGP_NOTIFY_OPEN_UNSUP_VERSION,
                                   (u_char * ) "\x04", 1);
        return -1;
    }

    /* Check neighbor as number. */
    if (remote_as != peer->as)
    {
        if (BGP_DEBUG (normal, NORMAL))
            zlog_info ("%s bad OPEN, remote AS is %d, expected %d\n",
                       peer->host, remote_as, peer->as);
        bgp_notify_send_with_data (peer, 
                                   BGP_NOTIFY_OPEN_ERR, 
                                   BGP_NOTIFY_OPEN_BAD_PEER_AS,
                                   ( u_char * ) notify_data_remote_as, 2);
        return -1;
    }

    /* From the rfc: Upon receipt of an OPEN message, a BGP speaker MUST
       calculate the value of the Hold Timer by using the smaller of its
       configured Hold Time and the Hold Time received in the OPEN message.
       The Hold Time MUST be either zero or at least three seconds.  An
       implementation may reject connections on the basis of the Hold Time. */

    if (holdtime < 3 && holdtime != 0)
    {
        bgp_notify_send (peer,
                         BGP_NOTIFY_OPEN_ERR, 
                         BGP_NOTIFY_OPEN_UNACEP_HOLDTIME);
        return -1;
    }

    /* From the rfc: A reasonable maximum time between KEEPALIVE messages
       would be one third of the Hold Time interval.  KEEPALIVE messages
       MUST NOT be sent more frequently than one per second.  An
       implementation MAY adjust the rate at which it sends KEEPALIVE
       messages as a function of the Hold Time interval. */

    if (peer->config & PEER_CONFIG_TIMER)
        send_holdtime = peer->holdtime;
    else
        send_holdtime = peer->global_holdtime;

    if (holdtime < send_holdtime)
    {
        peer->v_holdtime = holdtime;
        peer->v_keepalive = peer->v_holdtime / 3;
    } else
    {
        peer->v_holdtime = send_holdtime;

        if (peer->config & PEER_CONFIG_TIMER)
            peer->v_keepalive = peer->keepalive;
        else
            peer->v_keepalive = peer->global_keepalive;
    }

    /* Open option part parse. */
    capability = 0;
    optlen = stream_getc (peer->ibuf);
    if (optlen != 0)
    {
        ret = bgp_open_option_parse (peer, optlen, &capability);
        if (ret < 0)
            return ret;

        stream_forward (peer->ibuf, optlen);
    } else
    {
        if (BGP_DEBUG (normal, NORMAL))
            zlog_info ("%s rcvd OPEN w/ OPTION parameter len: 0\n",
                       peer->host);
    }

    /* Override capability. */
    if (! capability || CHECK_FLAG (peer->flags, PEER_FLAG_OVERRIDE_CAPABILITY))
    {
        peer->afc_nego[AFI_IP][SAFI_UNICAST] = peer->afc[AFI_IP][SAFI_UNICAST];
        //peer->afc_nego[AFI_IP][SAFI_MULTICAST] = peer->afc[AFI_IP][SAFI_MULTICAST];
	//        peer->afc_nego[AFI_IP6][SAFI_UNICAST] = peer->afc[AFI_IP6][SAFI_UNICAST];
	//        peer->afc_nego[AFI_IP6][SAFI_MULTICAST] = peer->afc[AFI_IP6][SAFI_MULTICAST];
    }

    /* Get sockname. */
    bgp_getsockname (peer);

    BGP_EVENT_ADD (peer, Receive_OPEN_message);

    peer->packet_size = 0;
    if (peer->ibuf)
        stream_reset (peer->ibuf);

    return 0;
}

/* Parse BGP Update packet and make attribute object. */
int
Bgp::bgp_update_receive (struct peer *peer, bgp_size_t size)
{
    int ret;
    u_char *end;
    struct stream *s;
    struct attr attr;
    bgp_size_t attribute_len;
    bgp_size_t update_len;
    bgp_size_t withdraw_len;
    struct bgp_nlri update;
    struct bgp_nlri withdraw;
    struct bgp_nlri mp_update;
    struct bgp_nlri mp_withdraw;
    char attrstr[BUFSIZ];
	

    /* Status must be Established. */
    if (peer->status != Established)
    {
        zlog_err ("%s [FSM] Update packet received under status %s\n",
                  peer->host, LOOKUP (bgp_status_msg, peer->status));
        bgp_notify_send (peer, BGP_NOTIFY_FSM_ERR, 0);
        return -1;
    }

    /* Set initial values. */
    memset (&attr, 0, sizeof (struct attr));
    memset (&update, 0, sizeof (struct bgp_nlri));
    memset (&withdraw, 0, sizeof (struct bgp_nlri));
    memset (&mp_update, 0, sizeof (struct bgp_nlri));
    memset (&mp_withdraw, 0, sizeof (struct bgp_nlri));

    s = peer->ibuf;
    end = stream_pnt (s) + size;

    /* RFC1771 6.3 If the Unfeasible Routes Length or Total Attribute
       Length is too large (i.e., if Unfeasible Routes Length + Total
       Attribute Length + 23 exceeds the message Length), then the Error
       Subcode is set to Malformed Attribute List.  */
    if (stream_pnt (s) + 2 > end)
    {
        zlog_err ("%s [Error] Update packet error\n"
                  " (packet length is short for unfeasible length)",
                  peer->host);
        bgp_notify_send (peer, BGP_NOTIFY_UPDATE_ERR, 
                         BGP_NOTIFY_UPDATE_MAL_ATTR);
        return -1;
    }

    /* Unfeasible Route Length. */
    withdraw_len = stream_getw (s);

    /* Unfeasible Route Length check. */
    if (stream_pnt (s) + withdraw_len > end)
    {
        zlog_err ("%s [Error] Update packet error\n"
                  " (packet unfeasible length overflow %d)",
                  peer->host, withdraw_len);
        bgp_notify_send (peer, BGP_NOTIFY_UPDATE_ERR, 
                         BGP_NOTIFY_UPDATE_MAL_ATTR);
        return -1;
    }

    /* Unfeasible Route packet format check. */
    if (withdraw_len > 0)
    {
        ret = nlri_sanity_check (peer, AFI_IP, stream_pnt (s), withdraw_len);
        if (ret < 0)
            return -1;

        if (BGP_DEBUG (packet, PACKET_RECV))
            zlog_info ("%s [Update:RECV] Unfeasible NLRI received\n", peer->host);

        withdraw.afi = AFI_IP;
        withdraw.safi = SAFI_UNICAST;
        withdraw.nlri = stream_pnt (s);
        withdraw.length = withdraw_len;
        stream_forward (s, withdraw_len);
    }

    /* Attribute total length check. */
    if (stream_pnt (s) + 2 > end)
    {
        zlog_warn ("%s [Error] Packet Error\n"
                   " (update packet is short for attribute length)",
                   peer->host);
        bgp_notify_send (peer, BGP_NOTIFY_UPDATE_ERR, 
                         BGP_NOTIFY_UPDATE_MAL_ATTR);
        return -1;
    }

    /* Fetch attribute total length. */
    attribute_len = stream_getw (s);

    /* Attribute length check. */
    if (stream_pnt (s) + attribute_len > end)
    {
        zlog_warn ("%s [Error] Packet Error\n"
                   " (update packet attribute length overflow %d)",
                   peer->host, attribute_len);
        bgp_notify_send (peer, BGP_NOTIFY_UPDATE_ERR, 
                         BGP_NOTIFY_UPDATE_MAL_ATTR);
        return -1;
    }

    /* Parse attribute when it exists. */
    if (attribute_len)
    {
        ret = bgp_attr_parse (peer, &attr, attribute_len, 
                              &mp_update, &mp_withdraw);
        if (ret < 0)
            return -1;
    }

    /* Logging the attribute. */
    bgp_dump_attr (peer, &attr, attrstr, BUFSIZ);

    if (BGP_DEBUG (update, UPDATE_IN))
    {
        zlog (peer->log, LOG_INFO, "%s rcvd UPDATE w/ attr: %s\n",
              peer->host, attrstr);
    }

    /* Network Layer Reachability Information. */
    update_len = end - stream_pnt (s);

    if (update_len)
    {
        /* Check NLRI packet format and prefix length. */
        ret = nlri_sanity_check (peer, AFI_IP, stream_pnt (s), update_len);
        if (ret < 0)
            return -1;

        /* Set NLRI portion to structure. */
        update.afi = AFI_IP;
        update.safi = SAFI_UNICAST;
        update.nlri = stream_pnt (s);
        update.length = update_len;
        stream_forward (s, update_len);
    }

    /* NLRI is processed only when the peer is configured specific
       Address Family and Subsequent Address Family. */
    if (peer->afc[AFI_IP][SAFI_UNICAST])
    {
        if (withdraw.length)
            nlri_parse (peer, NULL, &withdraw);

        if (update.length)
        {
            /* We check well-known attribute only for IPv4 unicast
               update. */
            ret = bgp_attr_check (peer, &attr);
            if (ret < 0)
                return -1;

            nlri_parse (peer, &attr, &update);
        }
    }

    /*
    if (peer->afc[AFI_IP][SAFI_MULTICAST])
    {
        if (mp_update.length
            && mp_update.afi == AFI_IP 
            && mp_update.safi == SAFI_MULTICAST)
            nlri_parse (peer, &attr, &mp_update);

        if (mp_withdraw.length
            && mp_withdraw.afi == AFI_IP 
            && mp_withdraw.safi == SAFI_MULTICAST)
            nlri_parse (peer, NULL, &mp_withdraw);
    }
    */
    /*
    if (peer->afc[AFI_IP6][SAFI_UNICAST])
    {
        if (mp_update.length 
            && mp_update.afi == AFI_IP6 
            && mp_update.safi == SAFI_UNICAST)
            nlri_parse (peer, &attr, &mp_update);

        if (mp_withdraw.length 
            && mp_withdraw.afi == AFI_IP6 
            && mp_withdraw.safi == SAFI_UNICAST)
            nlri_parse (peer, NULL, &mp_withdraw);
    }    
    if (peer->afc[AFI_IP6][SAFI_MULTICAST])
    {
        if (mp_update.length 
            && mp_update.afi == AFI_IP6 
            && mp_update.safi == SAFI_MULTICAST)
            nlri_parse (peer, &attr, &mp_update);

        if (mp_withdraw.length 
            && mp_withdraw.afi == AFI_IP6 
            && mp_withdraw.safi == SAFI_MULTICAST)
            nlri_parse (peer, NULL, &mp_withdraw);
    }
    */
    /* Everything is done.  We unintern temporary structures which
       interned in bgp_attr_parse(). */
    if (attr.aspath)
        aspath_unintern (attr.aspath);
    if (attr.community)
        community_unintern (attr.community);
    if (attr.cluster)
        cluster_unintern (attr.cluster);
    if (attr.transit)
        transit_unintern (attr.transit);

    /* If peering is stopped due to some reason, do not generate BGP
       event.  */
    if (peer->status != Established)
        return 0;

    /* Increment packet counter. */
    peer->update_in++;
    double simulation_time;
    simulation_time = Scheduler::instance().clock();
    time_t clock = (int)simulation_time + start_time;
    peer->update_time = clock;

    /* Generate BGP event. */
    BGP_EVENT_ADD (peer, Receive_UPDATE_message);

    return 0;
}

/* Notify message treatment function. */
void
Bgp::bgp_notify_receive (struct peer *peer, bgp_size_t size)
{
    struct bgp_notify bgp_notify;

    if (peer->notify.data)
    {
        XFREE (MTYPE_TMP, peer->notify.data);
        peer->notify.data = NULL;
        peer->notify.length = 0;
    }

    bgp_notify.code = stream_getc (peer->ibuf);
    bgp_notify.subcode = stream_getc (peer->ibuf);
    bgp_notify.length = size - 2;
    bgp_notify.data = NULL;

    /* Preserv notify code and sub code. */
    peer->notify.code = bgp_notify.code;
    peer->notify.subcode = bgp_notify.subcode;
    /* For further diagnostic record returned Data. */
    if (bgp_notify.length)
    {
        peer->notify.length = size - 2;
        peer->notify.data = ( char * ) XMALLOC (MTYPE_TMP, size - 2);
        memcpy (peer->notify.data, stream_pnt (peer->ibuf), size - 2);
    }

    /* For debug */
    {
        int i;
        int first = 0;
        char c[4];

        if (bgp_notify.length)
        {
            bgp_notify.data =  ( char * ) XMALLOC (MTYPE_TMP, bgp_notify.length * 3);
            for (i = 0; i < bgp_notify.length; i++)
                if (first)
                {
                    sprintf (c, " %02x", stream_getc (peer->ibuf));
                    strcat (bgp_notify.data, c);
                } else
                {
                    first = 1;
                    sprintf (c, "%02x", stream_getc (peer->ibuf));
                    strcpy (bgp_notify.data, c);
                }
        }

        bgp_notify_print(peer, &bgp_notify, "received");
        if (bgp_notify.data)
            XFREE (MTYPE_TMP, bgp_notify.data);
    }

    /* peer count update */
    peer->notify_in++;

    /* We have to check for Notify with Unsupported Optional Parameter.
       in that case we fallback to open without the capability option.
       But this done in bgp_stop. We just mark it here to avoid changing
       the fsm tables.  */
    if (bgp_notify.code == BGP_NOTIFY_OPEN_ERR &&
        bgp_notify.subcode == BGP_NOTIFY_OPEN_UNSUP_PARAM)
        UNSET_FLAG (peer->sflags, PEER_STATUS_CAPABILITY_OPEN);

    /* Also apply to Unsupported Capability until remote router support
       capability. */
    if (bgp_notify.code == BGP_NOTIFY_OPEN_ERR &&
        bgp_notify.subcode == BGP_NOTIFY_OPEN_UNSUP_CAPBL)
        UNSET_FLAG (peer->sflags, PEER_STATUS_CAPABILITY_OPEN);

    BGP_EVENT_ADD (peer, Receive_NOTIFICATION_message);
}

/* Keepalive treatment function -- get keepalive send keepalive */
void
Bgp::bgp_keepalive_receive (struct peer *peer, bgp_size_t size)
{
    if (BGP_DEBUG (keepalive, KEEPALIVE))
        zlog_info ("%s KEEPALIVE rcvd\n", peer->host);

    BGP_EVENT_ADD (peer, Receive_KEEPALIVE_message);
}

/* Route refresh message is received. */
void
Bgp::bgp_route_refresh_receive (struct peer *peer, bgp_size_t size)
{
    afi_t afi;
    safi_t safi;
    u_char reserved;

    /* If peer does not have the capability, send notification. */
    if (peer->refresh_nego_old == 0 && peer->refresh_nego_new == 0)
    {
        plog_err (peer->log, "%s [Error] BGP route refresh is not enabled\n",
                  peer->host);
        bgp_notify_send (peer,
                         BGP_NOTIFY_HEADER_ERR,
                         BGP_NOTIFY_HEADER_BAD_MESTYPE);
        return;
    }

    /* Status must be Established. */
    if (peer->status != Established)
    {
        plog_err (peer->log,
                  "%s [Error] Route refresh packet received under status %s\n",
                  peer->host, LOOKUP (bgp_status_msg, peer->status));
        bgp_notify_send (peer, BGP_NOTIFY_FSM_ERR, 0);
        return;
    }

    /* Packet size of already check in bgp_read (). */

    /* Parse packet. */
    afi = stream_getw (peer->ibuf);
    reserved = stream_getc (peer->ibuf);
    safi = stream_getc (peer->ibuf);

    /* Check AFI and SAFI. */
    if (afi != AFI_IP) 
	//&& afi != AFI_IP6)
    {
        plog_err (peer->log,
                  "%s [Error] Unknown AFI %d route refresh\n",
                  peer->host, afi);
        bgp_notify_send (peer, BGP_NOTIFY_CEASE, 0);
        return;
    }
    if (safi != SAFI_UNICAST && safi != SAFI_MULTICAST && safi )
    {
        plog_err (peer->log,
                  "%s [Error] Unknown SAFI %d route refresh\n",
                  peer->host, safi);
        bgp_notify_send (peer, BGP_NOTIFY_CEASE, 0);
        return;
    }
    /* Logging. */
    if (BGP_DEBUG (normal, NORMAL))
        zlog_info ("%s rcv REFRESH_REQ for afi/safi: %d/%d\n", peer->host, afi, safi);

#ifdef HAVE_ZEBRA_93b
    bgp_announce_route (peer, afi, safi);
#else 
    /* Perform route refreshment to the peer */
    bgp_refresh_table (peer, afi, safi);
#endif
}

/* BGP read utility function. */
int
Bgp::bgp_read_packet (struct peer *peer)
{
    int nbytes;
    int readsize;

    readsize = peer->packet_size - peer->ibuf->putp;

    /* If size is zero then return. */
    if (! readsize)
        return 0;

    /* Read packet from fd. */
    nbytes = stream_read_unblock (peer->ibuf, readsize);

    /* If read byte is smaller than zero then error occured. */
    if (nbytes < 0)
    {
        if (errno == EAGAIN)
            return -1;

        plog_err (peer->log, "%s [Error] bgp_read_packet error: %s\n",
                  peer->host, strerror (errno));
        BGP_EVENT_ADD (peer, TCP_fatal_error);
        return -1;
    }

    /* When read byte is zero : clear bgp peer and return */
    if (nbytes == 0)
    {
        if (BGP_DEBUG (events, EVENTS))
            plog_info (peer->log, "%s [Event] BGP connection closed \n",
                       peer->host);
        BGP_EVENT_ADD (peer, TCP_connection_closed);
        return -1;
    }

    /* We read partial packet. */
    if (peer->ibuf->putp != peer->packet_size)
        return -1;

    return 0;
}

/* Marker check. */
int
Bgp::bgp_marker_all_one (struct stream *s, int length)
{
    int i;

    for (i = 0; i < length; i++)
        if (s->data[i] != 0xff)
        {
            if (0) printf("\n%s: MARKER CHECK PROBLEM NOT ALL ONE",name());
            return 0;
        }

    return 1;
}

/* Starting point of packet process function. */
int
Bgp::bgp_read (struct thread *thread)
{
    int ret;
    u_char type = 0;
    struct peer *peer;
    bgp_size_t size;
    double simulation_time;
    char notify_data_length[2];
    if (0) printf("\n%s: BGP READ",name());
    /* Yes first of all get peer pointer. */
    peer = ( struct peer * ) THREAD_ARG (thread);
    peer->t_read = NULL;

    /* For non-blocking IO check. */
    if (peer->status == Connect)
      {
	bgp_connect_check(peer);
	goto done;
      } 
    else
      {
        BGP_READ_ON (peer->t_read, &Bgp::bgp_read,peer->LocalAgent);
      }
    
    /* Read packet header to determine type of the packet */
    if (peer->packet_size == 0)
        peer->packet_size = BGP_HEADER_SIZE;

    if (peer->ibuf->putp < BGP_HEADER_SIZE)
    {
        ret = bgp_read_packet (peer);

        /* Header read error or partial read packet. */
        if (ret < 0)
        {
            if (0) printf("\n%s: read packet error",name());
            goto done;
        }

        /* Get size and type. */
        stream_forward (peer->ibuf, BGP_MARKER_SIZE);
        memcpy (notify_data_length, stream_pnt (peer->ibuf), 2);
        size = stream_getw (peer->ibuf);
        type = stream_getc (peer->ibuf);

	simulation_time = Scheduler::instance().clock();

        /* Last read timer set */
        peer->readtime = start_time + (int)simulation_time;
        if (0) printf("\n%s: Message Type %d",name(),type);
        if (BGP_DEBUG (normal, NORMAL) && type != 2 && type != 0)
            zlog_info ("%s rcv message type %d, length (excl. header) %d\n",
                       peer->host, type, size - BGP_HEADER_SIZE);

        /* Marker check */
        if (type == BGP_MSG_OPEN
            && ! bgp_marker_all_one (peer->ibuf, BGP_MARKER_SIZE))
        {
            bgp_notify_send (peer,
                             BGP_NOTIFY_HEADER_ERR, 
                             BGP_NOTIFY_HEADER_NOT_SYNC);
            goto done;
        }

        /* BGP type check. */
        if (type != BGP_MSG_OPEN && type != BGP_MSG_UPDATE 
            && type != BGP_MSG_NOTIFY && type != BGP_MSG_KEEPALIVE 
            && type != BGP_MSG_ROUTE_REFRESH && type != BGP_MSG_ROUTE_REFRESH_01)
        {
            if (0) printf("\n%s: Unknown message type",name());
            if (BGP_DEBUG (normal, NORMAL))
                plog_err (peer->log,
                          "%s unknown message type 0x%02x\n",
                          peer->host, type);
            bgp_notify_send_with_data (peer,
                                       BGP_NOTIFY_HEADER_ERR,
                                       BGP_NOTIFY_HEADER_BAD_MESTYPE,
                                       &type, 1);
            goto done;
        }
        /* Mimimum packet length check. */
        if ((size < BGP_HEADER_SIZE)
            || (size > BGP_MAX_PACKET_SIZE)
            || (type == BGP_MSG_OPEN && size < BGP_MSG_OPEN_MIN_SIZE)
            || (type == BGP_MSG_UPDATE && size < BGP_MSG_UPDATE_MIN_SIZE)
            || (type == BGP_MSG_NOTIFY && size < BGP_MSG_NOTIFY_MIN_SIZE)
            || (type == BGP_MSG_KEEPALIVE && size != BGP_MSG_KEEPALIVE_MIN_SIZE)
            || (type == BGP_MSG_ROUTE_REFRESH && size != BGP_MSG_ROUTE_REFRESH_MIN_SIZE)
            || (type == BGP_MSG_ROUTE_REFRESH_01 && size != BGP_MSG_ROUTE_REFRESH_MIN_SIZE))
        {
            if (BGP_DEBUG (normal, NORMAL))
                plog_err (peer->log,
                          "%s bad message length - %d for %s\n",
                          peer->host, size, 
                          ((int) type) == (int)128 ?(char*) "ROUTE-REFRESH" :
                          (char*)bgp_type_str[(int) type]);
            bgp_notify_send_with_data (peer,
                                       BGP_NOTIFY_HEADER_ERR,
                                       BGP_NOTIFY_HEADER_BAD_MESLEN,
                                       ( u_char * ) notify_data_length, 2);
            goto done;
        }

        /* Adjust size to message length. */
        peer->packet_size = size;
    }

    ret = bgp_read_packet (peer);
    if (ret < 0)
        goto done;

    /* Get size and type again. */
    size = stream_getw_from (peer->ibuf, BGP_MARKER_SIZE);
    type = stream_getc_from (peer->ibuf, BGP_MARKER_SIZE + 2);

    /* BGP packet dump function. */
    bgp_dump_packet (peer, type, peer->ibuf);

    size = (peer->packet_size - BGP_HEADER_SIZE);

    /* Read rest of the packet and call each sort of packet routine */
    switch (type)
    {
    case BGP_MSG_OPEN:
        peer->open_in++;
        bgp_open_receive (peer, size);
        break;
    case BGP_MSG_UPDATE:
        bgp_update_receive (peer, size);
        break;
    case BGP_MSG_NOTIFY:
        bgp_notify_receive (peer, size);
        break;
    case BGP_MSG_KEEPALIVE:
        bgp_keepalive_receive (peer, size);
        break;
    case BGP_MSG_ROUTE_REFRESH:
    case BGP_MSG_ROUTE_REFRESH_01:
        peer->refresh_in++;
        bgp_route_refresh_receive (peer, size);
        break;
    default:
        printf("%s: Fatal Error unknow msg receved",name());
        return -1 ;
    }

    /* Clear input buffer. */
    peer->packet_size = 0;
    if (peer->ibuf)
        stream_reset (peer->ibuf);

    done:
    if (CHECK_FLAG (peer->sflags, PEER_STATUS_ACCEPT_PEER))
    {
        if (BGP_DEBUG (events, EVENTS))
            zlog_info ("%s [Event] Accepting BGP peer delete\n", peer->host);
        peer_delete (peer);
    }
    return 0;
}

void
Bgp::bgp_connect_check (struct peer *peer)
{
  
  /* Anyway I have to reset read and write thread. */
  BGP_READ_OFF (peer->t_read);
  
  if ( peer->LocalAgent->state() ==  TCPS_ESTABLISHED )
    {
      BGP_EVENT_ADD (peer, TCP_connection_open);
    }
  else
    {
      if (BGP_DEBUG (events, EVENTS))
	plog_info (peer->log, "%s [Event] Connect failed (%s)\n",
		   peer->host, strerror (errno));
      BGP_EVENT_ADD (peer, TCP_connection_open_failed);
    }
}



////////////////////////////////////////////////
////////////////////////////////////////////////
///bgp_regexp.c/////////////////////////////////
////////////////////////////////////////////////
/* Character `_' has special mean.  It represents [,{}() ] and the
   beginning of the line(^) and the end of the line ($).  

   (^|[,{}() ]|$) */

regex_t *
Bgp::bgp_regcomp (char *regstr)
{
    /* Convert _ character to generic regular expression. */
    int i, j;
    int len;
    int magic = 0;
    char *magic_str;
    char magic_regexp[] = "(^|[,{}() ]|$)";
    int ret;
    regex_t *regex;

    len = strlen (regstr);
    for (i = 0; i < len; i++)
        if (regstr[i] == '_')
            magic++;

    magic_str = ( char * ) XMALLOC (MTYPE_TMP, len + (14 * magic) + 1);
    regex = ( regex_t * )  XMALLOC (MTYPE_TMP, sizeof (regex_t));

    for (i = 0, j = 0; i < len; i++)
    {

        if (regstr[i] == '_')
        {
            memcpy (magic_str + j, magic_regexp, strlen (magic_regexp));
            j += strlen (magic_regexp);
        } else
            magic_str[j++] = regstr[i];
    }
    magic_str[j] = '\0';

    ret = regcomp (regex, magic_str, REG_EXTENDED);

    XFREE (MTYPE_TMP, magic_str);

    if (ret != 0)
    {
        XFREE (MTYPE_TMP, regex);

        return NULL;
    }

    return regex;
}

int
Bgp::bgp_regexec (regex_t *regex, struct aspath *aspath)
{
    return regexec (regex, aspath->str, 0, NULL, 0);
}

void
Bgp::bgp_regex_free (regex_t *regex)
{
    regfree (regex);
    XFREE (MTYPE_TMP, regex);
}



////////////////////////////////////////////////
////////////////////////////////////////////////
///bgp_route.c//////////////////////////////////
////////////////////////////////////////////////


struct bgp_node *
Bgp::bgp_route_node_get (struct bgp *bgp, afi_t afi, safi_t safi, struct prefix *p,
                         struct prefix_rd *prd)
{
    struct bgp_node *rn;
    struct bgp_table *table;

    table = bgp->rib[afi][safi];

    return route_node_get (table, p);
}

/* Allocate New bgp info structure. */
struct bgp_info *
Bgp::bgp_info_new ()
{
    struct bgp_info *New;

    New = ( struct bgp_info * ) XMALLOC (MTYPE_BGP_ROUTE, sizeof (struct bgp_info));
    memset (New, 0, sizeof (struct bgp_info));

    return New;
}

/* Free bgp route information. */
void
Bgp::bgp_info_free (struct bgp_info *br)
{

#ifndef HAVE_ZEBRA_93b
  if (br->bgp_damp_info)
    br->bgp_damp_info->bgp_info = NULL;
#endif
  if (br->attr)
    bgp_attr_unintern (br->attr);
#ifdef HAVE_ZEBRA_93b
  if (br->damp_info)
    bgp_damp_info_free (br->damp_info, 0);
#endif

  XFREE (MTYPE_BGP_ROUTE, br);
}

/* Add bgp route infomation to routing table node. */
void
Bgp::bgp_info_add (struct bgp_info **rp, struct bgp_info *ri)
{
    ri->next = *rp;
    ri->prev = NULL;
    if (*rp)
        (*rp)->prev = ri;
    *rp = ri;
}

/* Delete rib from rib list. */
void
Bgp::bgp_info_delete (struct bgp_info **rp, struct bgp_info *ri)
{
    if (ri->next)
        ri->next->prev = ri->prev;

    if (ri->prev)
        ri->prev->next = ri->next;
    else
        *rp = ri->next;
}

/* Get MED value.  If MED value is missing and "bgp bestpath
   missing-as-worst" is specified, treat it as the worst value. */
u_int32_t
Bgp::bgp_med_value (struct attr *attr, struct bgp *bgp)
{
    if (attr->flag & ATTR_FLAG_BIT (BGP_ATTR_MULTI_EXIT_DISC))
        return attr->med;
    else
    {
        if (CHECK_FLAG (bgp->config, BGP_CONFIG_MED_MISSING_AS_WORST))
            return 4294967295ul;
        else
            return 0;
    }
}

/* Compare two bgp route entity.  br is preferable then return 1. */
int
Bgp::bgp_info_cmp (struct bgp *bgp, struct bgp_info *New, struct bgp_info *exist)
{
    u_int32_t new_pref;
    u_int32_t exist_pref;
    u_int32_t new_med;
    u_int32_t exist_med;
    struct in_addr new_id;
    struct in_addr exist_id;
    int new_cluster;
    int exist_cluster;
    int internal_as_route = 0;
    int confed_as_route = 0;
    int ret;

    /* 0. Null check. */
    if (New == NULL)
        return 0;
    if (exist == NULL)
        return 1;

    /* 1. Weight check. */
    if (New->attr->weight > exist->attr->weight)
        return 1;
    if (New->attr->weight < exist->attr->weight)
        return 0;

    /* 2. Local preference check. */
    if (New->attr->flag & ATTR_FLAG_BIT (BGP_ATTR_LOCAL_PREF))
        new_pref = New->attr->local_pref;
    else
        new_pref = bgp->default_local_pref;

    if (exist->attr->flag & ATTR_FLAG_BIT (BGP_ATTR_LOCAL_PREF))
        exist_pref = exist->attr->local_pref;
    else
        exist_pref = bgp->default_local_pref;

    if (new_pref > exist_pref)
        return 1;
    if (new_pref < exist_pref)
        return 0;

    /* 3. Local route check. */
    if (New->type == ZEBRA_ROUTE_CONNECT)
        return 1;
    if (exist->type == ZEBRA_ROUTE_CONNECT)
        return 0;

    if (New->type == ZEBRA_ROUTE_STATIC)
        return 1;
    if (exist->type == ZEBRA_ROUTE_STATIC)
        return 0;

    if (New->sub_type == BGP_ROUTE_STATIC)
        return 1;
    if (exist->sub_type == BGP_ROUTE_STATIC)
        return 0;

    if (New->sub_type == BGP_ROUTE_AGGREGATE)
        return 1;
    if (exist->sub_type == BGP_ROUTE_AGGREGATE)
        return 0;

    /* 4. AS path length check. */
    if (! CHECK_FLAG (bgp->config, BGP_CONFIG_ASPATH_IGNORE))
    {
        if (New->attr->aspath->count < exist->attr->aspath->count)
            return 1;
        if (New->attr->aspath->count > exist->attr->aspath->count)
            return 0;
    }

    /* 5. Origin check. */
    if (New->attr->origin < exist->attr->origin)
        return 1;
    if (New->attr->origin > exist->attr->origin)
        return 0;

    /* 6. MED check. */
    internal_as_route = (New->attr->aspath->length == 0
                         && exist->attr->aspath->length == 0);
    confed_as_route = (New->attr->aspath->length > 0
                       && exist->attr->aspath->length > 0
                       && New->attr->aspath->count == 0
                       && exist->attr->aspath->count == 0);

    if (CHECK_FLAG (bgp->config, BGP_CONFIG_ALWAYS_COMPARE_MED)
        || (CHECK_FLAG (bgp->config, BGP_CONFIG_MED_CONFED)
            && confed_as_route)
        || aspath_cmp_left (New->attr->aspath, exist->attr->aspath)
        || aspath_cmp_left_confed (New->attr->aspath, exist->attr->aspath)
        || internal_as_route)
    {
        new_med = bgp_med_value (New->attr, bgp);
        exist_med = bgp_med_value (exist->attr, bgp);

        if (new_med < exist_med)
            return 1;
        if (new_med > exist_med)
            return 0;
    }

    /* 7. Peer type check. */
    if (peer_sort (New->peer) == BGP_PEER_EBGP 
        && peer_sort (exist->peer) == BGP_PEER_IBGP)
        return 1;
    if (peer_sort (New->peer) == BGP_PEER_EBGP 
        && peer_sort (exist->peer) == BGP_PEER_CONFED)
        return 1;
    if (peer_sort (New->peer) == BGP_PEER_IBGP 
        && peer_sort (exist->peer) == BGP_PEER_EBGP)
        return 0;
    if (peer_sort (New->peer) == BGP_PEER_CONFED 
        && peer_sort (exist->peer) == BGP_PEER_EBGP)
        return 0;

    /* 8. IGP metric check. */
    if (New->igpmetric < exist->igpmetric)
        return 1;
    if (New->igpmetric > exist->igpmetric)
        return 0;

    /* 9. Maximum path check. */

    /* 10. If both paths are external, prefer the path that was received
       first (the oldest one).  This step minimizes route-flap, since a
       newer path won't displace an older one, even if it was the
       preferred route based on the additional decision criteria below.  */
    if (! CHECK_FLAG (bgp->config, BGP_CONFIG_COMPARE_ROUTER_ID)
        && peer_sort (New->peer) == BGP_PEER_EBGP
        && peer_sort (exist->peer) == BGP_PEER_EBGP)
    {
        if (CHECK_FLAG (New->flags, BGP_INFO_SELECTED))
            return 1;
        if (CHECK_FLAG (exist->flags, BGP_INFO_SELECTED))
            return 0;
    }

    /* 11. Rourter-ID comparision. */
    if (New->attr->flag & ATTR_FLAG_BIT(BGP_ATTR_ORIGINATOR_ID))
        new_id.s_addr = New->attr->originator_id.s_addr;
    else
        new_id.s_addr = New->peer->remote_id.s_addr;
    if (exist->attr->flag & ATTR_FLAG_BIT(BGP_ATTR_ORIGINATOR_ID))
        exist_id.s_addr = exist->attr->originator_id.s_addr;
    else
        exist_id.s_addr = exist->peer->remote_id.s_addr;

    if (ntohl (new_id.s_addr) < ntohl (exist_id.s_addr))
        return 1;
    if (ntohl (new_id.s_addr) > ntohl (exist_id.s_addr))
        return 0;

    /* 12. Cluster length comparision. */
    if (New->attr->flag & ATTR_FLAG_BIT(BGP_ATTR_CLUSTER_LIST))
        new_cluster = New->attr->cluster->length;
    else
        new_cluster = 0;
    if (exist->attr->flag & ATTR_FLAG_BIT(BGP_ATTR_CLUSTER_LIST))
        exist_cluster = exist->attr->cluster->length;
    else
        exist_cluster = 0;

    if (new_cluster < exist_cluster)
        return 1;
    if (new_cluster > exist_cluster)
        return 0;

    /* 13. Neighbor address comparision. */
    ret = sockunion_cmp (New->peer->su_remote, exist->peer->su_remote);

    if (ret == 1)
        return 0;
    if (ret == -1)
        return 1;

    return 1;
}

enum filter_type
Bgp::bgp_input_filter (struct peer_conf *conf, struct prefix *p, struct attr *attr,
                       afi_t afi, safi_t safi)
{
    struct bgp_filter *filter;

    filter = &conf->filter[afi][safi];

    if (DISTRIBUTE_IN_NAME (filter))
        if (access_list_apply (DISTRIBUTE_IN (filter), p) == FILTER_DENY)
            return FILTER_DENY;

    if (PREFIX_LIST_IN_NAME (filter))
        if (prefix_list_apply (PREFIX_LIST_IN (filter), p) == PREFIX_DENY)
            return FILTER_DENY;

    if (FILTER_LIST_IN_NAME (filter))
        if (as_list_apply (FILTER_LIST_IN (filter), attr->aspath)== AS_FILTER_DENY)
            return FILTER_DENY;

    return FILTER_PERMIT;
}

enum filter_type
Bgp::bgp_output_filter (struct peer_conf *conf, struct prefix *p, struct attr *attr,
                        afi_t afi, safi_t safi)
{
    struct bgp_filter *filter;

    filter = &conf->filter[afi][safi];

    if (DISTRIBUTE_OUT_NAME (filter))
        if (access_list_apply (DISTRIBUTE_OUT (filter), p) == FILTER_DENY)
            return FILTER_DENY;

    if (PREFIX_LIST_OUT_NAME (filter))
        if (prefix_list_apply (PREFIX_LIST_OUT (filter), p) == PREFIX_DENY)
            return FILTER_DENY;

    if (FILTER_LIST_OUT_NAME (filter))
        if (as_list_apply (FILTER_LIST_OUT (filter), attr->aspath) == AS_FILTER_DENY)
            return FILTER_DENY;

    return FILTER_PERMIT;
}

/* If community attribute includes no_export then return 1. */
int
Bgp::bgp_community_filter (struct peer *peer, struct attr *attr)
{
    if (attr->community)
    {
        /* NO_ADVERTISE check. */
        if (community_include (attr->community, COMMUNITY_NO_ADVERTISE))
            return 1;

        /* NO_EXPORT check. */
        if (peer_sort (peer) == BGP_PEER_EBGP &&
            community_include (attr->community, COMMUNITY_NO_EXPORT))
            return 1;

        /* NO_EXPORT_SUBCONFED check. */
        if (peer_sort (peer) == BGP_PEER_EBGP 
            || peer_sort (peer) == BGP_PEER_CONFED)
            if (community_include (attr->community, COMMUNITY_NO_EXPORT_SUBCONFED))
                return 1;
    }
    return 0;
}

int
Bgp::bgp_cluster_filter (struct peer_conf *conf, struct attr *attr)
{
    struct in_addr cluster_id;

    /* Route reflection loop check. */
    if (attr->cluster)
    {
        if (conf->bgp->config & BGP_CONFIG_CLUSTER_ID)
            cluster_id = conf->bgp->cluster;
        else
            cluster_id = conf->bgp->id;

        if (cluster_loop_check (attr->cluster, cluster_id))
            return 1;
    }
    return 0;
}

void
Bgp::bgp_reset ()
{
    access_list_reset ();
    prefix_list_reset ();
}

/* Apply filters and return interned struct attr. */
int
Bgp::bgp_input_modifier (struct peer *peer, struct peer_conf *conf, 
                         struct prefix *p, struct attr *attr, afi_t afi, safi_t safi)
{
    struct bgp_filter *filter;
    struct bgp_info info;
    route_map_result_t ret;

    filter = &conf->filter[afi][safi];

    /* Apply default weight value. */
    attr->weight = peer->weight;

    /* Route map apply. */
    if (ROUTE_MAP_IN_NAME (filter))
    {
        /* Duplicate current value to New strucutre for modification. */
        info.peer = peer;
        info.attr = attr;

        /* Apply BGP route map to the attribute. */
        ret = route_map_apply (ROUTE_MAP_IN (filter), p, RMAP_BGP, &info);
        if (ret == RMAP_DENYMATCH)
        {
            /* Free newly generated AS path and community by route-map. */
            bgp_attr_flush (attr);
            return RMAP_DENY;
        }
    }
    return RMAP_PERMIT;
}

/* Set a route to Adj-RIBs-In or Adj-RIBs-Out.  In case of attr is
   NULL, it only store prefix information. */
int
Bgp::bgp_adj_set (struct bgp_table *table, struct prefix *p, struct attr *attr,
                  struct prefix_rd *prd, safi_t safi)
{
    struct bgp_node *rn;

    if (table == NULL)
        return 0;

    rn = route_node_get (table, p);
    if (rn->info)
    {
        if (rn->info != rn)
            bgp_attr_unintern (( struct attr * ) rn->info);
        route_unlock_node (rn);
    }

    if (attr)
        rn->info = bgp_attr_intern (attr);
    else
        rn->info = rn;

    return 0;
}

/* Unset a route from Adj-RIBs-In or Adj-RIBs-Out.  If bgp_adj_set()
   only store prefix information, this function detect it and properly
   unset it. */
int
Bgp::bgp_adj_unset (struct bgp_table *table, struct prefix *p,
                    struct prefix_rd *prd, safi_t safi)
{
    struct bgp_node *rn;

    if (table == NULL)
        return 0;

    rn = route_node_lookup (table, p);
    if (rn == NULL)
        return -1;

    if (rn->info != rn)
        bgp_attr_unintern ( ( struct attr * ) rn->info);
    rn->info = NULL;
    route_unlock_node (rn);
    route_unlock_node (rn);
    return 0;
}

/* Check the prefix is in Adj-RIBs-In or Adj-RIBs-Out. */
int
Bgp::bgp_adj_lookup (struct bgp_table *table, struct prefix *p,
                     struct prefix_rd *prd, safi_t safi)
{
    struct bgp_node *rn;
    struct bgp_node *rm;

    rn = NULL;

    if (table == NULL)
        return 1;


    rm = route_node_lookup (table, p);
    if (rm == NULL)
        return 0;

    route_unlock_node (rm);

    if (rn)
        route_unlock_node (rn);

    return 1;
}

/* Clear entire table. */
void
Bgp::bgp_adj_clear (struct bgp_table *table, safi_t safi)
{
    struct bgp_node *rn;

    if (table == NULL)
        return;

    for (rn = route_top (table); rn; rn = route_next (rn))
        if (rn->info)
        {
            if (rn->info != rn)
                bgp_attr_unintern (( struct attr * ) rn->info);
            rn->info = NULL;
            route_unlock_node (rn);
        }
}

int
Bgp::bgp_announce_check (struct bgp_info *ri, struct peer_conf *conf, 
                         struct prefix *p, struct attr *attr, afi_t afi, safi_t safi)
{
    int ret;
    char buf[SU_ADDRSTRLEN];
    struct bgp_filter *filter;
    struct bgp_info info;
    struct peer *peer;
    struct peer *from;
    struct bgp *bgp;
    struct attr dummy_attr;
    int transparent;

    from = ri->peer;
    peer = conf->peer;
    filter = &conf->filter[afi][safi];
    bgp = conf->bgp;

#ifdef DISABLE_BGP_ANNOUNCE
    return 0;
#endif


    /* Do not send back route to sender. */
    if (from == peer)
        return 0;

    /* Aggregate-address suppress check. */
    if (ri->suppress)
        return 0;

    /* If community is not disabled check the no-export and local. */
    if (bgp_community_filter (peer, ri->attr))
        return 0;

    /* If the attribute has originator-id and it is same as remote
       peer's id. */
    if (ri->attr->flag & ATTR_FLAG_BIT (BGP_ATTR_ORIGINATOR_ID))
    {
        if (IPV4_ADDR_SAME (&peer->remote_id, &ri->attr->originator_id))
        {
            if (BGP_DEBUG (filter, FILTER))
                zlog (peer->log, LOG_INFO,
                      "%s [Update:SEND] %s/%d originator-id is same as remote router-id\n",
                      peer->host,
                      Bgp::inet_ntop(p->family, &p->u.prefix, buf, SU_ADDRSTRLEN),
                      p->prefixlen);
            return 0;
        }
    }

    /* Output filter check. */
    if (bgp_output_filter (conf, p, ri->attr, afi, safi) == FILTER_DENY)
    {
        if (BGP_DEBUG (filter, FILTER))
            zlog (peer->log, LOG_INFO,
                  "%s [Update:SEND] %s/%d is filtered\n",
                  peer->host,
                  Bgp::inet_ntop(p->family, &p->u.prefix, buf, SU_ADDRSTRLEN),
                  p->prefixlen);
        return 0;
    }

    /* Default route check. */
    if (p->family == AF_INET && p->u.prefix4.s_addr == INADDR_ANY 
        && ! (CHECK_FLAG (peer->flags, PEER_FLAG_DEFAULT_ORIGINATE)))
    {
        if (BGP_DEBUG (filter, FILTER))
            zlog (peer->log, LOG_INFO,
                  "%s [Update:SEND] default route announcement is suppressed\n",
                  peer->host);
        return 0;
    }

    if (ssld) { 
      /* AS path loop check. */
      if (aspath_loop_check (ri->attr->aspath, peer->as))
	{
	  if (BGP_DEBUG (filter, FILTER))
            zlog (peer->log, LOG_INFO, 
                  "%s [Update:SEND] suppress announcement to peer AS %d is AS path.\n",
                  peer->host, peer->as);
	  return 0;
	}
    }
    
    /* If we're a CONFED we need to loop check the CONFED ID too */
    if (CHECK_FLAG(bgp->config, BGP_CONFIG_CONFEDERATION))
    {
        if (aspath_loop_check(ri->attr->aspath, bgp->confederation_id))
        {
            if (BGP_DEBUG (filter, FILTER))
                zlog (peer->log, LOG_INFO, 
                      "%s [Update:SEND] suppress announcement to peer AS %d is AS path.\n",
                      peer->host,
                      bgp->confederation_id);
            return 0;
        }
    }

    /* IBGP reflection check. */
    if (peer_sort (from) == BGP_PEER_IBGP && peer_sort (peer) == BGP_PEER_IBGP)
    {
        /* A route from a Client peer. */
        if (CHECK_FLAG (from->af_flags[afi][safi], PEER_FLAG_REFLECTOR_CLIENT))
        {
            /* Reflect to all the Non-Client peers and also to the
                   Client peers other than the originator.  Originator check
                   is already done.  So there is noting to do. */
            /* no bgp client-to-client reflection check. */
            if (CHECK_FLAG (bgp->config, BGP_CONFIG_NO_CLIENT_TO_CLIENT))
                if (CHECK_FLAG (peer->af_flags[afi][safi], PEER_FLAG_REFLECTOR_CLIENT))
                    return 0;
        } else
        {
            /* A route from a Non-client peer. Reflect to all other
               clients. */
            if (! CHECK_FLAG (peer->af_flags[afi][safi], PEER_FLAG_REFLECTOR_CLIENT))
                return 0;
        }
    }

    /* For modify attribute, copy it to temporary structure. */
    *attr = *ri->attr;

    /* If local-preference is not set. */
    if ((peer_sort (peer) == BGP_PEER_IBGP 
         || peer_sort (peer) == BGP_PEER_CONFED) 
        && (! (attr->flag & ATTR_FLAG_BIT (BGP_ATTR_LOCAL_PREF))))
    {
        attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_LOCAL_PREF);
        attr->local_pref = bgp->default_local_pref;
    }

    /* Transparency check. */
    if (CHECK_FLAG (peer->af_flags[afi][safi], PEER_FLAG_RSERVER_CLIENT)
        && CHECK_FLAG (from->af_flags[afi][safi], PEER_FLAG_RSERVER_CLIENT))
        transparent = 1;
    else
        transparent = 0;

    /* Remove MED if its an EBGP peer - will get overwritten by route-maps */
    if (transparent)
    {
        /* Route Server Clients are transparent MED.
       So there is noting to do. */
    } else
    {
        if (peer_sort (peer) == BGP_PEER_EBGP 
            && attr->flag & ATTR_FLAG_BIT (BGP_ATTR_MULTI_EXIT_DISC)
            && ri->peer != peer_self)
            attr->flag &= ~(ATTR_FLAG_BIT (BGP_ATTR_MULTI_EXIT_DISC));
    }

    /* next-hop-set */
    if (transparent || CHECK_FLAG (peer->flags, PEER_FLAG_TRANSPARENT_NEXTHOP))
    {
        /* Route Server Clients are transparent NEXT-HOP.
       So there is noting to do. */
    } else if (! (peer_sort (from) == BGP_PEER_IBGP
                  && peer_sort (peer) == BGP_PEER_IBGP))
    {
        if (CHECK_FLAG (peer->af_flags[afi][safi], PEER_FLAG_NEXTHOP_SELF)
            || (p->family == AF_INET && attr->nexthop.s_addr == 0)
            || ((peer_sort (peer) == BGP_PEER_EBGP)))
        {
            /* Set IPv4 nexthop. */
	  memcpy (&attr->nexthop, &peer->nexthop.v4, IPV4_MAX_BYTELEN);

        }
    }



    /* Route map apply. */
    if (ROUTE_MAP_OUT_NAME (filter))
    {
        info.peer = peer;
        info.attr = attr;

        /* The route reflector is not allowed to modify the attributes
       of the reflected IBGP routes. */
        if (peer_sort (from) == BGP_PEER_IBGP 
            && peer_sort (peer) == BGP_PEER_IBGP)
        {
            dummy_attr = *attr;
            info.attr = &dummy_attr;
        }

        ret = route_map_apply (ROUTE_MAP_OUT (filter), p, RMAP_BGP, &info);
        if (ret == RMAP_DENYMATCH)
        {
            bgp_attr_flush (attr);
            return 0;
        }
    }
    return 1;
}

#ifndef HAVE_ZEBRA_93b
/* Refresh routes conf->peer. */
void
Bgp::bgp_refresh_rib (struct peer_conf *conf, afi_t afi, safi_t safi)
{
    struct bgp_node *rn;
    struct bgp_info *ri;
    struct attr attr;

    for (rn = route_top (conf->bgp->rib[afi][safi]); rn; rn = route_next(rn))
        for (ri = ( struct bgp_info * ) rn->info; ri; ri = ri->next)
            if (CHECK_FLAG (ri->flags, BGP_INFO_SELECTED) && ri->peer != conf->peer)
            {
                if (bgp_announce_check (ri, conf, &rn->p, &attr, afi, safi))
		  {
                    bgp_update_send (conf, conf->peer, &rn->p, &attr, afi, safi,
                                     ri->peer, NULL, NULL);
                    bgp_adj_set (conf->peer->adj_out[afi][safi], &rn->p, &attr,
                                 NULL, safi);
		    
 		    if(mrai_type == MRAI_PER_PREFIX) bgp_update_add_timestamp(conf->peer,&rn->p);			
		    else if((mrai_type == MRAI_PER_PEER) && !conf->peer->t_routeadv) { 
		      /* if there is no pending timer start one */
		      BGP_TIMER_ON (conf->peer->t_routeadv,&Bgp::bgp_routeadv_timer,
				    conf->peer,conf->peer->v_routeadv);
		    }


		  } 
		else
		  {
		    
		    /* Rm any supressed update for withdrawn prefix */
		    bgp_withdraw_send_check(conf->peer,&rn->p);

                    /* Send withdraw to the peer */
                    if (bgp_adj_lookup (conf->peer->adj_out[afi][safi], &rn->p,
                                        NULL, safi))
                    {
		      bgp_withdraw_send (conf->peer, &rn->p, afi, safi, NULL,
                                           NULL);
		      bgp_adj_unset (conf->peer->adj_out[afi][safi], &rn->p, NULL,
                                       safi);
                    }
                }
            }
}


/* Announce current routing table to the peer when peer gets
   Established. */
void
Bgp::bgp_announce_table (struct peer *peer)
{
    struct listnode *nn;
    struct peer_conf *conf;
    for (nn = peer->conf->head; nn; nn = nn->next)
        if ((conf = ( struct peer_conf * ) nn->data) != NULL)
        {
            if (conf->peer->afc_nego[AFI_IP][SAFI_UNICAST])
                bgp_announce_rib (conf, AFI_IP, SAFI_UNICAST);
            //if (conf->peer->afc_nego[AFI_IP][SAFI_MULTICAST])
	    //  bgp_announce_rib (conf, AFI_IP, SAFI_MULTICAST);
	    //            if (conf->peer->afc_nego[AFI_IP6][SAFI_UNICAST])
	    //                bgp_announce_rib (conf, AFI_IP6, SAFI_UNICAST);
	    //            if (conf->peer->afc_nego[AFI_IP6][SAFI_MULTICAST])
	    //                bgp_announce_rib (conf, AFI_IP6, SAFI_MULTICAST);
        }
}

/* Announce selected routes to the conf->peer. */
void
Bgp::bgp_announce_rib (struct peer_conf *conf, afi_t afi, safi_t safi)
{
    struct bgp_node *rn;
    struct bgp_info *ri;
    struct attr attr;

    for (rn = route_top (conf->bgp->rib[afi][safi]); rn; rn = route_next(rn))
        for (ri = ( struct bgp_info * ) rn->info; ri; ri = ri->next)
        {
            if (CHECK_FLAG (ri->flags, BGP_INFO_SELECTED)
                && ri->peer != conf->peer)
                if (bgp_announce_check (ri, conf, &rn->p, &attr, afi, safi))
                {
                    bgp_update_send (conf, conf->peer, &rn->p, &attr, afi, safi,
                                     ri->peer, NULL, NULL);
		    
                    bgp_adj_set (conf->peer->adj_out[afi][safi], &rn->p, &attr,
                                 NULL, safi);
		    
		    if(mrai_type == MRAI_PER_PREFIX) bgp_update_add_timestamp(conf->peer,&rn->p);			
		    else if((mrai_type == MRAI_PER_PEER) && !conf->peer->t_routeadv) { 
		      /* if there is no pending timer start one */	
		      BGP_TIMER_ON (conf->peer->t_routeadv,&Bgp::bgp_routeadv_timer,
				    conf->peer,conf->peer->v_routeadv);
		    }
		    
		}
        }
}



#else

void
Bgp::bgp_announce_table (struct peer *peer, afi_t afi, safi_t safi,
			 struct bgp_table *table)
{
  struct bgp_node *rn;
  struct bgp_info *ri;
  struct attr attr;
  struct listnode *nn;
  struct peer_conf *conf;
  struct bgp* bgp;

  if (! table){ 
    bgp = bgp_get_default();
    table = bgp->rib[afi][safi];
  }

  for (nn = peer->conf->head; nn; nn = nn->next)
    if ((conf = ( struct peer_conf * ) nn->data) != NULL) {

      for (rn = bgp_table_top (table); rn; rn = bgp_route_next(rn))
	for (ri = (struct bgp_info*) rn->info; ri; ri = ri->next)
	  if (CHECK_FLAG (ri->flags, BGP_INFO_SELECTED) && ri->peer != peer)
	    {
	      if (bgp_announce_check (ri, conf, &rn->p, &attr, afi, safi))
		bgp_adj_out_set (rn, peer, &rn->p, &attr, afi, safi, ri);
	      else
		bgp_adj_out_unset (rn, peer, &rn->p, afi, safi);
	    }
    }
}

void
Bgp::bgp_announce_route (struct peer *peer, afi_t afi, safi_t safi)
{
  struct bgp_node *rn;
  struct bgp_table *table;

  if (peer->status != Established)
    return;

  if (! peer->afc_nego[afi][safi])
    return;
  
  bgp_announce_table (peer, afi, safi, NULL);
}

#endif

/* Get fist node and lock it.  This function is useful when one want
   to lookup all the node exist in the routing table. */
struct bgp_node *
Bgp::bgp_table_top (struct bgp_table *table)
{
  /* If there is no node in the routing table return NULL. */
  if (table->top == NULL)
    return NULL;

  /* Lock the top node and return it. */
  route_lock_node (table->top);
  return table->top;
}

#ifdef HAVE_ZEBRA_93b
void
Bgp::bgp_announce_route_all (struct peer *peer)
{
  afi_t afi;
  safi_t safi;
  
  for (afi = AFI_IP; afi < AFI_MAX; afi++)
    for (safi = SAFI_UNICAST; safi < SAFI_MAX; safi++)
      bgp_announce_route (peer, afi, safi);
}

#endif

/* Unlock current node and lock next node then return it. */
struct bgp_node *
Bgp::bgp_route_next (struct bgp_node *node)
{
  struct bgp_node *next;
  struct bgp_node *start;

  /* Node may be deleted from route_unlock_node so we have to preserve
     next node's pointer. */

  if (node->l_left)
    {
      next = node->l_left;
      route_lock_node (next);
      route_unlock_node (node);
      return next;
    }
  if (node->l_right)
    {
      next = node->l_right;
      route_lock_node (next);
      route_unlock_node (node);
      return next;
    }

  start = node;
  while (node->parent)
    {
      if (node->parent->l_left == node && node->parent->l_right)
	{
	  next = node->parent->l_right;
	  route_lock_node (next);
	  route_unlock_node (start);
	  return next;
	}
      node = node->parent;
    }
  route_unlock_node (start);
  return NULL;
}

#ifndef HAVE_ZEBRA_93b
/* Announce current routing table to the peer when peer gets
   Established. */
void
Bgp::bgp_refresh_table (struct peer *peer, afi_t afi, safi_t safi)
{
    struct listnode *nn;
    struct peer_conf *conf;
    for (nn = peer->conf->head; nn; nn = nn->next) \
        if ((conf =( struct peer_conf * )  nn->data) != NULL)
        {
            if (conf->peer->afc_nego[afi][safi])
            {
	      bgp_refresh_rib (conf, afi, safi);
            }
        }
}

/* Process changed routing entry. */
int
Bgp::bgp_process (struct bgp *bgp, struct bgp_node *rn, afi_t afi, safi_t safi,
                  struct bgp_info *del, struct prefix_rd *prd, u_char *tag)
{
    struct prefix *p;
    struct bgp_info *ri;
    struct bgp_info *new_select;
    struct bgp_info *old_select;
    struct listnode *nn;
    struct peer_conf *conf_to;
    struct peer *peer_to;
    struct attr attr;
    struct bgp_info *ri1;
    struct bgp_info *ri2;
    struct bgp *dummy;

    memset(&attr,0,sizeof(struct attr));
    p = &rn->p;

    /* Save the BGP instance in a global array to be used for 
	dumping bgp tables after convergence */
    dummy = bgp_get_default();
    bgp_instances[dummy->as] = dummy; 

    /* bgp deterministic-med */
    new_select = NULL;
    if (CHECK_FLAG (bgp->config, BGP_CONFIG_DETERMINISTIC_MED))
        for (ri1 = ( struct bgp_info * )  rn->info; ri1; ri1 = ri1->next)
        {
            if (CHECK_FLAG (ri1->flags, BGP_INFO_DMED_CHECK))
                continue;
            if (BGP_INFO_HOLDDOWN (ri1))
                continue;

            new_select = ri1;
            if (ri1->next)
                for (ri2 = ri1->next; ri2; ri2 = ri2->next)
                {
                    if (CHECK_FLAG (ri2->flags, BGP_INFO_DMED_CHECK))
                        continue;
                    if (BGP_INFO_HOLDDOWN (ri2))
                        continue;

                    if (aspath_cmp_left (ri1->attr->aspath, ri2->attr->aspath)
                        || aspath_cmp_left_confed (ri1->attr->aspath,
                                                   ri2->attr->aspath))
                    {
                        if (bgp_info_cmp (bgp, ri2, new_select))
                        {
                            UNSET_FLAG (new_select->flags, BGP_INFO_DMED_SELECTED);
                            new_select = ri2;
                        }

                        SET_FLAG (ri2->flags, BGP_INFO_DMED_CHECK);
                    }
                }
            SET_FLAG (new_select->flags, BGP_INFO_DMED_CHECK);
            SET_FLAG (new_select->flags, BGP_INFO_DMED_SELECTED);
        }

    /* Check old selected route and New selected route. */
    old_select = NULL;
    new_select = NULL;
    for (ri = ( struct bgp_info * )  rn->info; ri; ri = ri->next)
    {
        if (CHECK_FLAG (ri->flags, BGP_INFO_SELECTED))
            old_select = ri;

        if (BGP_INFO_HOLDDOWN (ri))
            continue;

        if (CHECK_FLAG (bgp->config, BGP_CONFIG_DETERMINISTIC_MED)
            && (! CHECK_FLAG (ri->flags, BGP_INFO_DMED_SELECTED)))
        {
            UNSET_FLAG (ri->flags, BGP_INFO_DMED_CHECK);
            continue;
        }
        UNSET_FLAG (ri->flags, BGP_INFO_DMED_CHECK);
        UNSET_FLAG (ri->flags, BGP_INFO_DMED_SELECTED);

        if (bgp_info_cmp (bgp, ri, new_select))
            new_select = ri;
    }

    /* Nothing to do. */
    if (old_select && old_select == new_select)
    {
        if (! CHECK_FLAG (old_select->flags, BGP_INFO_ATTR_CHANGED))
        {
            return 0;
        }
    }

    if (old_select)
        UNSET_FLAG (old_select->flags, BGP_INFO_SELECTED);
    if (new_select)
    {
        SET_FLAG (new_select->flags, BGP_INFO_SELECTED);
        UNSET_FLAG (new_select->flags, BGP_INFO_ATTR_CHANGED);
    }

    /* Check each BGP peer. */
    for (nn = bgp->peer_conf->head; nn; nn = nn->next)
        if ((conf_to = ( struct peer_conf * ) nn->data) != NULL)
        {
            peer_to = conf_to->peer;

            /* Announce route to Established peer. */
            if (peer_to->status != Established)
                continue;

            /* Address family configuration check. */
            if (! conf_to->peer->afc_nego[afi][safi])
                continue;

            /* Announcement to peer->conf.  If the route is filtered,
               withdraw it. */
            if (new_select 
                && bgp_announce_check (new_select, conf_to, p, &attr, afi, safi))
            {
                /* Send update to the peer. */
	      if(bgp_update_send_check(new_select,conf_to,peer_to,p,&attr,afi,safi,
				       new_select->peer,prd,tag)) {

                bgp_update_send (conf_to, peer_to, p, &attr, afi, safi,
                                 new_select->peer, prd, tag);
		/* For per prefix mrai */ 
		if(mrai_type == MRAI_PER_PREFIX) bgp_update_add_timestamp(peer_to,p);
		
		/* Update adj_out */
		bgp_adj_set (peer_to->adj_out[afi][safi], p, &attr, prd, safi);
	      }		

            } else
            {
	      
	      /* Rm any supressed update for withdrawn prefix */
	      bgp_withdraw_send_check(peer_to,p);

	      /* Send withdraw to the peer */
	      if (bgp_adj_lookup (peer_to->adj_out[afi][safi], p, prd, safi))
                {
		  bgp_withdraw_send (peer_to, p, afi, safi, prd, tag);
		  bgp_adj_unset (peer_to->adj_out[afi][safi], p, prd, safi);
                }
            }
        }
    return 0;
}
#else 

int
Bgp::bgp_process (struct bgp *bgp, struct bgp_node *rn, afi_t afi, safi_t safi,
		  struct bgp_info *del, struct prefix_rd *prd, u_char *tag)
{
  struct prefix *p;
  struct bgp_info *ri;
  struct bgp_info *new_select;
  struct bgp_info *old_select;
  struct listnode *nn;
  struct peer_conf *conf_to;
  struct peer *peer_to;
  struct attr attr;
  struct bgp_info *ri1;
  struct bgp_info *ri2;

  p = &rn->p;

  /* bgp deterministic-med */
  new_select = NULL;
  if (CHECK_FLAG (bgp->config, BGP_CONFIG_DETERMINISTIC_MED))
    for (ri1 = (struct bgp_info *) rn->info; ri1; ri1 = ri1->next)
      {
	if (CHECK_FLAG (ri1->flags, BGP_INFO_DMED_CHECK))
	  continue;
	if (BGP_INFO_HOLDDOWN (ri1))
	  continue;

	new_select = ri1;
	if (ri1->next)
	  for (ri2 = ri1->next; ri2; ri2 = ri2->next)
	    {
	      if (CHECK_FLAG (ri2->flags, BGP_INFO_DMED_CHECK))
		continue;
	      if (BGP_INFO_HOLDDOWN (ri2))
		continue;

	      if (aspath_cmp_left (ri1->attr->aspath, ri2->attr->aspath)
		  || aspath_cmp_left_confed (ri1->attr->aspath,
					     ri2->attr->aspath))
		{
		  if (bgp_info_cmp (bgp, ri2, new_select))
		    {
		      UNSET_FLAG (new_select->flags, BGP_INFO_DMED_SELECTED);
		      new_select = ri2;
		    }

		  SET_FLAG (ri2->flags, BGP_INFO_DMED_CHECK);
		}
	    }
	SET_FLAG (new_select->flags, BGP_INFO_DMED_CHECK);
	SET_FLAG (new_select->flags, BGP_INFO_DMED_SELECTED);
      }

  /* Check old selected route and new selected route. */
  old_select = NULL;
  new_select = NULL;
  for (ri =(struct bgp_info *) rn->info; ri; ri = ri->next)
    {
      if (CHECK_FLAG (ri->flags, BGP_INFO_SELECTED))
	old_select = ri;

      if (BGP_INFO_HOLDDOWN (ri))
	continue;

      if (CHECK_FLAG (bgp->config, BGP_CONFIG_DETERMINISTIC_MED)
          && (! CHECK_FLAG (ri->flags, BGP_INFO_DMED_SELECTED)))
	{
	  UNSET_FLAG (ri->flags, BGP_INFO_DMED_CHECK);
	  continue;
        }
      UNSET_FLAG (ri->flags, BGP_INFO_DMED_CHECK);
      UNSET_FLAG (ri->flags, BGP_INFO_DMED_SELECTED);

      if (bgp_info_cmp (bgp, ri, new_select))
	new_select = ri;
    }

  /* Nothing to do. */
  if (old_select && old_select == new_select)
    {
      if (! CHECK_FLAG (old_select->flags, BGP_INFO_ATTR_CHANGED))
	{
	  return 0;
	}
    }

  if (old_select)
    UNSET_FLAG (old_select->flags, BGP_INFO_SELECTED);
  if (new_select)
    {
      SET_FLAG (new_select->flags, BGP_INFO_SELECTED);
      UNSET_FLAG (new_select->flags, BGP_INFO_ATTR_CHANGED);
    }

  /* Check each BGP peer. */
  for (nn = bgp->peer_conf->head; nn; nn = nn->next)
    if ((conf_to = ( struct peer_conf * ) nn->data) != NULL)
      {
	peer_to = conf_to->peer;

      /* Announce route to Established peer. */
      if (peer_to->status != Established)
	continue;

      /* Address family configuration check. */
      if (! conf_to->peer->afc_nego[afi][safi])
	continue;

      /* Announcement to peer->conf.  If the route is filtered,
         withdraw it. */
      if (new_select 
	  && bgp_announce_check (new_select, conf_to, p, &attr, afi, safi))
	{
	  /* Send update to the peer. */
	bgp_adj_out_set (rn, peer_to, p, &attr, afi, safi, new_select);
	
	}
      else
	{
	bgp_adj_out_unset (rn, peer_to, p, afi, safi);
	}
    }

  return 0;
}
#endif /*HAVE_ZEBRA_93b*/


/* maximum-prefix check. */
int
Bgp::bgp_maximum_prefix_overflow (struct peer_conf *conf, afi_t afi, safi_t safi)
{
    struct peer *peer;

    if (conf->pmax[afi][safi]
        && conf->pcount[afi][safi] >= conf->pmax[afi][safi])
    {
        peer = conf->peer;
        zlog (peer->log, LOG_INFO,
              "MAXPFXEXCEED: No. of prefix received from %s (afi %d): %ld exceed limit %ld\n",
              peer->host, afi, conf->pcount[afi][safi], conf->pmax[afi][safi]);
        if (! conf->pmax_warning[afi][safi])
        {
            BGP_EVENT_ADD (peer, BGP_Stop);
            SET_FLAG (peer->sflags, PEER_STATUS_PREFIX_OVERFLOW);
            return 1;
        }
    }
    return 0;
}

void
Bgp::bgp_implicit_withdraw (struct peer_conf *conf, struct bgp *bgp,
                            struct prefix *p, struct bgp_info *ri,
                            struct bgp_node *rn, afi_t afi, safi_t safi)
{
    conf->pcount[afi][safi]--;
    bgp_aggregate_decrement (bgp, p, ri, afi, safi);
    bgp_info_delete ((struct bgp_info **) &rn->info, ri);
    bgp_info_free (ri);
    route_unlock_node (rn);
}


#ifdef HAVE_ZEBRA_93b
int
Bgp::bgp_update (struct peer *peer, struct prefix *p, struct attr *attr, 
		 afi_t afi, safi_t safi, int type, int sub_type,
		 struct prefix_rd *prd, u_char *tag, int soft_reconfig)
{
  int ret;
  struct listnode *nn;
  int aspath_loop_count = 0;
  struct bgp_node *rn;
  struct bgp *bgp;
  struct attr new_attr;
  struct attr *attr_new;
  struct bgp_info *ri;
  struct bgp_info *New;
  struct peer_conf *conf;
  char *reason;
  char buf[SU_ADDRSTRLEN];


  /* Kick each configuration BGP instance. */
  for (nn = peer->conf->head; nn; nn = nn->next)                
    if ((conf = ( struct peer_conf * ) nn->data) != NULL)
      {
	bgp = conf->bgp;
	rn = bgp_route_node_get (bgp, afi, safi, p, prd);

	/* When peer's soft reconfiguration enabled.  Record input packet in
	   Adj-RIBs-In.  */
	if (CHECK_FLAG (peer->af_flags[afi][safi], PEER_FLAG_SOFT_RECONFIG)
	    && peer != peer_self && ! soft_reconfig)
	  bgp_adj_in_set (rn, peer, attr);

	/* Check previously received route. */
	for (ri = (bgp_info *)rn->info; ri; ri = ri->next)
	  if (ri->peer == peer && ri->type == type && ri->sub_type == sub_type)
	    break;


	/* AS path loop check. */	
	if (aspath_loop_check (attr->aspath, bgp->as) 
	    || (CHECK_FLAG(bgp->config, BGP_CONFIG_CONFEDERATION)
		&& aspath_loop_check(attr->aspath, bgp->confederation_id)))
	  {
	    reason = "as-path contains our own AS;";
	    goto filtered;
	  }

	/* Route reflector originator ID check.  */
	if (attr->flag & ATTR_FLAG_BIT (BGP_ATTR_ORIGINATOR_ID)
	    && IPV4_ADDR_SAME (&bgp->id, &attr->originator_id))
	  {
	    reason = "originator is us;";
	    goto filtered;
	  }

	/* Route reflector cluster ID check.  */
	if (bgp_cluster_filter (conf, attr))
	  {
	    reason = "reflected from the same cluster;";
	    goto  filtered;
	  }

	/* Apply incoming filter.  */
	if (bgp_input_filter (conf, p, attr, afi, safi) == FILTER_DENY)
	  {
	    reason = "filter;";
	    goto filtered;
	  }

	/* Apply incoming route-map. */
	new_attr = *attr;

	if (bgp_input_modifier (peer, conf, p, &new_attr, afi, safi) == RMAP_DENY)
	  {
	    reason = "route-map;";
	    goto filtered;
	  }

	/* IPv4 unicast next hop check.  */
	//  we dont check any more if the peer is connected

	attr_new = bgp_attr_intern (&new_attr);

	/* If the update is implicit withdraw. */
	if (ri)
	  {
	    ri->uptime = (int) NOW + start_time;

	    /* Same attribute comes in. */
	    if (attrhash_cmp (ri->attr, attr_new))
	      {
		UNSET_FLAG (ri->flags, BGP_INFO_ATTR_CHANGED);

		if (CHECK_FLAG (bgp->config, BGP_CONFIG_DAMPENING)
		    && peer_sort (peer) == BGP_PEER_EBGP
		    && CHECK_FLAG (ri->flags, BGP_INFO_HISTORY))
		  {
		    if (BGP_DEBUG (update, UPDATE_IN))  
		      zlog (peer->log, LOG_INFO, "%s rcvd %s/%d\n",
			    peer->host,
			    inet_ntop(p->family, &p->u.prefix, buf, SU_ADDRSTRLEN),
			    p->prefixlen);

		    conf->pcount[afi][safi]++;
		    ret = bgp_damp_update (ri, rn, afi, safi);
		    if (ret != BGP_DAMP_SUPPRESSED)
		      {
			bgp_aggregate_increment (bgp, p, ri, afi, safi);
			bgp_process (bgp, rn, afi, safi, NULL, prd, tag);
		      }
		  }
		else
		  {
		    if (BGP_DEBUG (update, UPDATE_IN))  
		      zlog (peer->log, LOG_INFO,
			    "%s rcvd %s/%d...duplicate ignored\n",
			    peer->host,
			    inet_ntop(p->family, &p->u.prefix, buf, SU_ADDRSTRLEN),
			    p->prefixlen);
		  }

		route_unlock_node (rn);
		bgp_attr_unintern (attr_new);
		return 0;
	      }

	    /* Received Logging. */
	    if (BGP_DEBUG (update, UPDATE_IN))  
	      zlog (peer->log, LOG_INFO, "%s rcvd %s/%d\n",
		    peer->host,
		    inet_ntop(p->family, &p->u.prefix, buf, SU_ADDRSTRLEN),
		    p->prefixlen);

	    /* The attribute is changed. */
	    SET_FLAG (ri->flags, BGP_INFO_ATTR_CHANGED);

	    /* Update bgp route dampening information.  */
  	    if (CHECK_FLAG (bgp->config, BGP_CONFIG_DAMPENING)
		&& peer_sort (peer) == BGP_PEER_EBGP)
	      {
		/* This is implicit withdraw so we should update dampening
		   information.  */
		if (! CHECK_FLAG (ri->flags, BGP_INFO_HISTORY))
		  bgp_damp_withdraw (ri, rn, afi, safi, 1);  
		else
		  conf->pcount[afi][safi]++;
	      }
	
	    bgp_aggregate_decrement (bgp, p, ri, afi, safi);

	    /* Update to new attribute.  */
	    bgp_attr_unintern (ri->attr);
	    ri->attr = attr_new;

	    /* Update bgp route dampening information.  */
	    if (CHECK_FLAG (bgp->config, BGP_CONFIG_DAMPENING)
		&& peer_sort (peer) == BGP_PEER_EBGP)
	      {
		/* Now we do normal update dampening.  */
		ret = bgp_damp_update (ri, rn, afi, safi);
		if (ret == BGP_DAMP_SUPPRESSED)
		  {
		    route_unlock_node (rn);
		    return 0;
		  }
	      }

	    /* Nexthop reachability check. */
	    /*reachability check is not done*/
	    SET_FLAG (ri->flags, BGP_INFO_VALID);

	    /* Process change. */
	    bgp_aggregate_increment (bgp, p, ri, afi, safi);

	    bgp_process (bgp, rn, afi, safi, NULL, prd, tag);
	    route_unlock_node (rn);
	    return 0;
	  }

	/* Received Logging. */
	if (BGP_DEBUG (update, UPDATE_IN))  
	  {
	    zlog (peer->log, LOG_INFO, "%s rcvd %s/%d\n",
		  peer->host,
		  inet_ntop(p->family, &p->u.prefix, buf, SU_ADDRSTRLEN),
		  p->prefixlen);
	  }

	/* Increment prefix counter */
	conf->pcount[afi][safi]++;

	/* Make new BGP info. */
	New = bgp_info_new ();
	New->type = type;
	New->sub_type = sub_type;
	New->peer = peer;
	New->attr = attr_new;
	New->uptime =(int) NOW + start_time;


	/* Nexthop reachability check. */
	SET_FLAG (New->flags, BGP_INFO_VALID);

	/* Aggregate address increment. */
	bgp_aggregate_increment (bgp, p, New, afi, safi);
  
	/* Register new BGP information. */
	bgp_info_add ((struct bgp_info**)&rn->info, New);

	/* If maximum prefix count is configured and current prefix
	   count exeed it. */
	if (!conf->pmax_warning[afi][safi])	
	  if (bgp_maximum_prefix_overflow (conf, afi, safi))
	    return -1;

	/* Process change. */
	bgp_process (bgp, rn, afi, safi,NULL ,prd ,tag );

	return 0;
      }

  /* This BGP update is filtered.  Log the reason then update BGP
     entry.  */
 filtered:
  if (BGP_DEBUG (update, UPDATE_IN))
    zlog (peer->log, LOG_INFO,
	  "%s rcvd UPDATE about %s/%d -- DENIED due to: %s\n",
	  peer->host,
	  inet_ntop (p->family, &p->u.prefix, buf, SU_ADDRSTRLEN),
	  p->prefixlen, reason);
  
  if (ri)
    bgp_rib_withdraw (rn, ri, peer, afi, safi, 1);
  
  route_unlock_node (rn);
  
  return 0;
  

}

void
Bgp::bgp_rib_withdraw (struct bgp_node *rn, struct bgp_info *ri, struct peer *peer,
		       afi_t afi, safi_t safi, int force)
{
  int valid;
  int status = BGP_DAMP_NONE;
  struct listnode * nm;
  struct peer_conf* conf;
  struct bgp* bgp = bgp_get_default();

  if (! CHECK_FLAG (ri->flags, BGP_INFO_HISTORY))
    {
      for (nm = peer->conf->head; nm; nm = nm->next)
	if ((conf = ( struct peer_conf * ) nm->data) != NULL)
	  conf->pcount[afi][safi]--;

      bgp_aggregate_decrement (bgp, &rn->p, ri, afi, safi);
    }

  if (! force)
    {
      if (CHECK_FLAG (bgp->config, BGP_CONFIG_DAMPENING)
	  && peer_sort (peer) == BGP_PEER_EBGP)
	status = bgp_damp_withdraw (ri, rn, afi, safi, 0);

      if (status == BGP_DAMP_SUPPRESSED)
	return;
    }

  valid = CHECK_FLAG (ri->flags, BGP_INFO_VALID);
  UNSET_FLAG (ri->flags, BGP_INFO_VALID);
  bgp_process (bgp, rn, afi, safi, NULL, NULL, NULL);

  if (valid)
    SET_FLAG (ri->flags, BGP_INFO_VALID);

  if (status != BGP_DAMP_USED)
    {
      bgp_info_delete ((struct bgp_info **)&rn->info, ri);
      bgp_info_free (ri);
      route_unlock_node (rn);
    }
}


#else 
/* Generic function for update BGP information.  This function only
   update routing table information.  To announce change we have to
   call bgp_process(). */
int
Bgp::bgp_update (struct peer *peer, struct prefix *p, struct attr *attr, 
                 afi_t afi, safi_t safi, int type, int sub_type,
                 struct prefix_rd *prd, u_char *tag, int soft_reconfig)
{
    struct listnode *nn;
    struct bgp_node *rn;
    struct bgp *bgp;
    struct peer_conf *conf;
    struct attr new_attr;
    struct bgp_info *ri;
    struct bgp_info *New;
    char buf[SU_ADDRSTRLEN];


    /* Check this route's origin is not static/aggregate/redistributed
       routes. */
    if (peer != peer_self && ! soft_reconfig)
    {
        /* If peer is soft reconfiguration enabled.  Record input packet for
       further calculation. */
        if (CHECK_FLAG (peer->af_flags[afi][safi], PEER_FLAG_SOFT_RECONFIG))
            bgp_adj_set (peer->adj_in[afi][safi], p, attr, prd, safi);
    }

    /* Kick each configuration BGP instance. */
    for (nn = peer->conf->head; nn; nn = nn->next)                
      if ((conf = ( struct peer_conf * ) nn->data) != NULL)
        {
            bgp = conf->bgp;

            /* Lookup node. */
            rn = bgp_route_node_get (bgp, afi, safi, p, prd);

            /* Check selected route and self inserted route. */
            for (ri = ( struct bgp_info * ) rn->info; ri; ri = ri->next)
                if (ri->peer == peer && ri->type == type && ri->sub_type == sub_type)
                    break;

                /* Aspath loop check. */
            if (aspath_loop_check (attr->aspath, bgp->as)
                || (CHECK_FLAG(bgp->config, BGP_CONFIG_CONFEDERATION)
                    && aspath_loop_check(attr->aspath, bgp->confederation_id)))
            {
                /* If the update is implicit withdraw. */
                if (ri)
                    bgp_implicit_withdraw (conf, bgp, p, ri, rn, afi, safi);

                if (BGP_DEBUG (update, UPDATE_IN))
                    zlog (peer->log, LOG_INFO, 
                          "%s rcvd UPDATE about %s/%d -- DENIED due to: as-path contains our own AS;\n",
                          peer->host,
                          Bgp::inet_ntop (p->family, &p->u.prefix, buf, SU_ADDRSTRLEN),
                          p->prefixlen);
                /* Process change. */
                bgp_process (bgp, rn, afi, safi, NULL, prd, tag);
                route_unlock_node (rn);
                continue;
            }

            /* Route reflector originator ID check. */
            if (attr->flag & ATTR_FLAG_BIT (BGP_ATTR_ORIGINATOR_ID)
                && IPV4_ADDR_SAME (&bgp->id, &attr->originator_id))
            {
                /* If the update is implicit withdraw. */
                if (ri)
                    bgp_implicit_withdraw (conf, bgp, p, ri, rn, afi, safi);

                if (BGP_DEBUG (update, UPDATE_IN))
                    zlog (peer->log, LOG_INFO, 
                          "%s rcvd UPDATE about %s/%d -- DENIED due to: originator is us;\n",
                          peer->host,
                          Bgp::inet_ntop (p->family, &p->u.prefix, buf, SU_ADDRSTRLEN),
                          p->prefixlen);
                /* Process change. */
                bgp_process (bgp, rn, afi, safi, NULL, prd, tag);
                route_unlock_node (rn);
                continue;
            }

            /* Route reflector cluster ID check. */
            if (bgp_cluster_filter (conf, attr))
            {
                /* If the update is implicit withdraw. */
                if (ri)
                    bgp_implicit_withdraw (conf, bgp, p, ri, rn, afi, safi);

                if (BGP_DEBUG (update, UPDATE_IN))
                    zlog (peer->log, LOG_INFO, 
                          "%s rcvd UPDATE about %s/%d -- DENIED due to: reflected from the same cluster;\n",
                          peer->host,
                          Bgp::inet_ntop (p->family, &p->u.prefix, buf, SU_ADDRSTRLEN),
                          p->prefixlen);
                /* Process change. */
                bgp_process (bgp, rn, afi, safi, NULL, prd, tag);
                route_unlock_node (rn);
                continue;
            }

            /* Apply input filter and route-map.  Filter and route-map
               application logging is also don in the function. */
            if (bgp_input_filter (conf, p, attr, afi, safi) == FILTER_DENY)
            {
                /* If the update is implicit withdraw. */
                if (ri)
                    bgp_implicit_withdraw (conf, bgp, p, ri, rn, afi, safi);

                if (BGP_DEBUG (update, UPDATE_IN))
                {
                    zlog (peer->log, LOG_INFO,
                          "%s rcvd UPDATE about %s/%d -- DENIED due to: filter;\n",
                          peer->host,
                          Bgp::inet_ntop(p->family, &p->u.prefix, buf, SU_ADDRSTRLEN),
                          p->prefixlen);
                }
                /* Process change. */
                bgp_process (bgp, rn, afi, safi, NULL, prd, tag);
                route_unlock_node (rn);
                continue;
            }

            /* Apply input route-map. */
            new_attr = *attr;

            if (bgp_input_modifier (peer, conf, p, &new_attr, afi, safi) == RMAP_DENY)
            {
                /* If the update is implicit withdraw. */
                if (ri)
                    bgp_implicit_withdraw (conf, bgp, p, ri, rn, afi, safi);

                if (BGP_DEBUG (update, UPDATE_IN))
                {
                    zlog (peer->log, LOG_INFO,
                          "%s rcvd UPDATE about %s/%d -- DENIED due to: route-map;\n",
                          peer->host,
                          Bgp::inet_ntop(p->family, &p->u.prefix, buf, SU_ADDRSTRLEN),
                          p->prefixlen);
                }
                /* Process change. */
                bgp_process (bgp, rn, afi, safi, NULL, prd, tag);
                route_unlock_node (rn);
                continue;
            }

            /* If the peer is EBGP and nexthop is not on connected route,
               discard it.  */
            if (afi == AFI_IP && safi == SAFI_UNICAST
                && peer_sort (peer) == BGP_PEER_EBGP && peer->ttl == 1)
            {
	      //  we dont check any more if the peer is connected
            }

            /* Check nexthop. */
            if (afi == AFI_IP && safi == SAFI_UNICAST)
            {
	      if ( new_attr.nexthop.s_addr == 0
		  || ntohl (new_attr.nexthop.s_addr) >= 0xe0000000)
                {
                    /* Debug information. */
                    if (BGP_DEBUG (update, UPDATE_IN))
                    {
                        zlog (peer->log, LOG_INFO,
                              "%s rcvd UPDATE about %s/%d -- DENIED due to: martian next-hop;\n",
                              peer->host,
                              Bgp::inet_ntop(p->family, &p->u.prefix, buf, SU_ADDRSTRLEN),
                              p->prefixlen);
                    }

                    /* Perform implicit withdraw. */
                    if (ri)
                        bgp_implicit_withdraw (conf, bgp, p, ri, rn, afi, safi);

                    /* Process change. */
                    bgp_process (bgp, rn, afi, safi, NULL, prd, tag);
                    route_unlock_node (rn);
                    continue;
                }
            }

            /* If the update is implicit withdraw. */
            if (ri)
            {
                /* Update BGP flap dampening information. */
                if (ri->bgp_damp_info)
                    bgp_damp_update (ri);

                /* Same attribute comes in. */
                if (! CHECK_FLAG (ri->flags, BGP_INFO_HISTORY)
                    && Bgp::attrhash_cmp (ri->attr, &new_attr))
                {
                    UNSET_FLAG (ri->flags, BGP_INFO_ATTR_CHANGED);

                    if (BGP_DEBUG (update, UPDATE_IN))
                        zlog (peer->log, LOG_INFO,
                              "%s rcvd %s/%d...duplicate ignored\n",
                              peer->host,
                              Bgp::inet_ntop(p->family, &p->u.prefix, buf, SU_ADDRSTRLEN),
                              p->prefixlen);
		    
		    double simulation_time;
		    simulation_time = Scheduler::instance().clock();
		    time_t clock = (int)simulation_time + start_time;
                    ri->uptime = clock;
                    bgp_process (bgp, rn, afi, safi, NULL, prd, tag);
                    route_unlock_node (rn);
                    continue;
                }


                /* Received Logging. */
                if (BGP_DEBUG (update, UPDATE_IN))
                    zlog (peer->log, LOG_INFO, "%s rcvd %s/%d\n",
                          peer->host,
                          Bgp::inet_ntop(p->family, &p->u.prefix, buf, SU_ADDRSTRLEN),
                          p->prefixlen);

                /* The attribute is changed. */
                SET_FLAG (ri->flags, BGP_INFO_ATTR_CHANGED);

                if (CHECK_FLAG (ri->flags, BGP_INFO_HISTORY))
                {
                    UNSET_FLAG (ri->flags, BGP_INFO_HISTORY);
                    conf->pcount[afi][safi]++;
                }

                /* Rewrite BGP route information. */
                bgp_aggregate_decrement (bgp, p, ri, afi, safi);
                bgp_attr_unintern (ri->attr);
                ri->attr = bgp_attr_intern (&new_attr);
		double simulation_time;
		simulation_time = Scheduler::instance().clock();
		time_t clock = (int)simulation_time + start_time;
                ri->uptime = clock;

                /* Nexthop reachability check.disabled */
		SET_FLAG (ri->flags, BGP_INFO_VALID);

                /* Process change. */
                bgp_aggregate_increment (bgp, p, ri, afi, safi);
                bgp_process (bgp, rn, afi, safi, NULL, prd, tag);
                route_unlock_node (rn);
                continue;
            }

            /* Received Logging. */
            if (BGP_DEBUG (update, UPDATE_IN))
            {
                zlog (peer->log, LOG_INFO, "%s rcvd %s/%d\n",
                      peer->host,
                      Bgp::inet_ntop(p->family, &p->u.prefix, buf, SU_ADDRSTRLEN),
                      p->prefixlen);
            }

            /* Increment prefix counter */
            conf->pcount[afi][safi]++;

            /* Make New BGP info. */
            New = bgp_info_new ();
            New->type = type;
            New->sub_type = sub_type;
            New->peer = peer;
            New->attr = bgp_attr_intern (&new_attr);

	    double simulation_time;
	    simulation_time = Scheduler::instance().clock();
            New->uptime = (int)simulation_time + start_time;;

            /* Nexthop reachability check. */
	    SET_FLAG (New->flags, BGP_INFO_VALID);

            /* Aggregate address increment. */
            bgp_aggregate_increment (bgp, p, New, afi, safi);

            /* Register New BGP information. */
            bgp_info_add ((struct bgp_info **) &rn->info, New);

            /* If maximum prefix count is configured and current prefix
           count exeed it. */
            if (! conf->pmax_warning[afi][safi])
                if (bgp_maximum_prefix_overflow (conf, afi, safi))
                    return -1;

                /* Process change. */
            bgp_process (bgp, rn, afi, safi, NULL, prd, tag);
        }
    return 0;
}
#endif
/* Generic function for withdraw BGP information */
#ifdef HAVE_ZEBRA_93b

int
Bgp::bgp_withdraw (struct peer *peer, struct prefix *p, struct attr *attr, 
		   int afi, int safi, int type, int sub_type, struct prefix_rd *prd,
		   u_char *tag)
{
  struct bgp *bgp = bgp_get_default();
  char buf[SU_ADDRSTRLEN];
  struct bgp_node *rn;
  struct bgp_info *ri;
  

  /* Logging. */
  if (BGP_DEBUG (update, UPDATE_IN))  
    zlog (peer->log, LOG_INFO, "%s rcvd UPDATE about %s/%d -- withdrawn\n",
	  peer->host,
	  inet_ntop(p->family, &p->u.prefix, buf, SU_ADDRSTRLEN),
	  p->prefixlen);

  /* Lookup node. */
  rn = bgp_route_node_get (bgp, afi, safi, p, prd);

  /* If peer is soft reconfiguration enabled.  Record input packet for
     further calculation. */
  if (CHECK_FLAG (peer->af_flags[afi][safi], PEER_FLAG_SOFT_RECONFIG)
      && peer != peer_self)
    bgp_adj_in_unset (rn, peer);

  /* Lookup withdrawn route. */
  for (ri = (struct bgp_info *)rn->info; ri; ri = ri->next)
    if (ri->peer == peer && ri->type == type && ri->sub_type == sub_type) 
      break;

  /* Withdraw specified route from routing table. */
  if (ri && ! CHECK_FLAG (ri->flags, BGP_INFO_HISTORY))
    bgp_rib_withdraw (rn, ri, peer, afi, safi, 0);
  else if (BGP_DEBUG (update, UPDATE_IN))
    zlog (peer->log, LOG_INFO, 
	  "%s Can't find the route %s/%d\n", peer->host,
	  inet_ntop (p->family, &p->u.prefix, buf, SU_ADDRSTRLEN),
	  p->prefixlen);

  /* Unlock bgp_node_get() lock. */
  route_unlock_node (rn);

  return 0;
}

void
Bgp::bgp_clear_adj_in (struct peer *peer, afi_t afi, safi_t safi)
{
  struct bgp_table *table;
  struct bgp_node *rn;
  struct bgp_adj_in *ain;
  struct bgp* bgp = bgp_get_default();

  table = bgp->rib[afi][safi];

  for (rn = bgp_table_top (table); rn; rn = bgp_route_next (rn))
    for (ain = rn->adj_in; ain ; ain = ain->next)
      if (ain->peer == peer)
	{
          bgp_adj_in_remove (rn, ain);
          route_unlock_node (rn);
          break;
	}
}

#else

/* Generic function for withdraw BGP information */
int
Bgp::bgp_withdraw (struct peer *peer, struct prefix *p, struct attr *attr, 
                   int afi, int safi, int type, int sub_type, struct prefix_rd *prd,
                   u_char *tag)
{
    struct peer_conf *conf;
    struct listnode *nn;
    struct bgp *bgp;
    char buf[SU_ADDRSTRLEN];
    struct bgp_node *rn;
    struct bgp_info *ri;

    int status;

    if (peer != peer_self)
    {
        /* If peer is soft reconfiguration enabled.  Record input packet for
       further calculation. */
        if (CHECK_FLAG (peer->af_flags[afi][safi], PEER_FLAG_SOFT_RECONFIG))
            bgp_adj_unset (peer->adj_in[afi][safi], p, prd, safi);
    }
    for (nn = peer->conf->head; nn ; nn = nn->next)
        if ((conf = ( struct peer_conf * ) nn->data) != NULL)
        {
            bgp = conf->bgp;

            /* Logging. */
            if (BGP_DEBUG (update, UPDATE_IN))
                zlog (peer->log, LOG_INFO, "%s rcvd UPDATE about %s/%d -- withdrawn\n",
                      peer->host, Bgp::inet_ntop(p->family, &p->u.prefix, buf, SU_ADDRSTRLEN),
                      p->prefixlen);
	    

            /* Lookup node. */
            rn = bgp_route_node_get (bgp, afi, safi, p, prd);

            /* Check selected route and self inserted route. */
            for (ri = ( struct bgp_info * ) rn->info; ri; ri = ri->next)
	      if (ri->peer == peer && ri->type == type && ri->sub_type == sub_type) 
		break;

	    /* Withdraw specified route from routing table. */
            if (ri && ! CHECK_FLAG (ri->flags, BGP_INFO_HISTORY))
            {
                status = BGP_DAMP_DISABLED;

                if (peer_sort (peer) != BGP_PEER_IBGP
                    && peer_sort (peer) != BGP_PEER_CONFED)
                {
                    status = bgp_damp_withdraw (ri);

                    if (status == BGP_DAMP_CONTINUE
                        || status == BGP_DAMP_DISCONTINUE)
                    {
                        bgp_aggregate_decrement (bgp, p, ri, afi, safi);
                        bgp_process (bgp, rn, afi, safi, ri, prd, tag);
                        conf->pcount[afi][safi]--;
                    }
                }

                if (status == BGP_DAMP_DISABLED)
                {
                    bgp_aggregate_decrement (bgp, p, ri, afi, safi);
                    bgp_info_delete ((struct bgp_info **) &rn->info, ri);
                    bgp_process (bgp, rn, afi, safi, ri, prd, tag);
                    bgp_info_free (ri);
                    route_unlock_node (rn);

                    /* Prefix count updates. */
                    conf->pcount[afi][safi]--;
                }
            } else
            {
                if (BGP_DEBUG (update, UPDATE_IN))
                    zlog (peer->log, LOG_INFO, 
                          "%s Cant find the route %s/%d\n", peer->host,
                          Bgp::inet_ntop (p->family, &p->u.prefix, buf, SU_ADDRSTRLEN),
                          p->prefixlen);
            }

            /* Unlock route_node_get() lock. */
            route_unlock_node (rn);
        }
    return 0;
}


#endif

void write_conv_results(Bgp *bgpo)
{
    struct bgp *bgp;
    struct bgp_info *ri;
    struct bgp_node *rn;
    struct bgp_table *table;
    struct attr *attr;

    ofstream bgptable;
    bgptable.open("ns2-bgp_table.mrt");
 
   for (vector<struct bgp *>::iterator bgp = bgp_instances.begin(); bgp != bgp_instances.end(); ++bgp) 
   {
	if (NULL != (*bgp))
	{
    	    //cout << "******** DUMPING BGP TABLE FOR AS *************" << (*bgp)->as << endl;
    	    table = (*bgp)->rib[AFI_IP][SAFI_UNICAST];

    	    for (rn = bgpo->route_top (table); rn; rn = bgpo->route_next (rn))
        	if (rn->info != NULL)
        	{
            	    for (ri = (struct bgp_info * ) rn->info; ri; ri = ri->next)
            	    {
    			if (CHECK_FLAG (ri->flags, BGP_INFO_SELECTED))
			{	
			bgptable << (*bgp)->as << ",";
			attr = ri->attr;

   			if (attr)
    			{
	  		    //cout  << "  NEXT HOP : " << inet_ntoa (attr->nexthop) << endl;
			    bgptable << inet_ntoa (attr->nexthop) << ",";
        		    //if (attr->flag & ATTR_FLAG_BIT (BGP_ATTR_MULTI_EXIT_DISC))
	  		    //cout  << "  MED VALUE : " << attr->med << endl;

        		    //if (attr->flag & ATTR_FLAG_BIT (BGP_ATTR_LOCAL_PREF))
	  		    //cout  << "  LOCAL PREFERENCE : " << attr->local_pref << endl;

	  		    //cout  << "  WEIGHT : " << attr->weight << endl;
        		    if (attr->aspath)
			    {
				bgptable << attr->aspath->length << ",";
				bgptable << attr->aspath->count << ",";
			    	bgptable << attr->aspath->str << endl;
			    }
	  		    //cout  << "  AS PATH : " << attr->aspath->str << endl;

    			}
			}
	    	    }
		}
	}
   }
   bgptable.close();
}


void check_convergence(Bgp *bgp, int index)
{
    map<int, int>::iterator it;
    for ( it = ls_array[index]->process_queue.begin(); it != ls_array[index]->process_queue.end(); it++ )
    {
        if(it->second) 
        {
		#if CONV_DET_DEBUG
		printf ("\nDEBUG: Network not yet converged");
		#endif
		return;
	}
    }	

    for ( it = ls_array[index]->network_queue.begin(); it != ls_array[index]->network_queue.end(); it++ )
    {
        if(it->second) 
        {
		#if CONV_DET_DEBUG
		printf ("\nDEBUG: Network not yet converged\n");
		#endif
		return;
	}
    }
    //printf("\nDEBUG: NETWORK CONVERGED FOR PREFIX ");
    //cout << event_prefix[index] << endl;	
    write_conv_results(bgp);
    bgp->bgp_dump_routes_func(AFI_IP);
    delete ls_array[index];
    event_prefix[index] = "";
    return;
}
/* Parser of NLRI octet stream.  Withdraw NLRI is recognized by NULL
   attr value. */
int
Bgp::nlri_parse (struct peer *peer, struct attr *attr, struct bgp_nlri *packet)
{
    u_char *pnt;
    u_char *lim;
    struct prefix p;
    int psize;
    int ret;

    /* Check peer status. */
    if (peer->status != Established)
        return 0;

    pnt = packet->nlri;
    lim = pnt + packet->length;

    for (; pnt < lim; pnt += psize)
    {
        /* Clear prefix structure. */
        memset (&p, 0, sizeof (struct prefix));

        /* Fetch prefix length. */
        p.prefixlen = *pnt++;
        p.family = afi2family (packet->afi);

        /* Already checked in nlri_sanity_check().  We do double check
           here. */
        if ((packet->afi == AFI_IP && p.prefixlen > 32)
	    //            || (packet->afi == AFI_IP6 && p.prefixlen > 128)
	    )
            return -1;

        /* Packet size overflow check. */
        psize = PSIZE (p.prefixlen);

        /* When packet overflow occur return immediately. */
        if (pnt + psize > lim)
            return -1;

        /* Fetch prefix from NLRI packet. */
        memcpy (&p.u.prefix, pnt, psize);

        /* Check address. */
        if (packet->afi == AFI_IP && packet->safi == SAFI_UNICAST)
        {
            if (IN_CLASSD (ntohl (p.u.prefix4.s_addr)))
            {
                zlog (peer->log, LOG_ERR, 
                      "IPv4 unicast NLRI is multicast address %s\n",
                      inet_ntoa (p.u.prefix4));
                bgp_notify_send (peer, 
                                 BGP_NOTIFY_UPDATE_ERR, 
                                 BGP_NOTIFY_UPDATE_INVAL_NETWORK);
                return -1;
            }
        }

        /* Translate update.  Convert unicast update to multicast update. */
//         if (packet->safi == SAFI_UNICAST && peer->translate_update)
//         {
//             if (attr)
//                 ret = bgp_update (peer, &p, attr, packet->afi, SAFI_MULTICAST,
//                                   ZEBRA_ROUTE_BGP, BGP_ROUTE_NORMAL, NULL, NULL, 0);
//             else
//                 ret = bgp_withdraw (peer, &p, attr, packet->afi, SAFI_MULTICAST,
//                                     ZEBRA_ROUTE_BGP, BGP_ROUTE_NORMAL, NULL, NULL);
//             if (ret < 0)
//                 return -1;
//         }

        /* Do not process unicast update when translate update is
           only to multicast. */
//         if (packet->safi == SAFI_UNICAST 
//             && peer->translate_update == SAFI_MULTICAST)
//            continue;

	/* Decrement the network queue and increment the processing queue
	used for convergence detection in NS2*/ 
	//print_event_prefixes();

	string ip_prefix = inet_ntoa(p.u.prefix4);
	int index=0;
	for (int i = 0; i < total_events; i++)
	{
		if (event_prefix[i] == ip_prefix)
		{
			index = i;
			ls_array[i]->network_queue[peer->local_as] -= 1;
			ls_array[i]->process_queue[peer->local_as] += 1;
			#if CONV_DET_DEBUG
			printf("\n DEBUG: OnReceive network queue of AS %d decremented to %d",peer->local_as, ls_array[i]->network_queue[peer->local_as]);
			printf("\n DEBUG: OnReceive process queue of AS %d incremented to %d",peer->local_as, ls_array[i]->process_queue[peer->local_as]);
			#endif
			break;
		}
     	}
	    
        /* Normal process. */
        if (attr)
            ret = bgp_update (peer, &p, attr, packet->afi, packet->safi, 
                              ZEBRA_ROUTE_BGP, BGP_ROUTE_NORMAL, NULL, NULL, 0);
        else
            ret = bgp_withdraw (peer, &p, attr, packet->afi, packet->safi, 
                                ZEBRA_ROUTE_BGP, BGP_ROUTE_NORMAL, NULL, NULL);

	/* Decrement the processing queue used for convergence detection*/		
	if (mrai_map[(make_pair(ip_prefix,peer->local_as))] != 1)
	{ls_array[index]->process_queue[peer->local_as] -= 1;
		#if CONV_DET_DEBUG
		printf("\n DEBUG: OnSend process queue of AS %d decremented to %d",peer->local_as, ls_array[index]->process_queue[peer->local_as]);
		#endif
		if (ls_array[index]->process_queue[peer->local_as] == 0)
			check_convergence(this, index);
	}

        /* Address family configuration mismatch or maximum-prefix count
           overflow. */
        if (ret < 0)
            return -1;
    }

    /* Packet length consistency check. */
    if (pnt != lim)
        return -1;

    return 0;
}

/* NLRI encode syntax check routine. */
int
Bgp::nlri_sanity_check (struct peer *peer, int afi, u_char *pnt, bgp_size_t length)
{
    u_char *end;
    u_char prefixlen;
    int psize;

    end = pnt + length;

    /* RFC1771 6.3 The NLRI field in the UPDATE message is checked for
       syntactic validity.  If the field is syntactically incorrect,
       then the Error Subcode is set to Invalid Network Field. */

    while (pnt < end)
    {
        prefixlen = *pnt++;

        /* Prefix length check. */
        if ((afi == AFI_IP && prefixlen > 32)
	    //            || (afi == AFI_IP6 && prefixlen > 128)
	    )
        {
            plog_err (peer->log, 
                      "%s [Error] Update packet error (wrong prefix length %d)\n",
                      peer->host, prefixlen);
            bgp_notify_send (peer, BGP_NOTIFY_UPDATE_ERR, 
                             BGP_NOTIFY_UPDATE_INVAL_NETWORK);
            return -1;
        }

        /* Packet size overflow check. */
        psize = PSIZE (prefixlen);

        if (pnt + psize > end)
        {
            plog_err (peer->log, 
                      "%s [Error] Update packet error\n"
                      " (prefix data overflow prefix size is %d)",
                      peer->host, psize);
            bgp_notify_send (peer, BGP_NOTIFY_UPDATE_ERR, 
                             BGP_NOTIFY_UPDATE_INVAL_NETWORK);
            return -1;
        }

        pnt += psize;
    }

    /* Packet length consistency check. */
    if (pnt != end)
    {
        plog_err (peer->log,
                  "%s [Error] Update packet error\n"
                  " (prefix length mismatch with total length)",
                  peer->host);
        bgp_notify_send (peer, BGP_NOTIFY_UPDATE_ERR, 
                         BGP_NOTIFY_UPDATE_INVAL_NETWORK);
        return -1;
    }
    return 0;
}
#ifndef HAVE_ZEBRA_93b
/* Soft reconfiguration for input. */
void
Bgp::bgp_soft_reconfig_in (struct peer *peer, afi_t afi, safi_t safi)
{
    int ret;
    struct bgp_node *rn;
    struct attr *attr;

    for (rn = route_top (peer->adj_in[afi][safi]); rn; rn = route_next (rn))
        if ((attr = ( struct attr * )  rn->info) != NULL)
        {
            ret = bgp_update (peer, &rn->p, attr, afi, safi,
                              ZEBRA_ROUTE_BGP, BGP_ROUTE_NORMAL,
                              NULL, NULL, 1);

            /* Address family configuration mismatch or maximum-prefix count
               overflow. */
            if (ret < 0)
            {
                route_unlock_node (rn);
                return;
            }
        }
}

#else 
void
Bgp::bgp_soft_reconfig_table (struct peer *peer, afi_t afi, safi_t safi,
			      struct bgp_table *table)
{
  int ret;
  struct bgp_node *rn;
  struct bgp_adj_in *ain;
  struct bgp* bgp;

  bgp = bgp_get_default();

  if (! table)
    table = bgp->rib[afi][safi];

  for (rn = bgp_table_top (table); rn; rn = bgp_route_next (rn))
    for (ain = rn->adj_in; ain; ain = ain->next)
      {
	if (ain->peer == peer)
	  {
	    ret = bgp_update (peer, &rn->p, ain->attr, afi, safi,
			      ZEBRA_ROUTE_BGP, BGP_ROUTE_NORMAL,
			      NULL, NULL, 1);
	    if (ret < 0)
	      {
		route_unlock_node (rn);
		return;
	      }
	    continue;
	  }
      }
}

void
Bgp::bgp_soft_reconfig_in (struct peer *peer, afi_t afi, safi_t safi)
{
  struct bgp_node *rn;
  struct bgp_table *table;

  if (peer->status != Established)
    return;

  bgp_soft_reconfig_table (peer, afi, safi, NULL);
}

#endif
/* Remove all routes from the peer. */
void
Bgp::bgp_route_clear_with_afi (struct peer *peer, struct bgp *bgp, afi_t afi,
                               safi_t safi)
{
    struct bgp_node *rn;
    struct bgp_info *ri;
    struct bgp_info *next;

    for (rn = route_top (bgp->rib[afi][safi]); rn; rn = route_next (rn))
        for (ri = ( struct bgp_info * )rn->info; ri; ri = next)
        {
            next = ri->next;

            if (ri->peer == peer)
            {
                bgp_aggregate_decrement (bgp, &rn->p, ri, afi, safi);
                bgp_info_delete ((struct bgp_info **) &rn->info, ri);
                bgp_process (bgp, rn, afi, safi, ri, NULL, NULL);
                bgp_info_free (ri);
                route_unlock_node (rn);
            }
        }
}

#ifndef HAVE_ZEBRA_93b
/* Remove all routes from the peer. */
void
Bgp::bgp_route_clear (struct peer *peer)
{
    struct listnode *nn;
    struct peer_conf *conf;

    /* Clear BGP routes. */
    for (nn = peer->conf->head; nn; nn = nn->next)
        if (( conf = ( struct peer_conf * ) nn->data ) != NULL)
        {
            bgp_route_clear_with_afi (peer, conf->bgp, AFI_IP, SAFI_UNICAST);

            /* Clear prefix counter. */
            conf->pcount[AFI_IP][SAFI_UNICAST] = 0;
        }

        /* Clear Adj-RIB-In information. */
    bgp_adj_clear (peer->adj_in[AFI_IP][SAFI_UNICAST], SAFI_UNICAST);

    /* Clear Adj-RIB-Out information. */
    bgp_adj_clear (peer->adj_out[AFI_IP][SAFI_UNICAST], SAFI_UNICAST);
}
#else
void
Bgp::bgp_clear_route_table (struct peer *peer, afi_t afi, safi_t safi,
			    struct bgp_table *table)
{
  struct bgp_node *rn;
  struct bgp_adj_in *ain;
  struct bgp_adj_out *aout;
  struct bgp_info *ri;
  struct bgp *bgp = bgp_get_default();

  if (! table)
    table = bgp->rib[afi][safi];

  for (rn = bgp_table_top (table); rn; rn = bgp_route_next (rn))
    {
      for (ri = (struct bgp_info *) rn->info; ri; ri = ri->next)
	if (ri->peer == peer)
	  {
	    bgp_rib_remove (rn, ri, peer, afi, safi);
	    break;
	  }
      for (ain = rn->adj_in; ain; ain = ain->next)
	if (ain->peer == peer)
	  {
	    bgp_adj_in_remove (rn, ain);
	    route_unlock_node (rn);
	    break;
	  }
      for (aout = rn->adj_out; aout; aout = aout->next)
	if (aout->peer == peer)
	  {
	    bgp_adj_out_remove (rn, aout, peer, afi, safi);
	    route_unlock_node (rn);
	    break;
	  }
    }
}

void
Bgp::bgp_clear_route (struct peer *peer, afi_t afi, safi_t safi)
{
  struct bgp_node *rn;
  struct bgp_table *table;
  struct bgp * bgp = bgp_get_default();

  if (! peer->afc[afi][safi])
    return;
  
  bgp_clear_route_table (peer, afi, safi, NULL);
}
  
void
Bgp::bgp_clear_route_all (struct peer *peer)
{
  afi_t afi;
  safi_t safi;

  for (afi = AFI_IP; afi < AFI_MAX; afi++)
    for (safi = SAFI_UNICAST; safi < SAFI_MAX; safi++)
      bgp_clear_route (peer, afi, safi);
}

void
Bgp::bgp_rib_remove (struct bgp_node *rn, struct bgp_info *ri, struct peer *peer,
		     afi_t afi, safi_t safi)
{
  struct listnode * nm;
  struct peer_conf* conf;
  struct bgp *bgp = bgp_get_default();

  if (! CHECK_FLAG (ri->flags, BGP_INFO_HISTORY))
    {

      for (nm = peer->conf->head; nm; nm = nm->next)
	if ((conf = ( struct peer_conf * ) nm->data) != NULL)
	  conf->pcount[afi][safi]--;

      bgp_aggregate_decrement (bgp, &rn->p, ri, afi, safi);
      UNSET_FLAG (ri->flags, BGP_INFO_VALID);
      bgp_process (bgp, rn, afi, safi, NULL, NULL, NULL);
    }
  bgp_info_delete ((struct bgp_info**)&rn->info, ri);
  bgp_info_free (ri);
  route_unlock_node (rn);
}
#endif

struct bgp_static *
Bgp::bgp_static_new ()
{
    struct bgp_static *New;
    New = ( struct bgp_static * ) XMALLOC (MTYPE_BGP_STATIC, sizeof (struct bgp_static));
    memset (New, 0, sizeof (struct bgp_static));
    return New;
}

void
Bgp::bgp_static_free (struct bgp_static *bgp_static)
{
    XFREE (MTYPE_BGP_STATIC, bgp_static);
}

void
Bgp::bgp_static_update (struct bgp *bgp, struct prefix *p, u_int16_t afi,
                        u_char safi)
{
    struct bgp_node *rn;
    struct bgp_info *New;
    u_int32_t igpmetric;

    rn = bgp_route_node_get (bgp, afi, safi, p, NULL);

    /* Make New BGP info. */
    New = bgp_info_new ();
    New->type = ZEBRA_ROUTE_BGP;
    New->sub_type = BGP_ROUTE_STATIC;
    New->peer = peer_self;
    
    SET_FLAG (New->flags, BGP_INFO_VALID);
    
    New->attr = bgp_attr_default_intern (BGP_ORIGIN_IGP);
    double simulation_time;
    simulation_time = Scheduler::instance().clock();
    time_t clock = (int)simulation_time + start_time;
    New->uptime = clock;

    /* Aggregate address increment. */
    bgp_aggregate_increment (bgp, p, New, afi, safi);

    /* Register New BGP information. */
    bgp_info_add ((struct bgp_info **) &rn->info, New);

    /* Process change. */
    bgp_process (bgp, rn, afi, safi, NULL, NULL, NULL);
}


void
Bgp::bgp_static_withdraw (struct bgp *bgp, struct prefix *p, u_int16_t afi,
                          u_char safi)
{
    struct bgp_node *rn;
    struct bgp_info *ri;

    rn = bgp_route_node_get (bgp, afi, safi, p, NULL);

    /* Check selected route and self inserted route. */
    for (ri = ( struct bgp_info * ) rn->info; ri; ri = ri->next)
        if (ri->peer == peer_self 
            && ri->type == ZEBRA_ROUTE_BGP
            && ri->sub_type == BGP_ROUTE_STATIC)
            break;

        /* Withdraw static BGP route from routing table. */
    if (ri)
    {
        bgp_aggregate_decrement (bgp, p, ri, afi, safi);
        bgp_info_delete ((struct bgp_info **) &rn->info, ri);
        bgp_process (bgp, rn, afi, safi, ri, NULL, NULL);
        bgp_info_free (ri);
        route_unlock_node (rn);
    }

    /* Unlock route_node_lookup. */
    route_unlock_node (rn);
}


/* Configure static BGP network. */
int
Bgp::bgp_static_set (struct vty *vty, struct bgp *bgp, char *ip_str, u_int16_t afi,
                     u_char safi)
{
    int ret;
    struct prefix p;
    struct bgp_static *bgp_static;
    struct bgp_node *rn;
    struct peer *peer;
    struct listnode *nn;
    
    /* Convert IP prefix string to struct prefix. */
    ret = str2prefix (ip_str, &p);
    if (! ret)
    {
        vty_out (zlog_default,LOG_DEBUG, "%% Malformed prefix%s", VTY_NEWLINE);
        return CMD_WARNING;
    }

    apply_mask (&p);

    /* Set BGP static route configuration. */
    rn = route_node_get (bgp->route[afi][safi], &p);

    if (rn->info)
    {
        /* Configuration change. */
        bgp_static =( struct bgp_static * )  rn->info;
        route_unlock_node (rn);
    } else
    {
        /* New configuration. */
        bgp_static = bgp_static_new ();
        bgp_static->valid = 1;
	bgp_static->igpmetric = 0;

        rn->info = bgp_static;
#ifndef HAVE_ZEBRA_93b
	for (nn = peer_list->head; nn; nn  = nn->next)
	  if ((peer = ( struct peer * ) nn->data) != NULL)
	    bgp_cancel_supressed_update_by_prefix(peer,&p);
#endif
	bgp_static_update (bgp, &p, afi, safi);	
    }

    return CMD_SUCCESS;
}

/* Configure static BGP network. */
int
Bgp::bgp_static_unset (struct vty *vty, struct bgp *bgp, char *ip_str,
                       u_int16_t afi, u_char safi)
{
    int ret;
    struct prefix p;
    struct bgp_static *bgp_static;
    struct bgp_node *rn;

    /* Convert IP prefix string to struct prefix. */
    ret = str2prefix (ip_str, &p);
    if (! ret)
    {
        vty_out (zlog_default,LOG_DEBUG, "%% Malformed prefix%s", VTY_NEWLINE);
        return CMD_WARNING;
    }

    apply_mask (&p);

    rn = route_node_lookup (bgp->route[afi][safi], &p);
    if (! rn)
    {
        vty_out (zlog_default,LOG_DEBUG, "%% Cant find specified static route configuration.%s",
                 VTY_NEWLINE);
        return CMD_WARNING;
    }

    bgp_static = ( struct bgp_static * ) rn->info;

    /* Update BGP RIB. */
    bgp_static_withdraw (bgp, &p, afi, safi);

    /* Clear configuration. */
    bgp_static_free (bgp_static);
    rn->info = NULL;
    route_unlock_node (rn);
    route_unlock_node (rn);

    return CMD_SUCCESS;
}

/* Called from bgp_delete().  Delete all static routes from the BGP
   instance. */
void
Bgp::bgp_static_delete (struct bgp *bgp)
{
    afi_t afi;
    safi_t safi;
    struct bgp_node *rn;
    struct bgp_node *rm;
    struct bgp_table *table;
    struct bgp_static *bgp_static;

    for (afi = AFI_IP; afi < AFI_MAX; afi++)
        for (safi = SAFI_UNICAST; safi < SAFI_MAX; safi++)
            for (rn = route_top (bgp->route[afi][safi]); rn; rn = route_next (rn))
                if (rn->info != NULL)
                {
		  bgp_static = ( struct bgp_static * ) rn->info;
		  bgp_static_withdraw (bgp, &rn->p, afi, safi);
		  bgp_static_free (bgp_static);
		  rn->info = NULL;
		  route_unlock_node (rn);
                  
                }
}

afi_t
Bgp::bgp_node_afi (struct vty *vty)
{
    return AFI_IP;
}

safi_t
Bgp::bgp_node_safi (struct vty *vty)
{
  return  SAFI_UNICAST;
}

DEFUN (bgp_network,
       bgp_network_cmd,
       "network A.B.C.D/M",
       "Specify a network to announce via BGP\n"
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n")
{
    return bgp_static_set (vty, bgp_get_default(), argv[0],
                           AFI_IP, bgp_node_safi (vty));
}

DEFUN (bgp_network_mask,
       bgp_network_mask_cmd,
       "network A.B.C.D mask A.B.C.D",
       "Specify a network to announce via BGP\n"
       "Network number\n"
       "Network mask\n"
       "Network mask\n")
{
    int ret;
    char prefix_str[BUFSIZ];

    if (argc == 2)
        ret = netmask_str2prefix_str (argv[0], argv[1], prefix_str);
    else
        ret = netmask_str2prefix_str (argv[0], NULL, prefix_str);

    if (! ret)
    {
        vty_out (zlog_default,LOG_DEBUG, "%% Inconsistent address and mask%s", VTY_NEWLINE);
        return CMD_WARNING;
    }

    return bgp_static_set (vty,bgp_get_default(), prefix_str,
                           AFI_IP, bgp_node_safi (vty));
}


DEFUN (no_bgp_network,
       no_bgp_network_cmd,
       "no network A.B.C.D/M",
       NO_STR
       "Specify a network to announce via BGP\n"
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n")
{
    return bgp_static_unset (vty, ( struct bgp * ) bgp_get_default(), argv[0], AFI_IP, 
                             bgp_node_safi (vty));
}


DEFUN (no_bgp_network_mask,
       no_bgp_network_mask_cmd,
       "no network A.B.C.D mask A.B.C.D",
       NO_STR
       "Specify a network to announce via BGP\n"
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n")
{
    int ret;
    char prefix_str[BUFSIZ];

    if (argc == 2)
        ret = netmask_str2prefix_str (argv[0], argv[1], prefix_str);
    else
        ret = netmask_str2prefix_str (argv[0], NULL, prefix_str);

    if (! ret)
    {
        vty_out (zlog_default,LOG_DEBUG, "%% Inconsistent address and mask%s", VTY_NEWLINE);
        return CMD_WARNING;
    }

    return bgp_static_unset (vty, ( struct bgp * ) bgp_get_default(), prefix_str, AFI_IP, 
                             bgp_node_safi (vty));
}


/* Aggreagete address:

  advertise-map  Set condition to advertise attribute
  as-set         Generate AS set path information
  attribute-map  Set attributes of aggregate
  route-map      Set parameters of aggregate
  summary-only   Filter more specific routes from updates
  suppress-map   Conditionally filter more specific routes from updates
  <cr>
 */

struct bgp_aggregate *
Bgp::bgp_aggregate_new ()
{
    struct bgp_aggregate *New;
    New =( struct bgp_aggregate * )  XMALLOC (MTYPE_BGP_AGGREGATE, sizeof (struct bgp_aggregate));
    memset (New, 0, sizeof (struct bgp_aggregate));
    return New;
}

void
Bgp::bgp_aggregate_free (struct bgp_aggregate *aggregate)
{
    XFREE (MTYPE_BGP_AGGREGATE, aggregate);
}     

void
Bgp::bgp_aggregate_route (struct bgp *bgp, struct prefix *p, struct bgp_info *rinew,
                          afi_t afi, safi_t safi, struct bgp_info *del, 
                          struct bgp_aggregate *aggregate)
{
    struct bgp_table *table;
    struct bgp_node *top;
    struct bgp_node *rn;
    u_char origin;
    struct aspath *aspath = NULL;
    struct aspath *asmerge = NULL;
    struct community *community = NULL;
    struct community *commerge = NULL;
    struct in_addr nexthop;
    u_int32_t med = 0;
    struct bgp_info *ri;
    struct bgp_info *New;
    int first = 1;
    unsigned long match = 0;

    /* Record adding route's nexthop and med. */
    if (rinew)
    {
        nexthop = rinew->attr->nexthop;
        med = rinew->attr->med;
    }

    /* ORIGIN attribute: If at least one route among routes that are
       aggregated has ORIGIN with the value INCOMPLETE, then the
       aggregated route must have the ORIGIN attribute with the value
       INCOMPLETE. Otherwise, if at least one route among routes that
       are aggregated has ORIGIN with the value EGP, then the aggregated
       route must have the origin attribute with the value EGP. In all
       other case the value of the ORIGIN attribute of the aggregated
       route is INTERNAL. */
    origin = BGP_ORIGIN_IGP;

    table = bgp->rib[afi][safi];

    top = route_node_get (table, p);
    for (rn = route_node_get (table, p); rn; rn = route_next_until (rn, top))
        if (rn->p.prefixlen > p->prefixlen)
        {
            match = 0;

            for (ri = ( struct bgp_info * ) rn->info; ri; ri = ri->next)
            {
                if (BGP_INFO_HOLDDOWN (ri))
                    continue;

                if (del && ri == del)
                    continue;

                if (! rinew && first)
                {
                    nexthop = ri->attr->nexthop;
                    med = ri->attr->med;
                    first = 0;
                }

#ifdef AGGREGATE_NEXTHOP_CHECK
                if (! IPV4_ADDR_SAME (&ri->attr->nexthop, &nexthop)
                    || ri->attr->med != med)
                {
                    if (aspath)
                        aspath_free (aspath);
                    if (community)
                        community_free (community);
                    route_unlock_node (rn);
                    route_unlock_node (top);
                    return;
                }
#endif /* AGGREGATE_NEXTHOP_CHECK */

                if (ri->sub_type != BGP_ROUTE_AGGREGATE)
                {
                    if (aggregate->summary_only)
                    {
                        ri->suppress++;
                        SET_FLAG (ri->flags, BGP_INFO_ATTR_CHANGED);
                        match++;
                    }

                    aggregate->count++;

                    if (aggregate->as_set)
                    {
                        if (origin < ri->attr->origin)
                            origin = ri->attr->origin;

                        if (aspath)
                        {
                            asmerge = aspath_aggregate (aspath, ri->attr->aspath);
                            aspath_free (aspath);
                            aspath = asmerge;
                        } else
                            aspath = aspath_dup (ri->attr->aspath);

                        if (ri->attr->community)
                        {
                            if (community)
                            {
                                commerge = community_merge (community,
                                                            ri->attr->community);
                                community = community_uniq_sort (commerge);
                                community_free (commerge);
                            } else
                                community = community_dup (ri->attr->community);
                        }
                    }
                }
            }
            if (match)
                bgp_process (bgp, rn, afi, safi, NULL, NULL, NULL);
        }
    route_unlock_node (top);

    if (rinew)
    {
        aggregate->count++;

        if (aggregate->summary_only)
            rinew->suppress++;

        if (aggregate->as_set)
        {
            if (origin < rinew->attr->origin)
                origin = rinew->attr->origin;

            if (aspath)
            {
                asmerge = aspath_aggregate (aspath, rinew->attr->aspath);
                aspath_free (aspath);
                aspath = asmerge;
            } else
                aspath = aspath_dup (rinew->attr->aspath);

            if (rinew->attr->community)
            {
                if (community)
                {
                    commerge = community_merge (community,
                                                rinew->attr->community);
                    community = community_uniq_sort (commerge);
                    community_free (commerge);
                } else
                    community = community_dup (rinew->attr->community);
            }
        }
    }

    if (aggregate->count > 0)
    {
        rn = route_node_get (table, p);
        New = bgp_info_new ();
        New->type = ZEBRA_ROUTE_BGP;
        New->sub_type = BGP_ROUTE_AGGREGATE;
        New->peer = peer_self;
        SET_FLAG (New->flags, BGP_INFO_VALID);
        New->attr = bgp_attr_aggregate_intern (bgp, origin, aspath, community, aggregate->as_set);
	double simulation_time;
	simulation_time = Scheduler::instance().clock();
	time_t clock = (int)simulation_time + start_time;
        New->uptime = clock;

        bgp_info_add ((struct bgp_info **) &rn->info, New);
        bgp_process (bgp, rn, afi, safi, NULL, NULL, NULL);
    } else
    {
        if (aspath)
            aspath_free (aspath);
        if (community)
            community_free (community);
    }
}

void
Bgp::bgp_aggregate_increment (struct bgp *bgp, struct prefix *p,
                              struct bgp_info *ri, afi_t afi, safi_t safi)
{
    struct bgp_node *child;
    struct bgp_node *rn;
    struct bgp_aggregate *aggregate;

    if (p->prefixlen == 0)
        return;

    if (BGP_INFO_HOLDDOWN (ri))
        return;

    child = route_node_get (bgp->aggregate[afi][safi], p);

    /* Aggregate address configuration check. */
    for (rn = child; rn; rn = rn->parent)
        if ((aggregate = ( struct bgp_aggregate * ) rn->info) != NULL && rn->p.prefixlen < p->prefixlen)
        {
            bgp_aggregate_delete (bgp, &rn->p, afi, safi, aggregate);
            bgp_aggregate_route (bgp, &rn->p, ri, safi, safi, NULL, aggregate);
        }
    route_unlock_node (child);
}

void
Bgp::bgp_aggregate_decrement (struct bgp *bgp, struct prefix *p, 
                              struct bgp_info *del, afi_t afi, safi_t safi)
{
    struct bgp_node *child;
    struct bgp_node *rn;
    struct bgp_aggregate *aggregate;

    if (p->prefixlen == 0)
        return;

    if (BGP_INFO_HOLDDOWN (del))
        return;

    child = route_node_get (bgp->aggregate[afi][safi], p);

    /* Aggregate address configuration check. */
    for (rn = child; rn; rn = rn->parent)
        if ((aggregate = ( struct bgp_aggregate * ) rn->info) != NULL && rn->p.prefixlen < p->prefixlen)
        {
            bgp_aggregate_delete (bgp, &rn->p, afi, safi, aggregate);
            bgp_aggregate_route (bgp, &rn->p, NULL, safi, safi, del, aggregate);
        }
    route_unlock_node (child);
}

void
Bgp::bgp_aggregate_add (struct bgp *bgp, struct prefix *p, afi_t afi, safi_t safi,
                        struct bgp_aggregate *aggregate)
{
    struct bgp_table *table;
    struct bgp_node *top;
    struct bgp_node *rn;
    struct bgp_info *New;
    struct bgp_info *ri;
    unsigned long match;
    u_char origin = BGP_ORIGIN_IGP;
    struct aspath *aspath = NULL;
    struct aspath *asmerge = NULL;
    struct community *community = NULL;
    struct community *commerge = NULL;

    table = bgp->rib[afi][safi];

    /* Sanity check. */
    if (afi == AFI_IP && p->prefixlen == IPV4_MAX_BITLEN)
        return;
    //    if (afi == AFI_IP6 && p->prefixlen == IPV6_MAX_BITLEN)
    //        return;

    /* If routes exists below this node, generate aggregate routes. */
    top = route_node_get (table, p);
    for (rn = route_node_get (table, p); rn; rn = route_next_until (rn, top))
        if (rn->p.prefixlen > p->prefixlen)
        {
            match = 0;

            for (ri = ( struct bgp_info * ) rn->info; ri; ri = ri->next)
            {
                if (BGP_INFO_HOLDDOWN (ri))
                    continue;

                if (ri->sub_type != BGP_ROUTE_AGGREGATE)
                {
                    /* summary-only aggregate route suppress aggregated
                       route announcement.  */
                    if (aggregate->summary_only)
                    {
                        ri->suppress++;
                        SET_FLAG (ri->flags, BGP_INFO_ATTR_CHANGED);
                        match++;
                    }
                    /* as-set aggregate route generate origin, as path,
                       community aggregation.  */
                    if (aggregate->as_set)
                    {
                        if (origin < ri->attr->origin)
                            origin = ri->attr->origin;

                        if (aspath)
                        {
                            asmerge = aspath_aggregate (aspath, ri->attr->aspath);
                            aspath_free (aspath);
                            aspath = asmerge;
                        } else
                            aspath = aspath_dup (ri->attr->aspath);

                        if (ri->attr->community)
                        {
                            if (community)
                            {
                                commerge = community_merge (community,
                                                            ri->attr->community);
                                community = community_uniq_sort (commerge);
                                community_free (commerge);
                            } else
                                community = community_dup (ri->attr->community);
                        }
                    }
                    aggregate->count++;
                }
            }

            /* If this node is suppressed, process the change. */
            if (match)
                bgp_process (bgp, rn, afi, safi, NULL, NULL, NULL);
        }
    route_unlock_node (top);

    /* Add aggregate route to BGP table. */
    if (aggregate->count)
    {
        rn = route_node_get (table, p);

        New = bgp_info_new ();
        New->type = ZEBRA_ROUTE_BGP;
        New->sub_type = BGP_ROUTE_AGGREGATE;
        New->peer = peer_self;
        SET_FLAG (New->flags, BGP_INFO_VALID);
        New->attr = bgp_attr_aggregate_intern (bgp, origin, aspath, community, aggregate->as_set);
	double simulation_time;
	simulation_time = Scheduler::instance().clock();
	time_t clock = (int)simulation_time + start_time;
        New->uptime = clock;

        bgp_info_add ((struct bgp_info **) &rn->info, New);

        /* Process change. */
        bgp_process (bgp, rn, afi, safi, NULL, NULL, NULL);
    }
}

void
Bgp::bgp_aggregate_delete (struct bgp *bgp, struct prefix *p, afi_t afi, 
                           safi_t safi, struct bgp_aggregate *aggregate)
{
    struct bgp_table *table;
    struct bgp_node *top;
    struct bgp_node *rn;
    struct bgp_info *ri;
    unsigned long match;

    table = bgp->rib[afi][safi];

    if (afi == AFI_IP && p->prefixlen == IPV4_MAX_BITLEN)
        return;
    //    if (afi == AFI_IP6 && p->prefixlen == IPV6_MAX_BITLEN)
    //        return;

    /* If routes exists below this node, generate aggregate routes. */
    top = route_node_get (table, p);
    for (rn = route_node_get (table, p); rn; rn = route_next_until (rn, top))
        if (rn->p.prefixlen > p->prefixlen)
        {
            match = 0;

            for (ri = ( struct bgp_info * ) rn->info; ri; ri = ri->next)
            {
                if (BGP_INFO_HOLDDOWN (ri))
                    continue;

                if (ri->sub_type != BGP_ROUTE_AGGREGATE)
                {
                    if (aggregate->summary_only)
                    {
                        ri->suppress--;

                        if (ri->suppress == 0)
                        {
                            SET_FLAG (ri->flags, BGP_INFO_ATTR_CHANGED);
                            match++;
                        }
                    }
                    aggregate->count--;
                }
            }

            /* If this node is suppressed, process the change. */
            if (match)
                bgp_process (bgp, rn, afi, safi, NULL, NULL, NULL);
        }
    route_unlock_node (top);

    /* Delete aggregate route from BGP table. */
    rn = route_node_get (table, p);

    for (ri = ( struct bgp_info * ) rn->info; ri; ri = ri->next)
        if (ri->peer == peer_self 
            && ri->type == ZEBRA_ROUTE_BGP
            && ri->sub_type == BGP_ROUTE_AGGREGATE)
            break;

        /* Withdraw static BGP route from routing table. */
    if (ri)
    {
        bgp_info_delete ((struct bgp_info **) &rn->info, ri);
        bgp_process (bgp, rn, afi, safi, ri, NULL, NULL);
        bgp_info_free (ri);
        route_unlock_node (rn);
    }

    /* Unlock route_node_lookup. */
    route_unlock_node (rn);
}

int
Bgp::bgp_aggregate_set (struct vty *vty, char *prefix_str, afi_t afi, safi_t safi,
                        u_char summary_only, u_char as_set)
{
    int ret;
    struct prefix p;
    struct bgp_node *rn;
    struct bgp *bgp;
    struct bgp_aggregate *aggregate;

    /* Convert string to prefix structure. */
    ret = str2prefix (prefix_str, &p);
    if (!ret)
    {
        vty_out (zlog_default,LOG_DEBUG, "Malformed prefix%s", VTY_NEWLINE);
        return CMD_WARNING;
    }
    apply_mask (&p);

    /* Get BGP structure. */
    bgp = ( struct bgp * ) bgp_get_default();

    /* Old configuration check. */
    rn = route_node_get (bgp->aggregate[afi][safi], &p);

    if (rn->info)
    {
        vty_out (zlog_default,LOG_DEBUG, "There is already same aggregate network.%s", VTY_NEWLINE);
        route_unlock_node (rn);
        return CMD_WARNING;
    }

    /* Make aggregate address structure. */
    aggregate = bgp_aggregate_new ();
    aggregate->summary_only = summary_only;
    aggregate->as_set = as_set;
    aggregate->safi = safi;
    rn->info = aggregate;

    /* Aggregate address insert into BGP routing table. */
    if (safi & SAFI_UNICAST)
        bgp_aggregate_add (bgp, &p, afi, SAFI_UNICAST, aggregate);

    return CMD_SUCCESS;
}

int
Bgp::bgp_aggregate_unset (struct vty *vty, char *prefix_str, afi_t afi, safi_t safi)
{
    int ret;
    struct prefix p;
    struct bgp_node *rn;
    struct bgp *bgp;
    struct bgp_aggregate *aggregate;

    /* Convert string to prefix structure. */
    ret = str2prefix (prefix_str, &p);
    if (!ret)
    {
        vty_out (zlog_default,LOG_DEBUG, "Malformed prefix%s", VTY_NEWLINE);
        return CMD_WARNING;
    }
    apply_mask (&p);

    /* Get BGP structure. */
    bgp = ( struct bgp * ) bgp_get_default();

    /* Old configuration check. */
    rn = route_node_lookup (bgp->aggregate[afi][safi], &p);
    if (! rn)
    {
        vty_out (zlog_default,LOG_DEBUG, "%% There is no aggregate-address configuration.%s",
                 VTY_NEWLINE);
        return CMD_WARNING;
    }

    aggregate = ( struct bgp_aggregate * ) rn->info;
    if (aggregate->safi & SAFI_UNICAST)
        bgp_aggregate_delete (bgp, &p, afi, SAFI_UNICAST, aggregate);
    //    if (aggregate->safi & SAFI_MULTICAST)
    //        bgp_aggregate_delete (bgp, &p, afi, SAFI_MULTICAST, aggregate);

    /* Unlock aggregate address configuration. */
    rn->info = NULL;
    bgp_aggregate_free (aggregate);
    route_unlock_node (rn);
    route_unlock_node (rn);

    return CMD_SUCCESS;
}

DEFUN (aggregate_address,
       aggregate_address_cmd,
       "aggregate-address A.B.C.D/M",
       "Configure BGP aggregate entries\n"
       "Aggregate prefix\n")
{
    return bgp_aggregate_set (vty, argv[0], AFI_IP, bgp_node_safi (vty), 0, 0);
}

DEFUN (aggregate_address_mask,
       aggregate_address_mask_cmd,
       "aggregate-address A.B.C.D A.B.C.D",
       "Configure BGP aggregate entries\n"
       "Aggregate address\n"
       "Aggregate mask\n")
{
    int ret;
    char prefix_str[BUFSIZ];

    ret = netmask_str2prefix_str (argv[0], argv[1], prefix_str);

    if (! ret)
    {
        vty_out (zlog_default,LOG_DEBUG, "%% Inconsistent address and mask%s", VTY_NEWLINE);
        return CMD_WARNING;
    }

    return bgp_aggregate_set (vty, prefix_str, AFI_IP, bgp_node_safi (vty),
                              0, 0);
}

DEFUN (aggregate_address_summary_only,
       aggregate_address_summary_only_cmd,
       "aggregate-address A.B.C.D/M summary-only",
       "Configure BGP aggregate entries\n"
       "Aggregate prefix\n"
       "Filter more specific routes from updates\n")
{
    return bgp_aggregate_set (vty, argv[0], AFI_IP, bgp_node_safi (vty),
                              AGGREGATE_SUMMARY_ONLY, 0);
}

DEFUN (aggregate_address_mask_summary_only,
       aggregate_address_mask_summary_only_cmd,
       "aggregate-address A.B.C.D A.B.C.D summary-only",
       "Configure BGP aggregate entries\n"
       "Aggregate address\n"
       "Aggregate mask\n"
       "Filter more specific routes from updates\n")
{
    int ret;
    char prefix_str[BUFSIZ];

    ret = netmask_str2prefix_str (argv[0], argv[1], prefix_str);

    if (! ret)
    {
        vty_out (zlog_default,LOG_DEBUG, "%% Inconsistent address and mask%s", VTY_NEWLINE);
        return CMD_WARNING;
    }

    return bgp_aggregate_set (vty, prefix_str, AFI_IP, bgp_node_safi (vty),
                              AGGREGATE_SUMMARY_ONLY, 0);
}

DEFUN (aggregate_address_as_set,
       aggregate_address_as_set_cmd,
       "aggregate-address A.B.C.D/M as-set",
       "Configure BGP aggregate entries\n"
       "Aggregate prefix\n"
       "Generate AS set path information\n")
{
    return bgp_aggregate_set (vty, argv[0], AFI_IP, bgp_node_safi (vty),
                              0, AGGREGATE_AS_SET);
}

DEFUN (aggregate_address_mask_as_set,
       aggregate_address_mask_as_set_cmd,
       "aggregate-address A.B.C.D A.B.C.D as-set",
       "Configure BGP aggregate entries\n"
       "Aggregate address\n"
       "Aggregate mask\n"
       "Generate AS set path information\n")
{
    int ret;
    char prefix_str[BUFSIZ];

    ret = netmask_str2prefix_str (argv[0], argv[1], prefix_str);

    if (! ret)
    {
        vty_out (zlog_default,LOG_DEBUG, "%% Inconsistent address and mask%s", VTY_NEWLINE);
        return CMD_WARNING;
    }

    return bgp_aggregate_set (vty, prefix_str, AFI_IP, bgp_node_safi (vty),
                              0, AGGREGATE_AS_SET);
}


DEFUN (aggregate_address_as_set_summary,
       aggregate_address_as_set_summary_cmd,
       "aggregate-address A.B.C.D/M as-set summary-only",
       "Configure BGP aggregate entries\n"
       "Aggregate prefix\n"
       "Generate AS set path information\n"
       "Filter more specific routes from updates\n")
{
    return bgp_aggregate_set (vty, argv[0], AFI_IP, bgp_node_safi (vty),
                              AGGREGATE_SUMMARY_ONLY, AGGREGATE_AS_SET);
}


DEFUN (aggregate_address_mask_as_set_summary,
       aggregate_address_mask_as_set_summary_cmd,
       "aggregate-address A.B.C.D A.B.C.D as-set summary-only",
       "Configure BGP aggregate entries\n"
       "Aggregate address\n"
       "Aggregate mask\n"
       "Generate AS set path information\n"
       "Filter more specific routes from updates\n")
{
    int ret;
    char prefix_str[BUFSIZ];

    ret = netmask_str2prefix_str (argv[0], argv[1], prefix_str);

    if (! ret)
    {
        vty_out (zlog_default,LOG_DEBUG, "%% Inconsistent address and mask%s", VTY_NEWLINE);
        return CMD_WARNING;
    }

    return bgp_aggregate_set (vty, prefix_str, AFI_IP, bgp_node_safi (vty),
                              AGGREGATE_SUMMARY_ONLY, AGGREGATE_AS_SET);
}


DEFUN (no_aggregate_address,
       no_aggregate_address_cmd,
       "no aggregate-address A.B.C.D/M",
       NO_STR
       "Configure BGP aggregate entries\n"
       "Aggregate prefix\n")
{
    return bgp_aggregate_unset (vty, argv[0], AFI_IP, bgp_node_safi (vty));
}


DEFUN (no_aggregate_address_mask,
       no_aggregate_address_mask_cmd,
       "no aggregate-address A.B.C.D A.B.C.D",
       NO_STR
       "Configure BGP aggregate entries\n"
       "Aggregate address\n"
       "Aggregate mask\n")
{
    int ret;
    char prefix_str[BUFSIZ];

    ret = netmask_str2prefix_str (argv[0], argv[1], prefix_str);

    if (! ret)
    {
        vty_out (zlog_default,LOG_DEBUG, "%% Inconsistent address and mask%s", VTY_NEWLINE);
        return CMD_WARNING;
    }

    return bgp_aggregate_unset (vty, prefix_str, AFI_IP, bgp_node_safi (vty));
}



/* Redistribute route treatment. */
void
Bgp::bgp_redistribute_add (struct prefix *p, struct in_addr *nexthop,
                           u_int32_t metric, u_char type)
{
    struct bgp *bgp;
    struct listnode *nn;
    struct bgp_info *New;
    struct bgp_node *rn;
    struct attr attr;
    struct attr attr_new;
    struct bgp_info info;
    afi_t afi;
    int ret;

    /* Make default attribute. */
    bgp_attr_default_set (&attr, BGP_ORIGIN_INCOMPLETE);
    if (nexthop)
        attr.nexthop = *nexthop;

    attr.med = metric;
    attr.flag |= ATTR_FLAG_BIT (BGP_ATTR_MULTI_EXIT_DISC);
    for (nn = bgp_list->head; nn; nn = nn->next)
        if ((bgp = ( struct bgp * ) nn->data) != NULL)
        {
            afi = family2afi (p->family);

            if (bgp->redist[afi][type])
            {
                /* Copy attribute for modification. */
                attr_new = attr;

                /* Apply route-map. */
                if (bgp->rmap[afi][type].map)
                {
                    info.peer = peer_self;
                    info.attr = &attr_new;

                    ret = route_map_apply (bgp->rmap[afi][type].map, p, RMAP_BGP,
                                           &info);
                    if (ret == RMAP_DENYMATCH)
                    {
                        /* Free uninterned attribute. */
                        bgp_attr_flush (&attr_new);

                        /* Unintern original. */
                        aspath_unintern (attr.aspath);
                        return;
                    }
                }

                New = bgp_info_new ();
                New->type = type;
                New->peer = peer_self;
                SET_FLAG (New->flags, BGP_INFO_VALID);
                New->attr = bgp_attr_intern (&attr_new);
		double simulation_time;
		simulation_time = Scheduler::instance().clock();
		time_t clock = (int)simulation_time + start_time;
                New->uptime = clock;

                rn = bgp_route_node_get (bgp, afi, SAFI_UNICAST, p, NULL);
                bgp_aggregate_increment (bgp, p, New, afi, SAFI_UNICAST);
                bgp_info_add ((struct bgp_info **) &rn->info, New);
                bgp_process (bgp, rn, afi, SAFI_UNICAST, NULL, NULL, NULL);
            }
        }

        /* Unintern original. */
    aspath_unintern (attr.aspath);
}

void
Bgp::bgp_redistribute_delete (struct prefix *p, u_char type)
{
    struct bgp *bgp;
    struct listnode *nn;
    afi_t afi;
    struct bgp_node *rn;
    struct bgp_info *ri;
    for (nn = bgp_list->head; nn; nn = nn->next)
        if ((bgp =( struct bgp * )  nn->data) != NULL)
        {
            afi = family2afi (p->family);

            if (bgp->redist[afi][type])
            {
                rn = bgp_route_node_get (bgp, afi, SAFI_UNICAST, p, NULL);

                for (ri = ( struct bgp_info * ) rn->info; ri; ri = ri->next)
                    if (ri->peer == peer_self
                        && ri->type == type)
                        break;

                if (ri)
                {
                    bgp_aggregate_decrement (bgp, p, ri, afi, SAFI_UNICAST);
                    bgp_info_delete ((struct bgp_info **) &rn->info, ri);
                    bgp_process (bgp, rn, afi, SAFI_UNICAST, ri, NULL, NULL);
                    bgp_info_free (ri);
                    route_unlock_node (rn);
                }
                route_unlock_node (rn);
            }
        }
}

/* Withdraw specified route type's route. */
void
Bgp::bgp_redistribute_withdraw (struct bgp *bgp, afi_t afi, int type)
{
    struct bgp_node *rn;
    struct bgp_info *ri;
    struct bgp_table *table;

    table = bgp->rib[afi][SAFI_UNICAST];

    for (rn = route_top (table); rn; rn = route_next (rn))
    {
        for (ri = ( struct bgp_info * ) rn->info; ri; ri = ri->next)
            if (ri->peer == peer_self
                && ri->type == type)
                break;

        if (ri)
        {
            bgp_aggregate_decrement (bgp, &rn->p, ri, afi, SAFI_UNICAST);
            bgp_info_delete ((struct bgp_info **) &rn->info, ri);
            bgp_process (bgp, rn, afi, SAFI_UNICAST, ri, NULL, NULL);
            bgp_info_free (ri);
            route_unlock_node (rn);
        }
    }
}

/* Static function to display route. */
void
Bgp::route_vty_out_route (struct prefix *p, struct vty *vty)
{
    int len;
    u_int32_t destination; 
    char buf[BUFSIZ];

    len = vty_out (zlog_default, LOG_DEBUG, "%s", Bgp::inet_ntop (p->family, &p->u.prefix, buf, BUFSIZ));
    destination = ntohl (p->u.prefix4.s_addr);

    if ((IN_CLASSC (destination) && p->prefixlen == 24)
        || (IN_CLASSB (destination) && p->prefixlen == 16)
        || (IN_CLASSA (destination) && p->prefixlen == 8))
    {
        /* When mask is natural, mask is not displayed. */
    } else
      vty_out (zlog_default, LOG_DEBUG, "/%d", p->prefixlen);

    len = 17 - len;
    if (len < 1)
      zlog (zlog_default, LOG_DEBUG, "%s%*s", VTY_NEWLINE, 20, " ");
    else
      vty_out (zlog_default, LOG_DEBUG, "%*s", len, " ");
}

/* Calculate line number of output data. */
int
Bgp::vty_calc_line (struct vty *vty, unsigned long length)
{
    return 1;
}


/* called from terminal list command */
int
Bgp::route_vty_out (struct vty *vty, struct prefix *p,
                    struct bgp_info *binfo, int display, safi_t safi)
{
    struct attr *attr;
    unsigned long length = 0;

    /* Route status display. */
    if (binfo->suppress)
        vty_out (zlog_default, LOG_DEBUG, "s");
    else if (! CHECK_FLAG (binfo->flags, BGP_INFO_HISTORY))
        vty_out (zlog_default, LOG_DEBUG, "*");
    else
        vty_out (zlog_default, LOG_DEBUG, " ");

    /* Selected */
    if (CHECK_FLAG (binfo->flags, BGP_INFO_HISTORY))
        vty_out (zlog_default, LOG_DEBUG, "h");
    else if (CHECK_FLAG (binfo->flags, BGP_INFO_DAMPED))
        vty_out (zlog_default, LOG_DEBUG, "d");
    else if (CHECK_FLAG (binfo->flags, BGP_INFO_SELECTED))
        vty_out (zlog_default, LOG_DEBUG, ">");
    else
        vty_out (zlog_default, LOG_DEBUG, " ");

    /* Internal route. */
    if ((binfo->peer->as) && (binfo->peer->as == binfo->peer->local_as))
        vty_out (zlog_default, LOG_DEBUG, " i");
    else
        vty_out (zlog_default, LOG_DEBUG, " ");

    /* print prefix and mask */
    if (! display)
        route_vty_out_route (p, vty);
    else
        vty_out (zlog_default, LOG_DEBUG, "%*s", 17, " ");

    /* Print attribute */
    attr = binfo->attr;
    if (attr)
    {
        if (p->family == AF_INET)
        {
	  vty_out (zlog_default, LOG_DEBUG, "%-16s", inet_ntoa (attr->nexthop));
        }

        if (attr->flag & ATTR_FLAG_BIT (BGP_ATTR_MULTI_EXIT_DISC))
            vty_out (zlog_default, LOG_DEBUG, "%10d", attr->med);
        else
            vty_out (zlog_default, LOG_DEBUG, "          ");

        if (attr->flag & ATTR_FLAG_BIT (BGP_ATTR_LOCAL_PREF))
            vty_out (zlog_default, LOG_DEBUG, "%7d", attr->local_pref);
        else
            vty_out (zlog_default, LOG_DEBUG, "       ");

        vty_out (zlog_default, LOG_DEBUG, "%7u ",attr->weight);

        /* Print aspath */
        if (attr->aspath)
            aspath_print_vty (vty, attr->aspath);

        /* Print origin */
        if (strlen (attr->aspath->str) == 0)
            vty_out (zlog_default, LOG_DEBUG, "%s", bgp_origin_str[attr->origin]);
        else
            vty_out (zlog_default, LOG_DEBUG, "%s", bgp_origin_str[attr->origin]);
    }
    vty_out (zlog_default, LOG_DEBUG, "%s", VTY_NEWLINE);

    return vty_calc_line (vty, length);
}  

/* called from terminal list command */
void
Bgp::route_vty_out_tmp (struct vty *vty, struct prefix *p,
                        struct attr *attr, safi_t safi)
{
    /* Route status display. */
    vty_out (zlog_default,LOG_DEBUG, "*");
    vty_out (zlog_default,LOG_DEBUG, ">");
    vty_out (zlog_default,LOG_DEBUG, " ");

    /* print prefix and mask */
    route_vty_out_route (p, vty);

    /* Print attribute */
    if (attr)
    {
        if (p->family == AF_INET)
        {
	  vty_out (zlog_default,LOG_DEBUG, "%-16s", inet_ntoa (attr->nexthop));
        }

        if (attr->flag & ATTR_FLAG_BIT (BGP_ATTR_MULTI_EXIT_DISC))
            vty_out (zlog_default,LOG_DEBUG, "%10d", attr->med);
        else
            vty_out (zlog_default,LOG_DEBUG, "          ");

        if (attr->flag & ATTR_FLAG_BIT (BGP_ATTR_LOCAL_PREF))
            vty_out (zlog_default,LOG_DEBUG, "%7d", attr->local_pref);
        else
            vty_out (zlog_default,LOG_DEBUG, "       ");

        vty_out (zlog_default,LOG_DEBUG, "%7d ",attr->weight);

        /* Print aspath */
        if (attr->aspath)
            aspath_print_vty (vty, attr->aspath);

        /* Print origin */
        if (strlen (attr->aspath->str) == 0)
            vty_out (zlog_default,LOG_DEBUG, "%s", bgp_origin_str[attr->origin]);
        else
            vty_out (zlog_default,LOG_DEBUG, " %s", bgp_origin_str[attr->origin]);
    }

    vty_out (zlog_default,LOG_DEBUG, "%s", VTY_NEWLINE);
}  


void
Bgp::route_vty_out_detail (struct vty *vty, struct prefix *p, 
                           struct bgp_info *binfo, afi_t afi, safi_t safi)
{
    char buf[INET6_ADDRSTRLEN];
    char buf1[BUFSIZ];
    struct attr *attr;
    struct bgp *bgp;
    int sockunion_vty_out (struct vty *, union sockunion *);

    attr = binfo->attr;
    bgp = bgp_get_default ();

    if (attr)
    {
        /* Line1 display AS-path, Aggregator */
        if (attr->aspath)
        {
            vty_out (zlog_default,LOG_DEBUG, "  ");
            if (attr->aspath->length == 0)
                vty_out (zlog_default,LOG_DEBUG, "Local");
            else
                aspath_print_vty (vty, attr->aspath);
        }

        if (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_AGGREGATOR)
            || CHECK_FLAG (binfo->peer->af_flags[afi][safi], PEER_FLAG_REFLECTOR_CLIENT)
            || CHECK_FLAG (binfo->peer->af_flags[afi][safi], PEER_FLAG_RSERVER_CLIENT)
            || CHECK_FLAG (binfo->flags, BGP_INFO_HISTORY)
            || CHECK_FLAG (binfo->flags, BGP_INFO_DAMPED))
        {
            vty_out (zlog_default,LOG_DEBUG, ",");

            if (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_AGGREGATOR))
                vty_out (zlog_default,LOG_DEBUG, " (aggregated by %d %s)", attr->aggregator_as,
                         inet_ntoa (attr->aggregator_addr));
            if (CHECK_FLAG (binfo->peer->af_flags[afi][safi], PEER_FLAG_REFLECTOR_CLIENT))
                vty_out (zlog_default,LOG_DEBUG, " (Received from a RR-client)");
            if (CHECK_FLAG (binfo->peer->af_flags[afi][safi], PEER_FLAG_RSERVER_CLIENT))
                vty_out (zlog_default,LOG_DEBUG, " (Received from a RS-client)");
            if (CHECK_FLAG (binfo->flags, BGP_INFO_HISTORY))
                vty_out (zlog_default,LOG_DEBUG, " (history entry)");
            else if (CHECK_FLAG (binfo->flags, BGP_INFO_DAMPED))
                vty_out (zlog_default,LOG_DEBUG, " (suppressed due to dampening)");
        }
        vty_out (zlog_default,LOG_DEBUG, "%s", VTY_NEWLINE);

        /* Line2 display Next-hop, Neighbor, Router-id */

	vty_out (zlog_default,LOG_DEBUG, "    Next-hop, Neighbor, Router-id:");
	if (p->family == AF_INET)
        {
            vty_out (zlog_default,LOG_DEBUG, " %s", 
		     inet_ntoa (attr->nexthop));
        }

        if (binfo->peer == peer_self)
        {
            vty_out (zlog_default,LOG_DEBUG, " from %s ", 
                     p->family == AF_INET ? "0.0.0.0" : "::");
            vty_out (zlog_default,LOG_DEBUG, "(%s)", inet_ntoa(bgp->id));
        } else
        {
            if (! CHECK_FLAG (binfo->flags, BGP_INFO_VALID))
                vty_out (zlog_default,LOG_DEBUG, " (inaccessible)");
            else if (binfo->igpmetric)
                vty_out (zlog_default,LOG_DEBUG, " (metric %d)", binfo->igpmetric);
            vty_out (zlog_default,LOG_DEBUG, " from %s", sockunion2str (&binfo->peer->su, buf, SU_ADDRSTRLEN));
            if (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_ORIGINATOR_ID))
                vty_out (zlog_default,LOG_DEBUG, " (%s)", inet_ntoa (attr->originator_id));
            else
                vty_out (zlog_default,LOG_DEBUG, " (%s)", Bgp::inet_ntop (AF_INET, &binfo->peer->remote_id, buf1, BUFSIZ));
        }
        vty_out (zlog_default,LOG_DEBUG, "%s", VTY_NEWLINE);


        /* Line 3 display Origin, Med, Locpref, Weight, valid, Int/Ext/Local, Atomic, best */
        vty_out (zlog_default,LOG_DEBUG, "      Origin %s", bgp_origin_long_str[attr->origin]);

        if (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_MULTI_EXIT_DISC))
            vty_out (zlog_default,LOG_DEBUG, ", metric %d", attr->med);

        if (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_LOCAL_PREF))
            vty_out (zlog_default,LOG_DEBUG, ", localpref %d", attr->local_pref);
        else
            vty_out (zlog_default,LOG_DEBUG, ", localpref %d", bgp->default_local_pref);

        if (attr->weight != 0)
            vty_out (zlog_default,LOG_DEBUG, ", weight %d", attr->weight);

        if (! CHECK_FLAG (binfo->flags, BGP_INFO_HISTORY))
            vty_out (zlog_default,LOG_DEBUG, ", valid");

        if (binfo->peer != peer_self)
        {
            if (binfo->peer->as == binfo->peer->local_as)
                vty_out (zlog_default,LOG_DEBUG, ", internal");
            else
                vty_out (zlog_default,LOG_DEBUG, ", %s", 
                         (bgp_confederation_peers_check(bgp, binfo->peer->as) ? "confed-external" : "external"));
        } else if (binfo->sub_type == BGP_ROUTE_AGGREGATE)
            vty_out (zlog_default,LOG_DEBUG, ", aggregated, local");
        else if (binfo->type != ZEBRA_ROUTE_BGP)
            vty_out (zlog_default,LOG_DEBUG, ", sourced");
        else
            vty_out (zlog_default,LOG_DEBUG, ", sourced, local");

        if (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_ATOMIC_AGGREGATE))
            vty_out (zlog_default,LOG_DEBUG, ", atomic-aggregate");

        if (CHECK_FLAG (binfo->flags, BGP_INFO_SELECTED))
            vty_out (zlog_default,LOG_DEBUG, ", best");

        vty_out (zlog_default,LOG_DEBUG, "%s", VTY_NEWLINE);

        /* Line 4 display Community */
        if (attr->community)
        {
            vty_out (zlog_default,LOG_DEBUG, "      Community:");
            community_print_vty (vty, attr->community);
            vty_out (zlog_default,LOG_DEBUG, "%s", VTY_NEWLINE);
        }

        /* Line 5 display Extended-community */
        if (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_EXT_COMMUNITIES))
        {
            vty_out (zlog_default,LOG_DEBUG, "      Extended Community:");
            ecommunity_vty_out ( attr->ecommunity);
            vty_out (zlog_default,LOG_DEBUG, "%s", VTY_NEWLINE);
        }

        /* Line 6 display Originator, Cluster-id */
        if ((attr->flag & ATTR_FLAG_BIT(BGP_ATTR_ORIGINATOR_ID)) ||
            (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_CLUSTER_LIST)))
        {
            if (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_ORIGINATOR_ID))
                vty_out (zlog_default,LOG_DEBUG, "      Originator: %s", inet_ntoa (attr->originator_id));

            if (attr->flag & ATTR_FLAG_BIT(BGP_ATTR_CLUSTER_LIST))
            {
                int i;
                vty_out (zlog_default,LOG_DEBUG, ", Cluster list: ");
                for (i = 0; i < attr->cluster->length / 4; i++)
                    vty_out (zlog_default,LOG_DEBUG, "%s ", inet_ntoa (attr->cluster->list[i]));
            }
            vty_out (zlog_default,LOG_DEBUG, "%s", VTY_NEWLINE);
        }

#ifndef HAVE_ZEBRA_93b

        if (binfo->bgp_damp_info)
	  bgp_damp_info_print (vty, binfo);

#else 

        if (binfo->damp_info)
          bgp_damp_info_vty (vty, binfo);
	
#endif

        /* Line 7 display Uptime */
        vty_out (zlog_default,LOG_DEBUG, "      Last update: %s", ctime (&binfo->uptime));
    }
    vty_out (zlog_default,LOG_DEBUG, "%s", VTY_NEWLINE);
}  

int
Bgp::bgp_show (struct vty *vty, char *view_name, afi_t afi, safi_t safi,
               enum bgp_show_type type)
{
    struct bgp *bgp;
    struct bgp_info *ri;
    struct bgp_node *rn;
    struct bgp_table *table;
    int header = 1;
    int count;
    int display;

    /* BGP structure lookup. */
    {
        bgp = bgp_get_default ();
        if (bgp == NULL)
        {
            vty_out (zlog_default, LOG_DEBUG, "No BGP process is configured%s", VTY_NEWLINE);
            return CMD_WARNING;
        }
    }

    count = 0;

    /* This is first entry point, so reset total line. */
    vty->output_count = 0;

    table = bgp->rib[afi][safi];

    /* Start processing of routes. */
    for (rn = route_top (table); rn; rn = route_next (rn))
        if (rn->info != NULL)
        {
            display = 0;

            for (ri = ( struct bgp_info * ) rn->info; ri; ri = ri->next)
            {
                if (type == bgp_show_type_regexp)
                {
                    regex_t *regex = ( regex_t * ) vty->output_arg;

                    if (bgp_regexec (regex, ri->attr->aspath) == REG_NOMATCH)
                        continue;
                }
                if (type == bgp_show_type_prefix_list)
                {
                    struct prefix_list *plist = ( struct prefix_list* ) vty->output_arg;

                    if (prefix_list_apply (plist, &rn->p) != PREFIX_PERMIT)
                        continue;
                }
                if (type == bgp_show_type_filter_list)
                {
                    struct as_list *as_list = ( struct as_list * ) vty->output_arg;

                    if (as_list_apply (as_list, ri->attr->aspath) != AS_FILTER_PERMIT)
                        continue;
                }
                if (type == bgp_show_type_neighbor)
                {
                    union sockunion *su = ( union sockunion *) vty->output_arg;

                    if (ri->peer->su_remote == NULL || ! sockunion_same(ri->peer->su_remote, su))
                        continue;
                }
                if (type == bgp_show_type_cidr_only)
                {
                    u_int32_t destination;

                    destination = ntohl (rn->p.u.prefix4.s_addr);
                    if (IN_CLASSC (destination) && rn->p.prefixlen == 24)
                        continue;
                    if (IN_CLASSB (destination) && rn->p.prefixlen == 16)
                        continue;
                    if (IN_CLASSA (destination) && rn->p.prefixlen == 8)
                        continue;
                }
                if (type == bgp_show_type_prefix_longer)
                {
                    struct prefix *p = ( struct prefix * ) vty->output_arg;

                    if (! prefix_match (p, &rn->p))
                        continue;
                }
                if (type ==  bgp_show_type_community_all)
                {
                    if (! ri->attr->community)
                        continue;
                }
                if (type == bgp_show_type_community)
                {
                    struct community *com = ( struct community * ) vty->output_arg;

                    if (! ri->attr->community ||
                        ! community_match (ri->attr->community, com))
                        continue;
                }
                if (type == bgp_show_type_community_exact)
                {
                    struct community *com = ( struct community * ) vty->output_arg;

                    if (! ri->attr->community ||
                        ! community_cmp (ri->attr->community, com))
                        continue;
                }
                if (type == bgp_show_type_community_list)
                {
                    struct community_list *list = ( struct community_list * ) vty->output_arg;

                    if (! community_list_match (ri->attr->community, list))
                        continue;
                }
                if (type == bgp_show_type_community_list_exact)
                {
                    struct community_list *list = ( struct community_list * ) vty->output_arg;

                    if (! community_list_match_exact (ri->attr->community, list))
                        continue;
                }

                if (header)
                {
                    vty_out (zlog_default, LOG_DEBUG, "BGP table version is 0, local router ID is %s%s", inet_ntoa (bgp->id), VTY_NEWLINE);
                    vty_out (zlog_default, LOG_DEBUG, "Status codes: s suppressed, d damped, h history, * valid, > best, i - internal%s", VTY_NEWLINE);
                    vty_out (zlog_default, LOG_DEBUG, "Origin codes: i - IGP, e - EGP, ? - incomplete%s%s", VTY_NEWLINE, VTY_NEWLINE);
                    if (afi == AFI_IP)
                        vty_out (zlog_default, LOG_DEBUG, BGP_SHOW_V4_HEADER, VTY_NEWLINE);
		    //                    else if (afi == AFI_IP6)
		    //                        vty_out (zlog_default, LOG_DEBUG, BGP_SHOW_V6_HEADER, VTY_NEWLINE);
                    count += 5;
                    header = 0;
                }

                if (afi == AFI_IP)
                {
                    count += route_vty_out (vty, &rn->p, ri, display, SAFI_UNICAST);
                    display++;
                }

            }
            if (display)
	      vty->output_count++;
        }

        /* No route is displayed */
    if (vty->output_count == 0)
    {
        if (type == bgp_show_type_normal)
            vty_out (zlog_default, LOG_DEBUG, "No BGP network exists%s", VTY_NEWLINE);
    } else
        vty_out (zlog_default, LOG_DEBUG, "%sTotal number of prefixes %ld%s",
                 VTY_NEWLINE, vty->output_count, VTY_NEWLINE);

    /* Clean up allocated resources. */
    if (vty->output_clean)
        (this->*vty->output_clean) (vty);

    vty->output_clean = NULL;
    vty->output_arg = NULL;

    return CMD_SUCCESS;
}

/* Display specified route of BGP table. */
int
Bgp::bgp_show_route (struct vty *vty, char *view_name, char *ip_str,
                     afi_t afi, safi_t safi, int prefix_check)
{
    int ret;
    int count = 0;
    int best = 0;
    int suppress = 0;
    int no_export = 0;
    int no_advertise = 0;
    int local_as = 0;
    char buf[INET6_ADDRSTRLEN];
    struct bgp *bgp;
    struct prefix match;
    struct prefix *p;
    struct bgp_node *rn;
    struct bgp_info *ri;
#ifdef HAVE_ZEBRA_93b
    struct peer *peer;
#else
    struct peer_conf *conf;
#endif
    struct listnode *nn;
    int first = 0;

    {
        bgp = bgp_get_default ();
        if (bgp == NULL)
        {
            vty_out (zlog_default,LOG_DEBUG, "No BGP process is configured%s", VTY_NEWLINE);
            return CMD_WARNING;
        }
    }

    /* Check IP address argument. */
    ret = str2prefix (ip_str, &match);
    if (! ret)
    {
        vty_out (zlog_default,LOG_DEBUG, "address is malformed%s", VTY_NEWLINE);
        return CMD_WARNING;
    }

    match.family = afi2family (afi);

    /* Lookup route node. */
    rn = route_node_match (bgp->rib[afi][safi], &match);
    if (rn == NULL)
    {
        vty_out (zlog_default,LOG_DEBUG, "%% Network not in table%s", VTY_NEWLINE);
        return CMD_WARNING;
    }

    p = &rn->p; 
    if (prefix_check)
    {
        if (p->prefixlen != match.prefixlen)
        {
            vty_out (zlog_default,LOG_DEBUG, "%% Network not in table%s",ip_str, VTY_NEWLINE);
            return CMD_WARNING;
        }
    }

    /* Header of detailed BGP route information */
    for (ri = ( struct bgp_info * )rn->info; ri; ri = ri->next)
    {
        count++;
        if (CHECK_FLAG (ri->flags, BGP_INFO_SELECTED))
        {
            best = count;
            if (ri->suppress)
                suppress = 1;
            if (ri->attr->community != NULL)
            {
                if (community_include (ri->attr->community, COMMUNITY_NO_ADVERTISE))
                    no_advertise = 1;
                if (community_include (ri->attr->community, COMMUNITY_NO_EXPORT))
                    no_export = 1;
                if (community_include (ri->attr->community, COMMUNITY_LOCAL_AS))
                    local_as = 1;
            }
        }
    }
    vty_out (zlog_default,LOG_DEBUG, "BGP routing table entry for %s/%d%s",
             Bgp::inet_ntop (p->family, &p->u.prefix, buf, INET6_ADDRSTRLEN),
             p->prefixlen, VTY_NEWLINE); 

    vty_out (zlog_default,LOG_DEBUG, "Paths: (%d available", count);
    if (best)
    {
        vty_out (zlog_default,LOG_DEBUG, ", best #%d", best);
        if (safi == SAFI_UNICAST)
            vty_out (zlog_default,LOG_DEBUG, ", table Default-IP-Routing-Table");
    } else
        vty_out (zlog_default,LOG_DEBUG, ", no best path"); 
    if (no_advertise)
        vty_out (zlog_default,LOG_DEBUG, ", not advertised to any peer");
    else if (no_export)
        vty_out (zlog_default,LOG_DEBUG, ", not advertised to EBGP peer");
    else if (local_as)
        vty_out (zlog_default,LOG_DEBUG, ", not advertised outside local AS");
    if (suppress)
        vty_out (zlog_default,LOG_DEBUG, ", Advertisements suppressed by an aggregate.");
    vty_out (zlog_default,LOG_DEBUG, ")%s", VTY_NEWLINE);

    /* advertised peer */
#ifdef HAVE_ZEBRA_93b
    for (nn = peer_list->head; nn; nn = nn->next)
        if (( peer = ( struct peer *) nn->data) != NULL)
        {
            if (bgp_adj_out_lookup (peer, p, afi, safi, rn))
            {
                if (! first)
                    vty_out (zlog_default,LOG_DEBUG, "  Advertised to non peer-group peers:%s ", VTY_NEWLINE);
                vty_out (zlog_default,LOG_DEBUG, " %s", sockunion2str (&peer->su, buf, SU_ADDRSTRLEN));
                first = 1;
            }
        }
#else 
    for (nn = bgp->peer_conf->head; nn; nn = nn->next)
        if ((conf = ( struct peer_conf *) nn->data) != NULL)
        {
            if (bgp_adj_lookup (conf->peer->adj_out[afi][safi], p, NULL, safi))
            {
                if (! first)
                    vty_out (zlog_default,LOG_DEBUG, "  Advertised to non peer-group peers:%s ", VTY_NEWLINE);
                vty_out (zlog_default,LOG_DEBUG, " %s", sockunion2str (&conf->peer->su, buf, SU_ADDRSTRLEN));
                first = 1;
            }
        }
#endif

    if (! first)
        vty_out (zlog_default,LOG_DEBUG, "  Not advertised to any peer");
    vty_out (zlog_default,LOG_DEBUG, "%s", VTY_NEWLINE);

    /* Node is locked by route_node_match(). */
    for (ri = ( struct bgp_info * ) rn->info; ri; ri = ri->next)
        route_vty_out_detail (vty, &rn->p, ri, afi, safi);

    /* Work is done, so unlock the node. */
    route_unlock_node (rn);

    return CMD_SUCCESS;
}

/* BGP route print out function. */
DEFUN (show_ip_bgp,
       show_ip_bgp_cmd,
       "show ip bgp",
       SHOW_STR
       IP_STR
       BGP_STR)
{
    return bgp_show (vty, NULL, AFI_IP, SAFI_UNICAST, bgp_show_type_normal);
}

DEFUN (show_ip_bgp_route,
       show_ip_bgp_route_cmd,
       "show ip bgp A.B.C.D",
       SHOW_STR
       IP_STR
       BGP_STR
       "Network in the BGP routing table to display\n")
{
    return bgp_show_route (vty, NULL, argv[0], AFI_IP, SAFI_UNICAST, 0);
}

DEFUN (show_ip_bgp_prefix,
       show_ip_bgp_prefix_cmd,
       "show ip bgp A.B.C.D/M",
       SHOW_STR
       IP_STR
       BGP_STR
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n")
{
    return bgp_show_route (vty, NULL, argv[0], AFI_IP, SAFI_UNICAST, 1);
}


void
Bgp::bgp_show_regexp_clean (struct vty *vty)
{
    bgp_regex_free (( regex_t * ) vty->output_arg);
}

int
Bgp::bgp_show_regexp (struct vty *vty, int argc, char **argv, u_int16_t afi,
                      u_char safi)
{
    int i;
    struct buffer *b;
    char *regstr;
    int first;
    regex_t *regex;

    first = 0;
    b = buffer_new (1024);
    for (i = 0; i < argc; i++)
    {
        if (first)
            buffer_putc (b, ' ');
        else
        {
            if ((strcmp (argv[i], "unicast") == 0) || (strcmp (argv[i], "multicast") == 0))
                continue;
            first = 1;
        }

        buffer_putstr (b, ( u_char * ) argv[i]);
    }
    buffer_putc (b, '\0');

    regstr = buffer_getstr (b);
    buffer_free (b);

    regex = bgp_regcomp (regstr);
    if (! regex)
    {
        vty_out (zlog_default,LOG_DEBUG, "Cant compile regexp %s%s", argv[0],
                 VTY_NEWLINE);
        return CMD_WARNING;
    }

    vty->output_arg = regex;
    vty->output_clean = &Bgp::bgp_show_regexp_clean;

    return bgp_show (vty, NULL, afi, safi, bgp_show_type_regexp);
}

DEFUN (show_ip_bgp_regexp, 
       show_ip_bgp_regexp_cmd,
       "show ip bgp regexp .LINE",
       SHOW_STR
       IP_STR
       BGP_STR
       "Display routes matching the AS path regular expression\n"
       "A regular-expression to match the BGP AS paths\n")
{
    return bgp_show_regexp (vty, argc, argv, AFI_IP, SAFI_UNICAST);
}

int
Bgp::bgp_show_prefix_list (struct vty *vty, char *prefix_list_str, u_int16_t afi,
                           u_char safi)
{
    struct prefix_list *plist;

    plist = prefix_list_lookup (afi, prefix_list_str);
    if (plist == NULL)
    {
        vty_out (zlog_default,LOG_DEBUG, "%% %s is not a valid prefix-list name%s", prefix_list_str, VTY_NEWLINE);       
        return CMD_WARNING;
    }

    vty->output_arg = plist;

    return bgp_show (vty, NULL, afi, safi, bgp_show_type_prefix_list);
}

DEFUN (show_ip_bgp_prefix_list, 
       show_ip_bgp_prefix_list_cmd,
       "show ip bgp prefix-list WORD",
       SHOW_STR
       IP_STR
       BGP_STR
       "Display routes matching the prefix-list\n"
       "IP prefix-list name\n")
{
    return bgp_show_prefix_list (vty, argv[0], AFI_IP, SAFI_UNICAST);
}

int
Bgp::bgp_show_filter_list (struct vty *vty, char *filter, u_int16_t afi,
                           u_char safi)
{
    struct as_list *as_list;

    as_list = as_list_lookup (filter);
    if (as_list == NULL)
    {
        vty_out (zlog_default,LOG_DEBUG, "%% %s is not a valid AS-path access-list name%s", filter, VTY_NEWLINE);        
        return CMD_WARNING;
    }

    vty->output_arg = as_list;

    return bgp_show (vty, NULL, afi, safi, bgp_show_type_filter_list);
}

DEFUN (show_ip_bgp_filter_list, 
       show_ip_bgp_filter_list_cmd,
       "show ip bgp filter-list WORD",
       SHOW_STR
       IP_STR
       BGP_STR
       "Display routes conforming to the filter-list\n"
       "Regular expression access list name\n")
{
    return bgp_show_filter_list (vty, argv[0], AFI_IP, SAFI_UNICAST);
}

DEFUN (show_ip_bgp_cidr_only,
       show_ip_bgp_cidr_only_cmd,
       "show ip bgp cidr-only",
       SHOW_STR
       IP_STR
       BGP_STR
       "Display only routes with non-natural netmasks\n")
{
    return bgp_show (vty, NULL, AFI_IP, SAFI_UNICAST,
                     bgp_show_type_cidr_only);
}

DEFUN (show_ip_bgp_community_all,
       show_ip_bgp_community_all_cmd,
       "show ip bgp community",
       SHOW_STR
       IP_STR
       BGP_STR
       "Display routes matching the communities\n")
{
    return bgp_show (vty, NULL, AFI_IP, SAFI_UNICAST,
                     bgp_show_type_community_all);
}

int
Bgp::bgp_show_community (struct vty *vty, int argc, char **argv, int exact,
                         u_int16_t afi, u_char safi)
{
    struct community *com;
    struct buffer *b;
    int i;
    char *str;
    int first = 0;

    b = buffer_new (1024);
    for (i = 0; i < argc; i++)
    {
        if (first)
            buffer_putc (b, ' ');
        else
        {
            if ((strcmp (argv[i], "unicast") == 0) || (strcmp (argv[i], "multicast") == 0))
                continue;
            first = 1;
        }

        buffer_putstr (b,( u_char * )  argv[i]);
    }
    buffer_putc (b, '\0');

    str = buffer_getstr (b);
    buffer_free (b);

    com = community_str2com (str);
    free (str);
    if (! com)
    {
        vty_out (zlog_default,LOG_DEBUG, "%% Community malformed: %s", VTY_NEWLINE);
        return CMD_WARNING;
    }

    vty->output_arg = com;

    if (exact)
        return bgp_show (vty, NULL, afi, safi, bgp_show_type_community_exact);

    return bgp_show (vty, NULL, afi, safi, bgp_show_type_community);
}

DEFUN (show_ip_bgp_community,
       show_ip_bgp_community_cmd,
       "show ip bgp community (AA:NN|local-AS|no-advertise|no-export)",
       SHOW_STR
       IP_STR
       BGP_STR
       "Display routes matching the communities\n"
       "community number\n"
       "Do not send outside local AS (well-known community)\n"
       "Do not advertise to any peer (well-known community)\n"
       "Do not export to next AS (well-known community)\n")
{
    return bgp_show_community (vty, argc, argv, 0, AFI_IP, SAFI_UNICAST);
}


DEFUN (show_ip_bgp_community_exact,
       show_ip_bgp_community_exact_cmd,
       "show ip bgp community (AA:NN|local-AS|no-advertise|no-export) exact-match",
       SHOW_STR
       IP_STR
       BGP_STR
       "Display routes matching the communities\n"
       "community number\n"
       "Do not send outside local AS (well-known community)\n"
       "Do not advertise to any peer (well-known community)\n"
       "Do not export to next AS (well-known community)\n"
       "Exact match of the communities")
{
    return bgp_show_community (vty, argc, argv, 1, AFI_IP, SAFI_UNICAST);
}


int
Bgp::bgp_show_community_list (struct vty *vty, char *com, int exact,
                              u_int16_t afi, u_char safi)
{
    struct community_list *list;

    list = community_list_lookup (com);
    if (list == NULL)
    {
        vty_out (zlog_default,LOG_DEBUG, "%% %s is not a valid community-list name%s", com, VTY_NEWLINE);
        return CMD_WARNING;
    }

    vty->output_arg = list;

    if (exact)
        return bgp_show (vty, NULL, afi, safi, bgp_show_type_community_list_exact);

    return bgp_show (vty, NULL, afi, safi, bgp_show_type_community_list);
}

DEFUN (show_ip_bgp_community_list,
       show_ip_bgp_community_list_cmd,
       "show ip bgp community-list WORD",
       SHOW_STR
       IP_STR
       BGP_STR
       "Display routes matching the community-list\n"
       "community-list name\n")
{
    return bgp_show_community_list (vty, argv[0], 0, AFI_IP, SAFI_UNICAST);
}

DEFUN (show_ip_bgp_community_list_exact,
       show_ip_bgp_community_list_exact_cmd,
       "show ip bgp community-list WORD exact-match",
       SHOW_STR
       IP_STR
       BGP_STR
       "Display routes matching the community-list\n"
       "community-list name\n"
       "Exact match of the communities\n")
{
    return bgp_show_community_list (vty, argv[0], 1, AFI_IP, SAFI_UNICAST);
}


void
Bgp::bgp_show_prefix_longer_clean (struct vty *vty)
{
    struct prefix *p;
    p = ( struct prefix * ) vty->output_arg;
    prefix_free (p);
}

int
Bgp::bgp_show_prefix_longer (struct vty *vty, char *prefix,
                             u_int16_t afi, u_char safi)
{
    int ret;
    struct prefix *p;

    p = prefix_new();

    ret = str2prefix (prefix, p);
    if (! ret)
    {
        vty_out (zlog_default,LOG_DEBUG, "%% Malformed Prefix%s", VTY_NEWLINE);
        return CMD_WARNING;
    }

    vty->output_arg = p;
    vty->output_clean = &Bgp::bgp_show_prefix_longer_clean;

    return bgp_show (vty, NULL, afi, safi, bgp_show_type_prefix_longer);
}

DEFUN (show_ip_bgp_prefix_longer,
       show_ip_bgp_prefix_longer_cmd,
       "show ip bgp A.B.C.D/M longer-prefixes",
       SHOW_STR
       IP_STR
       BGP_STR
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
       "Display route and more specific routes\n")
{
    return bgp_show_prefix_longer (vty, argv[0], AFI_IP, SAFI_UNICAST);
}

#ifndef HAVE_ZEBRA_93b
void
Bgp::show_adj_route (struct vty *vty, struct peer *peer, afi_t afi, safi_t safi,
                     int in)
{
    struct bgp_table *table;
    struct bgp_node *rn;
    struct prefix *p;
    struct attr *attr;
    struct bgp *bgp;
    unsigned long output_count;
    int header = 1;

    if (in)
        table = peer->adj_in[afi][safi];
    else
        table = peer->adj_out[afi][safi];

    bgp = bgp_get_default ();
    output_count = 0;

    for (rn = route_top (table); rn; rn = route_next (rn))
        if ((attr = ( struct attr * ) rn->info) != NULL)
        {
            p = &rn->p;

            if (header)
            {
                vty_out (zlog_default,LOG_DEBUG, "BGP table version is 0, local router ID is %s%s", inet_ntoa (bgp->id), VTY_NEWLINE);
                vty_out (zlog_default,LOG_DEBUG, "Status codes: s suppressed, d damped, h history, * valid, > best, i - internal%s", VTY_NEWLINE);
                vty_out (zlog_default,LOG_DEBUG, "Origin codes: i - IGP, e - EGP, ? - incomplete%s%s", VTY_NEWLINE, VTY_NEWLINE);

                if (afi == AFI_IP)
                    vty_out (zlog_default,LOG_DEBUG, BGP_SHOW_V4_HEADER, VTY_NEWLINE);
		//                else if (afi == AFI_IP6)
		//                    vty_out (zlog_default,LOG_DEBUG, BGP_SHOW_V6_HEADER, VTY_NEWLINE);
                header = 0;
            }

            if (p->family == AF_INET)
            {
                route_vty_out_tmp (vty, p, attr, safi);
                output_count++;
            }
        }
    if (output_count != 0)
        vty_out (zlog_default,LOG_DEBUG, "%sTotal number of prefixes %ld%s",
                 VTY_NEWLINE, output_count, VTY_NEWLINE);
}
#else 

void
Bgp::show_adj_route (struct vty *vty, struct peer *peer, afi_t afi, safi_t safi,
		     int in)
{
  struct bgp_table *table;
  struct bgp_adj_in *ain;
  struct bgp_adj_out *adj;
  unsigned long output_count;
  struct bgp_node *rn;
  int header1 = 1;
  struct bgp *bgp;
  int header2 = 1;

  bgp = (struct bgp*)bgp_get_default ();

  if (! bgp)
    return;

  table = bgp->rib[afi][safi];

  output_count = 0;
	
  if (! in && CHECK_FLAG (peer->flags,
			  PEER_FLAG_DEFAULT_ORIGINATE))
    {
      vty_out (zlog_default,LOG_DEBUG, "BGP table version is 0, local router ID is %s%s", inet_ntoa (bgp->id), VTY_NEWLINE);
      vty_out (zlog_default,LOG_DEBUG, "Status codes: s suppressed, d damped, h history, * valid, > best, i - internal%s", VTY_NEWLINE);
      vty_out (zlog_default,LOG_DEBUG, "Origin codes: i - IGP, e - EGP, ? - incomplete%s%s", VTY_NEWLINE, VTY_NEWLINE);

      vty_out (zlog_default,LOG_DEBUG, "Originating default network 0.0.0.0%s%s",
	       VTY_NEWLINE, VTY_NEWLINE);
      header1 = 0;
    }

  for (rn = bgp_table_top (table); rn; rn = bgp_route_next (rn))
    if (in)
      {
	for (ain = rn->adj_in; ain; ain = ain->next)
	  if (ain->peer == peer)
	    {
	      if (header1)
		{
		  vty_out (zlog_default,LOG_DEBUG, "BGP table version is 0, local router ID is %s%s", inet_ntoa (bgp->id), VTY_NEWLINE);
		  vty_out (zlog_default,LOG_DEBUG, "Status codes: s suppressed, d damped, h history, * valid, > best, i - internal%s", VTY_NEWLINE);
		  vty_out (zlog_default,LOG_DEBUG, "Origin codes: i - IGP, e - EGP, ? - incomplete%s%s", VTY_NEWLINE, VTY_NEWLINE);
		  header1 = 0;
		}
	      if (header2)
		{
		  vty_out (zlog_default,LOG_DEBUG, BGP_SHOW_V4_HEADER, VTY_NEWLINE);
		  header2 = 0;
		}
	      if (ain->attr)
		{ 
		  route_vty_out_tmp (vty, &rn->p, ain->attr, safi);
		  output_count++;
		}
	    }
      }
    else
      {
	for (adj = rn->adj_out; adj; adj = adj->next)
	  if (adj->peer == peer)
	    {
	      if (header1)
		{
		  vty_out (zlog_default,LOG_DEBUG, "BGP table version is 0, local router ID is %s%s", inet_ntoa (bgp->id), VTY_NEWLINE);
		  vty_out (zlog_default,LOG_DEBUG, "Status codes: s suppressed, d damped, h history, * valid, > best, i - internal%s", VTY_NEWLINE);
		  vty_out (zlog_default,LOG_DEBUG, "Origin codes: i - IGP, e - EGP, ? - incomplete%s%s", VTY_NEWLINE, VTY_NEWLINE);
		  header1 = 0;
		}
	      if (header2)
		{
		  vty_out (zlog_default,LOG_DEBUG, BGP_SHOW_V4_HEADER, VTY_NEWLINE);
		  header2 = 0;
		}
	      if (adj->attr)
		{	
		  route_vty_out_tmp (vty, &rn->p, adj->attr, safi);
		  output_count++;
		}
	    }
      }
  
  if (output_count != 0)
    vty_out (zlog_default,LOG_DEBUG, "%sTotal number of prefixes %ld%s",
	     VTY_NEWLINE, output_count, VTY_NEWLINE);
}
#endif
int
Bgp::peer_adj_routes (struct vty *vty, char *ip_str, afi_t afi, safi_t safi, int in)
{
    int ret;
    struct peer *peer;
    union sockunion su;

    ret = str2sockunion (ip_str, &su);
    if (ret < 0)
    {
        vty_out (zlog_default,LOG_DEBUG, "Malformed address: %s%s", ip_str, VTY_NEWLINE);
        return CMD_WARNING;
    }
    peer = peer_lookup_by_su (&su);
    if (! peer || ! peer->afc[afi][safi])
    {
        vty_out (zlog_default,LOG_DEBUG, "%% No such neighbor or address family%s", VTY_NEWLINE);
        return CMD_WARNING;
    }

    if (in && ! CHECK_FLAG (peer->af_flags[afi][safi], PEER_FLAG_SOFT_RECONFIG))
    {
        vty_out (zlog_default,LOG_DEBUG, "%% Inbound soft reconfiguration not enabled%s",
                 VTY_NEWLINE);
        return CMD_WARNING;
    }
    show_adj_route (vty, peer, afi, safi, in);

    return CMD_SUCCESS;
}

DEFUN (show_ip_bgp_neighbor_advertised_route,
       show_ip_bgp_neighbor_advertised_route_cmd,
       "show ip bgp neighbors (A.B.C.D|X:X::X:X) advertised-routes",
       SHOW_STR
       IP_STR
       BGP_STR
       "Detailed information on TCP and BGP neighbor connections\n"
       "Neighbor to display information about\n"
       "Neighbor to display information about\n"
       "Display the routes advertised to a BGP neighbor\n")
{
    return peer_adj_routes (vty, argv[0], AFI_IP, SAFI_UNICAST, 0);
}

DEFUN (show_ip_bgp_neighbor_received_routes,
       show_ip_bgp_neighbor_received_routes_cmd,
       "show ip bgp neighbors (A.B.C.D|X:X::X:X) received-routes",
       SHOW_STR
       IP_STR
       BGP_STR
       "Detailed information on TCP and BGP neighbor connections\n"
       "Neighbor to display information about\n"
       "Neighbor to display information about\n"
       "Display the received routes from neighbor\n")
{
    return peer_adj_routes (vty, argv[0], AFI_IP, SAFI_UNICAST, 1);
}

void
Bgp::bgp_show_neighbor_route_clean (struct vty *vty)
{
    union sockunion *su;

    su = ( union sockunion * )  vty->output_arg;
    XFREE (MTYPE_SOCKUNION, su);
}

int
Bgp::bgp_show_neighbor_route (struct vty *vty, char *ip_str, u_int16_t afi,
                              u_char safi)
{
    union sockunion *su;
    struct peer *peer;

    su = sockunion_str2su (ip_str);
    if (su == NULL)
    {
        vty_out (zlog_default,LOG_DEBUG, "Malformed address: %s%s", ip_str, VTY_NEWLINE);
        return CMD_WARNING;
    }

    peer = peer_lookup_by_su (su);
    if (! peer || ! peer->afc[afi][safi])
    {
        vty_out (zlog_default,LOG_DEBUG, "%% No such neighbor or address family%s", VTY_NEWLINE);
        XFREE (MTYPE_SOCKUNION, su);
        return CMD_WARNING;
    }

    vty->output_arg = su;
    vty->output_clean = &Bgp::bgp_show_neighbor_route_clean;

    return bgp_show (vty, NULL, afi, safi, bgp_show_type_neighbor);
}

DEFUN (show_ip_bgp_neighbor_routes,
       show_ip_bgp_neighbor_routes_cmd,
       "show ip bgp neighbors (A.B.C.D|X:X::X:X) routes",
       SHOW_STR
       IP_STR
       BGP_STR
       "Detailed information on TCP and BGP neighbor connections\n"
       "Neighbor to display information about\n"
       "Neighbor to display information about\n"
       "Display routes learned from neighbor\n")
{
    return bgp_show_neighbor_route (vty, argv[0], AFI_IP, SAFI_UNICAST);
}

struct bgp_distance *
Bgp::bgp_distance_new ()
{
    struct bgp_distance *New;
    New = ( struct bgp_distance * ) XMALLOC (MTYPE_BGP_DISTANCE, sizeof (struct bgp_distance));
    memset (New, 0, sizeof (struct bgp_distance));
    return New;
}

void
Bgp::bgp_distance_free (struct bgp_distance *bdistance)
{
    XFREE (MTYPE_BGP_DISTANCE, bdistance);
}

int
Bgp::bgp_distance_set (struct vty *vty, char *distance_str, char *ip_str,
                       char *access_list_str)
{
    int ret;
    struct prefix_ipv4 p;
    u_char distance;
    struct bgp_node *rn;
    struct bgp_distance *bdistance;

    ret = str2prefix_ipv4 (ip_str, &p);
    if (ret == 0)
    {
        vty_out (zlog_default,LOG_DEBUG, "Malformed prefix%s", VTY_NEWLINE);
        return CMD_WARNING;
    }

    distance = atoi (distance_str);

    /* Get BGP distance node. */
    rn = route_node_get (bgp_distance_table, (struct prefix *) &p);
    if (rn->info)
    {
        bdistance = ( struct bgp_distance * ) rn->info;
        route_unlock_node (rn);
    } else
    {
        bdistance = bgp_distance_new ();
        rn->info = bdistance;
    }

    /* Set distance value. */
    bdistance->distance = distance;

    /* Reset access-list configuration. */
    if (bdistance->access_list)
    {
        free (bdistance->access_list);
        bdistance->access_list = NULL;
    }
    if (access_list_str)
        bdistance->access_list = strdup (access_list_str);

    return CMD_SUCCESS;
}

int
Bgp::bgp_distance_unset (struct vty *vty, char *distance_str, char *ip_str,
                         char *access_list_str)
{
    int ret;
    struct prefix_ipv4 p;
    u_char distance;
    struct bgp_node *rn;
    struct bgp_distance *bdistance;

    ret = str2prefix_ipv4 (ip_str, &p);
    if (ret == 0)
    {
        vty_out (zlog_default,LOG_DEBUG, "Malformed prefix%s", VTY_NEWLINE);
        return CMD_WARNING;
    }

    distance = atoi (distance_str);

    rn = route_node_lookup (bgp_distance_table, (struct prefix *)&p);
    if (! rn)
    {
        vty_out (zlog_default,LOG_DEBUG, "Cant find specified prefix%s", VTY_NEWLINE);
        return CMD_WARNING;
    }

    bdistance = ( struct bgp_distance * ) rn->info;

    if (bdistance->access_list)
        free (bdistance->access_list);
    bgp_distance_free (bdistance);

    rn->info = NULL;
    route_unlock_node (rn);
    route_unlock_node (rn);

    return CMD_SUCCESS;
}

void
Bgp::bgp_distance_reset ()
{
    struct bgp_node *rn;
    struct bgp_distance *bdistance;

    for (rn = route_top (bgp_distance_table); rn; rn = route_next (rn))
        if ((bdistance = ( struct bgp_distance * ) rn->info) != NULL)
        {
            if (bdistance->access_list)
                free (bdistance->access_list);
            bgp_distance_free (bdistance);
            rn->info = NULL;
            route_unlock_node (rn);
        }
}

/* Apply BGP information to distance method. */
u_char
Bgp::bgp_distance_apply (struct prefix *p, struct bgp_info *rinfo, struct bgp *bgp)
{
    struct bgp_node *rn;
    struct prefix_ipv4 q;
    struct peer *peer;
    struct bgp_distance *bdistance;
    struct access_list *alist;
    struct bgp_static *bgp_static;

    if (! bgp)
        return 0;

    if (p->family != AF_INET)
        return 0;

    peer = rinfo->peer;

    if (peer->su.sa.sa_family != AF_INET)
        return 0;

    memset (&q, 0, sizeof (struct prefix_ipv4));
    q.family = AF_INET;
    q.prefix = peer->su.sin.sin_addr;
    q.prefixlen = IPV4_MAX_BITLEN;

    /* Check source address. */
    rn = route_node_match (bgp_distance_table, (struct prefix *) &q);
    if (rn)
    {
        bdistance = ( struct bgp_distance * ) rn->info;
        route_unlock_node (rn);

        if (bdistance->access_list)
        {
            alist = access_list_lookup (AFI_IP, bdistance->access_list);
            if (alist == NULL)
                return 0;
            if (access_list_apply (alist, p) == FILTER_DENY)
                return 0;

            return bdistance->distance;
        } else
            return bdistance->distance;
    }

    if (peer_sort (peer) == BGP_PEER_EBGP)
    {
        rn = route_node_lookup (bgp->route[AFI_IP][SAFI_UNICAST], p);
        if (rn)
        {
            bgp_static = ( struct bgp_static * )  rn->info;
            route_unlock_node (rn);
        }

        if (bgp->distance_ebgp)
            return bgp->distance_ebgp;
    } else
    {
        if (bgp->distance_ibgp)
            return bgp->distance_ibgp;
    }

    return 0;
}

DEFUN (bgp_distance,
       bgp_distance_cmd,
       "distance bgp <1-255> <1-255> <1-255>",
       "Define an administrative distance\n"
       "BGP distance\n"
       "Distance for routes external to the AS\n"
       "Distance for routes internal to the AS\n"
       "Distance for local routes\n")
{
    struct bgp *bgp;

    bgp = ( struct bgp* ) bgp_get_default();

    bgp->distance_ebgp = atoi (argv[0]);
    bgp->distance_ibgp = atoi (argv[1]);
    bgp->distance_local = atoi (argv[2]);
    return CMD_SUCCESS;
}

DEFUN (no_bgp_distance,
       no_bgp_distance_cmd,
       "no distance bgp <1-255> <1-255> <1-255>",
       NO_STR
       "Define an administrative distance\n"
       "BGP distance\n"
       "Distance for routes external to the AS\n"
       "Distance for routes internal to the AS\n"
       "Distance for local routes\n")
{
    struct bgp *bgp;

    bgp = ( struct bgp * ) bgp_get_default();

    bgp->distance_ebgp= 0;
    bgp->distance_ibgp = 0;
    bgp->distance_local = 0;
    return CMD_SUCCESS;
}


DEFUN (bgp_distance_source,
       bgp_distance_source_cmd,
       "distance <1-255> A.B.C.D/M",
       "Define an administrative distance\n"
       "Administrative distance\n"
       "IP source prefix\n")
{
    bgp_distance_set (vty, argv[0], argv[1], NULL);
    return CMD_SUCCESS;
}

DEFUN (no_bgp_distance_source,
       no_bgp_distance_source_cmd,
       "no distance <1-255> A.B.C.D/M",
       NO_STR
       "Define an administrative distance\n"
       "Administrative distance\n"
       "IP source prefix\n")
{
    bgp_distance_unset (vty, argv[0], argv[1], NULL);
    return CMD_SUCCESS;
}

DEFUN (bgp_distance_source_access_list,
       bgp_distance_source_access_list_cmd,
       "distance <1-255> A.B.C.D/M WORD",
       "Define an administrative distance\n"
       "Administrative distance\n"
       "IP source prefix\n"
       "Access list name\n")
{
    bgp_distance_set (vty, argv[0], argv[1], argv[2]);
    return CMD_SUCCESS;
}

DEFUN (no_bgp_distance_source_access_list,
       no_bgp_distance_source_access_list_cmd,
       "no distance <1-255> A.B.C.D/M WORD",
       NO_STR
       "Define an administrative distance\n"
       "Administrative distance\n"
       "IP source prefix\n"
       "Access list name\n")
{
    bgp_distance_unset (vty, argv[0], argv[1], argv[2]);
    return CMD_SUCCESS;
}

#ifndef HAVE_ZEBRA_93b
DEFUN (bgp_damp_set,
       bgp_damp_set_cmd,
       "bgp dampening <1-45> <1-20000> <1-20000> <1-255>",
       "BGP Specific commands\n"
       "Enable route-flap dampening\n"
       "Half-life time for the penalty\n"
       "Value to start reusing a route\n"
       "Value to start suppressing a route\n"
       "Maximum duration to suppress a stable route\n")
{
    struct bgp *bgp;

    bgp = ( struct bgp * ) bgp_get_default();
    if (bgp_damp_enable (vty, argc, argv) == CMD_SUCCESS)
    {
        SET_FLAG (bgp->config, BGP_CONFIG_DAMPENING);
        return CMD_SUCCESS;
    }

    return CMD_WARNING;
}

DEFUN (bgp_damp_unset,
       bgp_damp_unset_cmd,
       "no bgp dampening",
       NO_STR
       "BGP Specific commands\n"
       "Enable route-flap dampening\n")
{
    struct bgp *bgp;

    bgp = ( struct bgp * ) bgp_get_default();
    if (bgp_damp_disable (vty) == CMD_SUCCESS)
    {
        UNSET_FLAG (bgp->config, BGP_CONFIG_DAMPENING);
        return CMD_SUCCESS;
    }

    return CMD_WARNING;
}

#else 
DEFUN (bgp_damp_set,
       bgp_damp_set_cmd,
       "bgp dampening <1-45> <1-20000> <1-20000> <1-255>",
       "BGP Specific commands\n"
       "Enable route-flap dampening\n"
       "Half-life time for the penalty\n"
       "Value to start reusing a route\n"
       "Value to start suppressing a route\n"
       "Maximum duration to suppress a stable route\n")
{
  struct bgp *bgp;
  int half = DEFAULT_HALF_LIFE * 60;
  int reuse = DEFAULT_REUSE;
  int suppress = DEFAULT_SUPPRESS;
  int max = 4 * half;

  if (argc == 4)
    {
      half = atoi (argv[0]) * 60;
      reuse = atoi (argv[1]);
      suppress = atoi (argv[2]);
      max = atoi (argv[3]) * 60;
    }
  else if (argc == 1)
    {
      half = atoi (argv[0]) * 60;
      max = 4 * half;
    }

  bgp = ( struct bgp * ) bgp_get_default();
  return bgp_damp_enable (bgp, bgp_node_afi (vty), bgp_node_safi (vty),
			  half, reuse, suppress, max);
}

DEFUN (bgp_damp_unset,
       bgp_damp_unset_cmd,
       "no bgp dampening",
       NO_STR
       "BGP Specific commands\n"
       "Enable route-flap dampening\n")
{
  struct bgp *bgp;

  bgp = ( struct bgp * ) bgp_get_default();
  return bgp_damp_disable (bgp, bgp_node_afi (vty), bgp_node_safi (vty));
}

DEFUN (clear_ip_bgp_dampening,
       clear_ip_bgp_dampening_cmd,
       "clear ip bgp dampening",
       CLEAR_STR
       IP_STR
       BGP_STR
       "Clear route flap dampening information\n")
{
  bgp_damp_info_clean ();
  return CMD_SUCCESS;
}

DEFUN (clear_ip_bgp_dampening_prefix,
       clear_ip_bgp_dampening_prefix_cmd,
       "clear ip bgp dampening A.B.C.D/M",
       CLEAR_STR
       IP_STR
       BGP_STR
       "Clear route flap dampening information\n"
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n")
{
  return bgp_clear_damp_route (vty, NULL, argv[0], AFI_IP,
			       SAFI_UNICAST, NULL, 1);
}

DEFUN (clear_ip_bgp_dampening_address,
       clear_ip_bgp_dampening_address_cmd,
       "clear ip bgp dampening A.B.C.D",
       CLEAR_STR
       IP_STR
       BGP_STR
       "Clear route flap dampening information\n"
       "Network to clear damping information\n")
{
  return bgp_clear_damp_route (vty, NULL, argv[0], AFI_IP,
			       SAFI_UNICAST, NULL, 0);
}

DEFUN (clear_ip_bgp_dampening_address_mask,
       clear_ip_bgp_dampening_address_mask_cmd,
       "clear ip bgp dampening A.B.C.D A.B.C.D",
       CLEAR_STR
       IP_STR
       BGP_STR
       "Clear route flap dampening information\n"
       "Network to clear damping information\n"
       "Network mask\n")
{
  int ret;
  char prefix_str[BUFSIZ];

  ret = netmask_str2prefix_str (argv[0], argv[1], prefix_str);
  if (! ret)
    {
      vty_out (zlog_default,LOG_DEBUG, "%% Inconsistent address and mask%s", VTY_NEWLINE);
      return CMD_WARNING;
    }
  
  return bgp_clear_damp_route (vty, NULL, prefix_str, AFI_IP,
			       SAFI_UNICAST, NULL, 0);
}

/* Display specified route of BGP table. */
int
Bgp::bgp_clear_damp_route (struct vty *vty, char *view_name, char *ip_str,
			   afi_t afi, safi_t safi, struct prefix_rd *prd,
			   int prefix_check)
{
  int ret;
  struct prefix match;
  struct bgp_node *rn;
  struct bgp_node *rm;
  struct bgp_info *ri;
  struct bgp_info *ri_temp;
  struct bgp *bgp;
  struct bgp_table *table;

  /* BGP structure lookup. */
  bgp = bgp_get_default ();
  if (bgp == NULL)
    {
      vty_out (zlog_default,LOG_DEBUG, "%% No BGP process is configured%s", VTY_NEWLINE);
      return CMD_WARNING;
    }

  /* Check IP address argument. */
  ret = str2prefix (ip_str, &match);
  if (! ret)
    {
      vty_out (zlog_default,LOG_DEBUG, "%% address is malformed%s", VTY_NEWLINE);
      return CMD_WARNING;
    }
  
  match.family = afi2family (afi);
  
  if ((rn = route_node_match (bgp->rib[afi][safi], &match)) != NULL)
    if (! prefix_check || rn->p.prefixlen == match.prefixlen)
      {
	ri = (struct bgp_info*) rn->info;
	while (ri)
	  {
	    if (ri->damp_info)
	      {
		    ri_temp = ri->next;
		    bgp_damp_info_free (ri->damp_info, 1);
		    ri = ri_temp;
	      }
	    else
	      ri = ri->next;
	  }
      }
 
  return CMD_SUCCESS;
}

#endif  /*HAVE_ZEBRA_93b*/

/* Configuration of static route announcement and aggregate
   information. */
int
Bgp::bgp_config_write_network (struct vty *vty, struct bgp *bgp,
                               afi_t afi, safi_t safi, int *write)
{
    struct bgp_node *rn;
    struct prefix *p;
    struct bgp_static *bgp_static;
    struct bgp_aggregate *bgp_aggregate;
    char buf[SU_ADDRSTRLEN];


    /* Network configuration. */
    for (rn = route_top (bgp->route[afi][safi]); rn; rn = route_next (rn))
        if ((bgp_static = ( struct bgp_static * ) rn->info) != NULL)
        {
            p = &rn->p;

            /* "address-family" display.  */
            bgp_config_write_family_header (vty, afi, safi, write);

            /* "network" configuration display.  */
            vty_out (zlog_default,LOG_DEBUG, " network %s/%d",
                     Bgp::inet_ntop (p->family, &p->u.prefix, buf, SU_ADDRSTRLEN), 
                     p->prefixlen);

            vty_out (zlog_default,LOG_DEBUG, "%s", VTY_NEWLINE);
        }

        /* Aggregate-address configuration. */
    for (rn = route_top (bgp->aggregate[afi][safi]); rn; rn = route_next (rn))
        if ((bgp_aggregate = ( struct bgp_aggregate * ) rn->info) != NULL)
        {
            p = &rn->p;

            /* "address-family" display.  */
            bgp_config_write_family_header (vty, afi, safi, write);

            vty_out (zlog_default,LOG_DEBUG, " aggregate-address %s/%d",
                     Bgp::inet_ntop (p->family, &p->u.prefix, buf, SU_ADDRSTRLEN),
                     p->prefixlen);

            if (bgp_aggregate->as_set)
                vty_out (zlog_default,LOG_DEBUG, " as-set");

            if (bgp_aggregate->summary_only)
                vty_out (zlog_default,LOG_DEBUG, " summary-only");

            vty_out (zlog_default,LOG_DEBUG, "%s", VTY_NEWLINE);
        }

    return 0;
}

int
Bgp::bgp_config_write_distance (struct vty *vty, struct bgp *bgp)
{
    struct bgp_node *rn;
    struct bgp_distance *bdistance;

    /* Distance configuration. */
    if (bgp->distance_ebgp
        && bgp->distance_ibgp
        && bgp->distance_local
        && (bgp->distance_ebgp != ZEBRA_EBGP_DISTANCE_DEFAULT
            || bgp->distance_ibgp != ZEBRA_IBGP_DISTANCE_DEFAULT
            || bgp->distance_local != ZEBRA_IBGP_DISTANCE_DEFAULT))
        vty_out (zlog_default,LOG_DEBUG, " distance bgp %d %d %d%s",
                 bgp->distance_ebgp, bgp->distance_ibgp, bgp->distance_local,
                 VTY_NEWLINE);

    for (rn = route_top (bgp_distance_table); rn; rn = route_next (rn))
        if ((bdistance = ( struct bgp_distance * ) rn->info) != NULL)
        {
            vty_out (zlog_default,LOG_DEBUG, " distance %d %s/%d %s%s", bdistance->distance,
                     inet_ntoa (rn->p.u.prefix4), rn->p.prefixlen,
                     bdistance->access_list ? bdistance->access_list : "",
                     VTY_NEWLINE);
        }

    return 0;
}

/* Allocate routing table structure and install commands. */
void
Bgp::bgp_route_init ()
{
    /* Make static announcement peer. */
    peer_self = peer_new ();
    peer_self->host = "Static announcement";

    /* Init BGP distance table. */
    /*bgp_distance_table = route_table_init ();*/

    /* IPv4 BGP commands. */
    if(cmdvec_init) install_element (CONFIG_NODE, &bgp_network_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &bgp_network_mask_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &bgp_network_mask_natural_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &no_bgp_network_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &no_bgp_network_mask_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &no_bgp_network_mask_natural_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &aggregate_address_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &aggregate_address_mask_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &aggregate_address_summary_only_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &aggregate_address_mask_summary_only_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &aggregate_address_as_set_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &aggregate_address_mask_as_set_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &aggregate_address_as_set_summary_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &aggregate_address_mask_as_set_summary_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &aggregate_address_summary_as_set_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &aggregate_address_mask_summary_as_set_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &no_aggregate_address_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &no_aggregate_address_summary_only_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &no_aggregate_address_as_set_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &no_aggregate_address_as_set_summary_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &no_aggregate_address_summary_as_set_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &no_aggregate_address_mask_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &no_aggregate_address_mask_summary_only_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &no_aggregate_address_mask_as_set_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &no_aggregate_address_mask_as_set_summary_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &no_aggregate_address_mask_summary_as_set_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &show_ip_bgp_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &show_ip_bgp_route_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &show_ip_bgp_prefix_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &show_ip_bgp_regexp_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &show_ip_bgp_prefix_list_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &show_ip_bgp_filter_list_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &show_ip_bgp_cidr_only_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &show_ip_bgp_community_all_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &show_ip_bgp_community_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &show_ip_bgp_community2_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &show_ip_bgp_community3_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &show_ip_bgp_community4_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &show_ip_bgp_community_exact_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &show_ip_bgp_community2_exact_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &show_ip_bgp_community3_exact_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &show_ip_bgp_community4_exact_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &show_ip_bgp_community_list_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &show_ip_bgp_community_list_exact_cmd);

    if(cmdvec_init) install_element (CONFIG_NODE, &show_ip_bgp_prefix_longer_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &show_ip_bgp_neighbor_advertised_route_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &show_ip_bgp_neighbor_received_routes_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &show_ip_bgp_neighbor_routes_cmd);

    /*distance related commands are not supported for now */ 
    if(0) install_element (CONFIG_NODE, &bgp_distance_cmd);
    if(0) install_element (CONFIG_NODE, &no_bgp_distance_cmd);
    if(0) install_element (CONFIG_NODE, &no_bgp_distance2_cmd);
    if(0) install_element (CONFIG_NODE, &bgp_distance_source_cmd);
    if(0) install_element (CONFIG_NODE, &no_bgp_distance_source_cmd);
    if(0) install_element (CONFIG_NODE, &bgp_distance_source_access_list_cmd);
    if(0) install_element (CONFIG_NODE, &no_bgp_distance_source_access_list_cmd);

    if(cmdvec_init) install_element (CONFIG_NODE, &bgp_damp_set_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &bgp_damp_set2_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &bgp_damp_set3_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &bgp_damp_unset_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &bgp_damp_unset2_cmd);

#ifdef HAVE_ZEBRA_93b
    if(cmdvec_init) install_element (CONFIG_NODE, &clear_ip_bgp_dampening_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &clear_ip_bgp_dampening_prefix_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &clear_ip_bgp_dampening_address_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &clear_ip_bgp_dampening_address_mask_cmd);    
#endif
}



////////////////////////////////////////////////
////////////////////////////////////////////////
//////bgp_routemap.c////////////////////////////
////////////////////////////////////////////////

/* Match function should return 1 if match is success else return
   zero. */
route_map_result_t
Bgp::route_match_ip_address (void *rule, struct prefix *prefix, 
                             route_map_object_t type, void *object)
{
    struct access_list *alist;
    /* struct prefix_ipv4 match; */

    if (type == RMAP_BGP)
    {
        alist = access_list_lookup (AFI_IP, (char *) rule);
        if (alist == NULL)
            return RMAP_NOMATCH;

        return(access_list_apply (alist, prefix) == FILTER_DENY ?
               RMAP_NOMATCH : RMAP_MATCH);
    }
    return RMAP_NOMATCH;
}

/* Route map `ip address' match statement.  `arg' should be
   access-list name. */
void *
Bgp::route_match_ip_address_compile (char *arg)
{
    return XSTRDUP (MTYPE_ROUTE_MAP_COMPILED, arg);
}

/* Free route map's compiled `ip address' value. */
void
Bgp::route_match_ip_address_free (void *rule)
{
    XFREE (MTYPE_ROUTE_MAP_COMPILED, rule);
}

/* `match ip next-hop IP_ADDRESS' */

/* Match function return 1 if match is success else return zero. */
route_map_result_t
Bgp::route_match_ip_next_hop (void *rule, struct prefix *prefix, 
                              route_map_object_t type, void *object)
{
    struct access_list *alist;
    struct bgp_info *bgp_info;
    struct prefix_ipv4 p;

    if (type == RMAP_BGP)
    {
        bgp_info = ( struct bgp_info * ) object;
        p.family = AF_INET;
        p.prefix = bgp_info->attr->nexthop;
        p.prefixlen = IPV4_MAX_BITLEN;

        alist = access_list_lookup (AFI_IP, (char *) rule);
        if (alist == NULL)
            return RMAP_NOMATCH;

        return(access_list_apply (alist, &p) == FILTER_DENY ?
               RMAP_NOMATCH : RMAP_MATCH);
    }
    return RMAP_NOMATCH;
}

/* Route map `ip next-hop' match statement. `arg' is
   access-list name. */
void *
Bgp::route_match_ip_next_hop_compile (char *arg)
{
    return XSTRDUP (MTYPE_ROUTE_MAP_COMPILED, arg);
}

/* Free route map's compiled `ip address' value. */
void
Bgp::route_match_ip_next_hop_free (void *rule)
{
    XFREE (MTYPE_ROUTE_MAP_COMPILED, rule);
}


/* `match ip address prefix-list PREFIX_LIST' */

route_map_result_t
Bgp::route_match_ip_address_prefix_list (void *rule, struct prefix *prefix, 
                                         route_map_object_t type, void *object)
{
    struct prefix_list *plist;

    if (type == RMAP_BGP)
    {
        plist = prefix_list_lookup (AFI_IP, (char *) rule);
        if (plist == NULL)
            return RMAP_NOMATCH;

        return(prefix_list_apply (plist, prefix) == PREFIX_DENY ?
               RMAP_NOMATCH : RMAP_MATCH);
    }
    return RMAP_NOMATCH;
}

void *
Bgp::route_match_ip_address_prefix_list_compile (char *arg)
{
    return XSTRDUP (MTYPE_ROUTE_MAP_COMPILED, arg);
}

void
Bgp::route_match_ip_address_prefix_list_free (void *rule)
{
    XFREE (MTYPE_ROUTE_MAP_COMPILED, rule);
}

/* `match ip next-hop prefix-list PREFIX_LIST' */

route_map_result_t
Bgp::route_match_ip_next_hop_prefix_list (void *rule, struct prefix *prefix,
                                          route_map_object_t type, void *object)
{
    struct prefix_list *plist;
    struct bgp_info *bgp_info;
    struct prefix_ipv4 p;

    if (type == RMAP_BGP)
    {
        bgp_info = ( struct bgp_info * ) object;
        p.family = AF_INET;
        p.prefix = bgp_info->attr->nexthop;
        p.prefixlen = IPV4_MAX_BITLEN;

        plist = prefix_list_lookup (AFI_IP, (char *) rule);
        if (plist == NULL)
            return RMAP_NOMATCH;

        return(prefix_list_apply (plist, &p) == PREFIX_DENY ?
               RMAP_NOMATCH : RMAP_MATCH);
    }
    return RMAP_NOMATCH;
}

void *
Bgp::route_match_ip_next_hop_prefix_list_compile (char *arg)
{
    return XSTRDUP (MTYPE_ROUTE_MAP_COMPILED, arg);
}

void
Bgp::route_match_ip_next_hop_prefix_list_free (void *rule)
{
    XFREE (MTYPE_ROUTE_MAP_COMPILED, rule);
}


/* `match metric METRIC' */

/* Match function return 1 if match is success else return zero. */
route_map_result_t
Bgp::route_match_metric (void *rule, struct prefix *prefix, 
                         route_map_object_t type, void *object)
{
    u_int32_t *med;
    struct bgp_info *bgp_info;

    if (type == RMAP_BGP)
    {
        med = ( u_int32_t * ) rule;
        bgp_info = ( struct bgp_info * ) object;

        if (bgp_info->attr->med == *med)
            return RMAP_MATCH;
        else
            return RMAP_NOMATCH;
    }
    return RMAP_NOMATCH;
}

/* Route map `match metric' match statement. `arg' is MED value */
void *
Bgp::route_match_metric_compile (char *arg)
{
    u_int32_t *med;
    char *endptr = NULL;

    med = ( u_int32_t * ) XMALLOC (MTYPE_ROUTE_MAP_COMPILED, sizeof (u_int32_t));
    *med = strtoul (arg, &endptr, 10);
    if (*endptr != '\0' || *med == ULONG_MAX)
    {
        XFREE (MTYPE_ROUTE_MAP_COMPILED, med);
        return NULL;
    }
    return med;
}

/* Free route map's compiled `match metric' value. */
void
Bgp::route_match_metric_free (void *rule)
{
    XFREE (MTYPE_ROUTE_MAP_COMPILED, rule);
}


/* `match as-path ASPATH' */

/* Match function for as-path match.  I assume given object is */
route_map_result_t
Bgp::route_match_aspath (void *rule, struct prefix *prefix, 
                         route_map_object_t type, void *object)
{

    struct as_list *as_list;
    struct bgp_info *bgp_info;

    if (type == RMAP_BGP)
    {
        as_list = as_list_lookup ((char *) rule);
        if (as_list == NULL)
            return RMAP_NOMATCH;

        bgp_info = ( struct bgp_info * ) object;

        /* Perform match. */
        return((as_list_apply (as_list, bgp_info->attr->aspath) == AS_FILTER_DENY) ? RMAP_NOMATCH : RMAP_MATCH);
    }
    return RMAP_NOMATCH;
}

/* Compile function for as-path match. */
void *
Bgp::route_match_aspath_compile (char *arg)
{
    return XSTRDUP (MTYPE_ROUTE_MAP_COMPILED, arg);
}

/* Compile function for as-path match. */
void
Bgp::route_match_aspath_free (void *rule)
{
    XFREE (MTYPE_ROUTE_MAP_COMPILED, rule);
}

/* `match community COMMUNIY' */

/* Match function for community match. */
route_map_result_t
Bgp::route_match_community (void *rule, struct prefix *prefix, 
                            route_map_object_t type, void *object)
{
    struct community_list *list;
    struct bgp_info *bgp_info;

    if (type == RMAP_BGP)
    {
        list = community_list_lookup ((char *) rule);
        bgp_info = ( struct bgp_info * )  object;

        if (list == NULL)
            return RMAP_NOMATCH;

        /* Perform match. */
        return(community_list_match (bgp_info->attr->community, list) 
               ? RMAP_MATCH : RMAP_NOMATCH);
    }
    return RMAP_NOMATCH;
}

/* Compile function for community match. */
void *
Bgp::route_match_community_compile (char *arg)
{
    return XSTRDUP (MTYPE_ROUTE_MAP_COMPILED, arg);
}

/* Compile function for community match. */
void
Bgp::route_match_community_free (void *rule)
{
    XFREE (MTYPE_ROUTE_MAP_COMPILED, rule);
}




/* `set ip next-hop IP_ADDRESS' */

/* Set nexthop to object.  ojbect must be pointer to struct attr. */
route_map_result_t
Bgp::route_set_ip_nexthop (void *rule, struct prefix *prefix, route_map_object_t type, void *object)
{
    struct in_addr *address;
    struct bgp_info *bgp_info;

    if (type == RMAP_BGP)
    {
        /* Fetch routemap's rule information. */
        address = ( struct in_addr * ) rule;
        bgp_info = ( struct bgp_info * ) object; 

        /* Set next hop value. */
        bgp_info->attr->nexthop = *address;
    }

    return RMAP_OKAY;
}

/* Route map `ip nexthop' compile function.  Given string is converted
   to struct in_addr structure. */
void *
Bgp::route_set_ip_nexthop_compile (char *arg)
{
    int ret;
    struct in_addr *address;

    address = ( struct in_addr * ) XMALLOC (MTYPE_ROUTE_MAP_COMPILED, sizeof (struct in_addr));

    ret = inet_aton (arg, address);

    if (ret == 0)
    {
        XFREE (MTYPE_ROUTE_MAP_COMPILED, address);
        return NULL;
    }

    return address;
}

/* Free route map's compiled `ip nexthop' value. */
void
Bgp::route_set_ip_nexthop_free (void *rule)
{
    XFREE (MTYPE_ROUTE_MAP_COMPILED, rule);
}


/* `set local-preference LOCAL_PREF' */

/* Set local preference. */
route_map_result_t
Bgp::route_set_local_pref (void *rule, struct prefix *prefix, route_map_object_t type, void *object)
{
    u_int32_t *local_pref;
    struct bgp_info *bgp_info;

    if (type == RMAP_BGP)
    {
        /* Fetch routemap's rule information. */
        local_pref = ( u_int32_t * ) rule;
        bgp_info = ( struct bgp_info * ) object; 

        /* Set local preference value. */
        bgp_info->attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_LOCAL_PREF);
        bgp_info->attr->local_pref = *local_pref;
    }

    return RMAP_OKAY;
}

/* set local preference compilation. */
void *
Bgp::route_set_local_pref_compile (char *arg)
{
    u_int32_t *local_pref;
    char *endptr = NULL;

    /* Local preference value shoud be integer. */
    if (! all_digit (arg))
        return NULL;

    local_pref = ( u_int32_t * ) XMALLOC (MTYPE_ROUTE_MAP_COMPILED, sizeof (u_int32_t));
    *local_pref = strtoul (arg, &endptr, 10);
    if (*endptr != '\0' || *local_pref == ULONG_MAX)
    {
        XFREE (MTYPE_ROUTE_MAP_COMPILED, local_pref);
        return NULL;
    }
    return local_pref;
}

/* Free route map's local preference value. */
void
Bgp::route_set_local_pref_free (void *rule)
{
    XFREE (MTYPE_ROUTE_MAP_COMPILED, rule);
}


/* `set weight WEIGHT' */

/* Set weight. */
route_map_result_t
Bgp::route_set_weight (void *rule, struct prefix *prefix, route_map_object_t type, void *object)
{
    u_int32_t *weight;
    struct bgp_info *bgp_info;

    if (type == RMAP_BGP)
    {
        /* Fetch routemap's rule information. */
        weight = ( u_int32_t * ) rule; 
        bgp_info =( struct bgp_info * )  object; 

        /* Set weight value. */
        bgp_info->attr->weight = *weight;
    }

    return RMAP_OKAY;
}

/* set local preference compilation. */
void *
Bgp::route_set_weight_compile (char *arg)
{
    u_int32_t *weight;
    char *endptr = NULL;

    /* Local preference value shoud be integer. */
    if (! all_digit (arg))
        return NULL;

    weight = ( u_int32_t * ) XMALLOC (MTYPE_ROUTE_MAP_COMPILED, sizeof (u_int32_t));
    *weight = strtoul (arg, &endptr, 10);
    if (*endptr != '\0' || *weight == ULONG_MAX)
    {
        XFREE (MTYPE_ROUTE_MAP_COMPILED, weight);
        return NULL;
    }
    return weight;
}

/* Free route map's local preference value. */
void
Bgp::route_set_weight_free (void *rule)
{
    XFREE (MTYPE_ROUTE_MAP_COMPILED, rule);
}

/* `set metric METRIC' */

/* Set metric to attribute. */
route_map_result_t
Bgp::route_set_metric (void *rule, struct prefix *prefix, 
                       route_map_object_t type, void *object)
{
    char *metric;
    u_int32_t metric_val;
    struct bgp_info *bgp_info;

    if (type == RMAP_BGP)
    {
        /* Fetch routemap's rule information. */
        metric = ( char * ) rule;
        bgp_info = ( struct bgp_info * ) object;

        if (! (bgp_info->attr->flag & ATTR_FLAG_BIT (BGP_ATTR_MULTI_EXIT_DISC)))
            bgp_info->attr->med = 0;
        bgp_info->attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_MULTI_EXIT_DISC);

        if (all_digit (metric))
        {
            metric_val = strtoul (metric, (char **)NULL, 10);
            bgp_info->attr->med = metric_val;
        } else
        {
            metric_val = strtoul (metric+1, (char **)NULL, 10);

            if (strncmp (metric, "+", 1) == 0)
            {
                if (bgp_info->attr->med/2 + metric_val/2 > ULONG_MAX/2)
                    bgp_info->attr->med = ULONG_MAX-1;
                else
                    bgp_info->attr->med += metric_val;
            } else if (strncmp (metric, "-", 1) == 0)
            {
                if (bgp_info->attr->med <= metric_val)
                    bgp_info->attr->med = 0;
                else
                    bgp_info->attr->med -= metric_val;
            }
        }
    }
    return RMAP_OKAY;
}

/* set metric compilation. */
void *
Bgp::route_set_metric_compile (char *arg)
{
    u_int32_t metric;
    char *endptr = NULL;

    if (all_digit (arg))
    {
        /* set metric value check*/
        metric = strtoul (arg, &endptr, 10);
        if (*endptr != '\0' || metric == ULONG_MAX)
            return NULL;
    } else
    {
        /* set metric +/-value check */
        if ((strncmp (arg, "+", 1) != 0
             && strncmp (arg, "-", 1) != 0)
            || (! all_digit (arg+1)))
            return NULL;

        metric = strtoul (arg+1, &endptr, 10);
        if (*endptr != '\0' || metric == ULONG_MAX)
            return NULL;
    }

    return XSTRDUP (MTYPE_ROUTE_MAP_COMPILED, arg);
}

/* Free route map's compiled `set metric' value. */
void
Bgp::route_set_metric_free (void *rule)
{
    XFREE (MTYPE_ROUTE_MAP_COMPILED, rule);
}


/* `set as-path prepend ASPATH' */

/* For AS path prepend mechanism. */
route_map_result_t
Bgp::route_set_aspath_prepend (void *rule, struct prefix *prefix, route_map_object_t type, void *object)
{
    struct aspath *aspath;
    struct aspath *New;
    struct bgp_info *bgp_info;

    if (type == RMAP_BGP)
    {
        aspath = ( struct aspath * ) rule;
        bgp_info = ( struct bgp_info * ) object;

        New = aspath_dup (bgp_info->attr->aspath);

        aspath_prepend (aspath, New);
        bgp_info->attr->aspath = New;
    }

    return RMAP_OKAY;
}

/* Compile function for as-path prepend. */
void *
Bgp::route_set_aspath_prepend_compile (char *arg)
{
    struct aspath *aspath;

    aspath = aspath_str2aspath (arg);
    if (! aspath)
        return NULL;
    return aspath;
}

/* Compile function for as-path prepend. */
void
Bgp::route_set_aspath_prepend_free (void *rule)
{
    struct aspath *aspath = ( struct aspath * ) rule;
    aspath_free (aspath);
}


/* `set community COMMUNITY' */

/* For community set mechanism. */
route_map_result_t
Bgp::route_set_community (void *rule, struct prefix *prefix, route_map_object_t type, void *object)
{
    struct community *com;
    struct bgp_info *bgp_info;

    if (type == RMAP_BGP)
    {
        bgp_info = ( struct bgp_info * ) object;

        if (strcmp (( char * ) rule, "none") == 0)
        {
            bgp_info->attr->flag &= ~(ATTR_FLAG_BIT (BGP_ATTR_COMMUNITIES));
            bgp_info->attr->community = NULL;
        } else
        {
            com = ( struct community * ) rule;

            if (!com)
                return RMAP_OKAY;

            bgp_info->attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_COMMUNITIES);
            bgp_info->attr->community = community_dup (com);
        }
    }

    return RMAP_OKAY;
}

/* Compile function for set community. */
void *
Bgp::route_set_community_compile (char *arg)
{
    struct community *com;

    if (strcmp (arg, "none") == 0)
        return( (void * ) "none") ;

    com = community_str2com (arg);
    if (! com)
        return NULL;
    return com;
}

/* Free function for set community. */
void
Bgp::route_set_community_free (void *rule)
{
    struct community *com;

    if (strcmp (( char * ) rule, "none") == 0)
        return;

    com = ( struct community * ) rule;
    community_free (com);
}

/* `set community-additive COMMUNITY' */

/* For community set mechanism. */
route_map_result_t
Bgp::route_set_community_additive (void *rule, struct prefix *prefix, route_map_object_t type, void *object)
{
    struct community *com;
    struct community *merge;
    struct community *old_com;
    struct community *new_com;
    struct bgp_info *bgp_info;

    if (type == RMAP_BGP)
    {
        com = ( struct community * ) rule;
        bgp_info = ( struct bgp_info * ) object;

        if (!com)
            return RMAP_OKAY;

        old_com = bgp_info->attr->community;

        if (old_com)
        {
            merge = community_merge (community_dup (old_com), com);
            new_com = community_uniq_sort (merge);
            community_free (merge);
        } else
            new_com = community_dup (com);

        bgp_info->attr->community = new_com;

        bgp_info->attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_COMMUNITIES);
    }

    return RMAP_OKAY;
}

/* Compile function for set community. */
void *
Bgp::route_set_community_additive_compile (char *arg)
{
    struct community *com;

    com = community_str2com (arg);
    if (! com)
        return NULL;
    return com;
}

/* Free function for set community. */
void
Bgp::route_set_community_additive_free (void *rule)
{
    struct community *com = ( struct community * ) rule;
    community_free (com);
}



/* `set community-delete COMMUNITY' */

/* For community set mechanism. */
route_map_result_t
Bgp::route_set_community_delete (void *rule, struct prefix *prefix, route_map_object_t type, void *object)
{
    struct community_list *list;
    struct community *merge;
    struct community *old_com;
    struct community *new_com;
    struct bgp_info *bgp_info;

    if (type == RMAP_BGP)
    {
        if (!rule)
            return RMAP_OKAY;

        bgp_info = ( struct bgp_info * ) object;
        list = community_list_lookup (( char * ) rule);

        old_com = bgp_info->attr->community;

        if (list && old_com)
        {
            merge = community_list_delete_entries (community_dup (old_com), list);
            new_com = community_uniq_sort (merge);
            community_free (merge);

            if (new_com->size == 0)
            {
                bgp_info->attr->community = NULL;
                bgp_info->attr->flag &= ~ATTR_FLAG_BIT (BGP_ATTR_COMMUNITIES);
                community_free (new_com);
            } else
            {
                bgp_info->attr->community = new_com;
                bgp_info->attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_COMMUNITIES);
            }
        }
    }

    return RMAP_OKAY;
}

/* Compile function for set community. */
void *
Bgp::route_set_community_delete_compile (char *arg)
{
    return XSTRDUP (MTYPE_ROUTE_MAP_COMPILED, arg);
}

/* Free function for set community. */
void
Bgp::route_set_community_delete_free (void *rule)
{
    XFREE (MTYPE_ROUTE_MAP_COMPILED, rule);
}


/* `set extcommunity rt COMMUNITY' */

/* For community set mechanism. */
route_map_result_t
Bgp::route_set_ecommunity_rt (void *rule, struct prefix *prefix, 
                              route_map_object_t type, void *object)
{
    struct ecommunity *ecom;
    struct ecommunity *new_ecom;
    struct ecommunity *old_ecom;
    struct bgp_info *bgp_info;

    if (type == RMAP_BGP)
    {
        ecom = ( struct ecommunity * ) rule;
        bgp_info = ( struct bgp_info * ) object;

        if (! ecom)
            return RMAP_OKAY;

        /* We assume additive for Extended Community. */
        old_ecom = bgp_info->attr->ecommunity;

        if (old_ecom)
            new_ecom = ecommunity_merge (ecommunity_dup (old_ecom), ecom);
        else
            new_ecom = ecommunity_dup (ecom);

        bgp_info->attr->ecommunity = new_ecom;

        bgp_info->attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_EXT_COMMUNITIES);
    }
    return RMAP_OKAY;
}

/* Compile function for set community. */
void *
Bgp::route_set_ecommunity_rt_compile (char *arg)
{
    struct ecommunity *ecom;

    ecom = ecommunity_str2com (ECOMMUNITY_ROUTE_TARGET, arg);
    if (! ecom)
        return NULL;
    return ecom;
}

/* Free function for set community. */
void
Bgp::route_set_ecommunity_rt_free (void *rule)
{
    struct ecommunity *ecom =( struct ecommunity * )  rule;
    ecommunity_free (ecom);
}

/* `set extcommunity soo COMMUNITY' */

/* For community set mechanism. */
route_map_result_t
Bgp::route_set_ecommunity_soo (void *rule, struct prefix *prefix, 
                               route_map_object_t type, void *object)
{
    struct ecommunity *ecom;
    struct bgp_info *bgp_info;

    if (type == RMAP_BGP)
    {
        ecom = ( struct ecommunity * ) rule;
        bgp_info = ( struct bgp_info * ) object;

        if (! ecom)
            return RMAP_OKAY;

        bgp_info->attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_EXT_COMMUNITIES);
        bgp_info->attr->ecommunity = ecommunity_dup (ecom);
    }
    return RMAP_OKAY;
}

/* Compile function for set community. */
void *
Bgp::route_set_ecommunity_soo_compile (char *arg)
{
    struct ecommunity *ecom;

    ecom = ecommunity_str2com (ECOMMUNITY_SITE_ORIGIN, arg);
    if (! ecom)
        return NULL;

    return ecom;
}

/* Free function for set community. */
void
Bgp::route_set_ecommunity_soo_free (void *rule)
{
    struct ecommunity *ecom = ( struct ecommunity * ) rule;
    ecommunity_free (ecom);
}


/* `set origin ORIGIN' */

/* For origin set. */
route_map_result_t
Bgp::route_set_origin (void *rule, struct prefix *prefix, route_map_object_t type, void *object)
{
    u_char *origin;
    struct bgp_info *bgp_info;

    if (type == RMAP_BGP)
    {
        origin = ( u_char * ) rule;
        bgp_info = ( struct bgp_info * ) object;

        bgp_info->attr->origin = *origin;
    }

    return RMAP_OKAY;
}

/* Compile function for origin set. */
void *
Bgp::route_set_origin_compile (char *arg)
{
    u_char *origin;

    if (strcmp (arg, "igp") == 0)
    {
        origin = (u_char * )  XMALLOC (MTYPE_ROUTE_MAP_COMPILED, sizeof (u_char));
        *origin = 0;
        return origin;
    } else if (strcmp (arg, "egp") == 0)
    {
        origin = ( u_char * ) XMALLOC (MTYPE_ROUTE_MAP_COMPILED, sizeof (u_char));
        *origin = 1;
        return origin;
    } else if (strcmp (arg, "incomplete") == 0)
    {
        origin = ( u_char * ) XMALLOC (MTYPE_ROUTE_MAP_COMPILED, sizeof (u_char));
        *origin = 2;
        return origin;
    }
    return NULL;
}

/* Compile function for origin set. */
void
Bgp::route_set_origin_free (void *rule)
{
    XFREE (MTYPE_ROUTE_MAP_COMPILED, rule);
}


/* `set atomic-aggregate' */

/* For atomic aggregate set. */
route_map_result_t
Bgp::route_set_atomic_aggregate (void *rule, struct prefix *prefix, route_map_object_t type, void *object)
{
    struct bgp_info *bgp_info;

    if (type == RMAP_BGP)
    {
        bgp_info = ( struct bgp_info * ) object;
        bgp_info->attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_ATOMIC_AGGREGATE);
    }

    return RMAP_OKAY;
}

/* Compile function for atomic aggregate. */
void *
Bgp::route_set_atomic_aggregate_compile (char *arg)
{
    return(void *)1;
}

/* Compile function for atomic aggregate. */
void
Bgp::route_set_atomic_aggregate_free (void *rule)
{
    return;
}


route_map_result_t
Bgp::route_set_aggregator_as (void *rule, struct prefix *prefix, 
                              route_map_object_t type, void *object)
{
    struct bgp_info *bgp_info;
    struct aggregator *aggregator;

    if (type == RMAP_BGP)
    {
        bgp_info = ( struct bgp_info * ) object;
        aggregator = ( struct aggregator * ) rule;

        bgp_info->attr->aggregator_as = aggregator->as;
        bgp_info->attr->aggregator_addr = aggregator->address;
        bgp_info->attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_AGGREGATOR);
    }

    return RMAP_OKAY;
}

void *
Bgp::route_set_aggregator_as_compile (char *arg)
{
    struct aggregator *aggregator;
    char as[10];
    char address[20];

    aggregator = ( struct aggregator * ) XMALLOC (MTYPE_ROUTE_MAP_COMPILED, sizeof (struct aggregator));
    memset (aggregator, 0, sizeof (struct aggregator));

    sscanf (arg, "%s %s", as, address);

    aggregator->as = strtoul (as, NULL, 10);
    inet_aton (address, &aggregator->address);

    return aggregator;
}

void
Bgp::route_set_aggregator_as_free (void *rule)
{
    XFREE (MTYPE_ROUTE_MAP_COMPILED, rule);
}


/* For origin set. */
route_map_result_t
Bgp::route_set_originator_id (void *rule, struct prefix *prefix, route_map_object_t type, void *object)
{
    struct in_addr *address;
    struct bgp_info *bgp_info;

    if (type == RMAP_BGP)
    {
        address = ( struct in_addr * ) rule;
        bgp_info = ( struct bgp_info * ) object;

        bgp_info->attr->flag |= ATTR_FLAG_BIT (BGP_ATTR_ORIGINATOR_ID);
        bgp_info->attr->originator_id = *address;
    }

    return RMAP_OKAY;
}

/* Compile function for originator-id set. */
void *
Bgp::route_set_originator_id_compile (char *arg)
{
    int ret;
    struct in_addr *address;

    address = ( struct in_addr * ) XMALLOC (MTYPE_ROUTE_MAP_COMPILED, sizeof (struct in_addr));

    ret = inet_aton (arg, address);

    if (ret == 0)
    {
        XFREE (MTYPE_ROUTE_MAP_COMPILED, address);
        return NULL;
    }

    return address;
}

/* Compile function for originator_id set. */
void
Bgp::route_set_originator_id_free (void *rule)
{
    XFREE (MTYPE_ROUTE_MAP_COMPILED, rule);
}



/* Add bgp route map rule. */
int
Bgp::bgp_route_match_add (struct vty *vty, struct route_map_index *index,
                          char *command, char *arg)
{
    int ret;

    ret = route_map_add_match (index, command, arg);
    if (ret)
    {
        switch (ret)
        {
        case RMAP_RULE_MISSING:
            vty_out (zlog_default,LOG_DEBUG, "%% Cant find rule.%s", VTY_NEWLINE);
            return CMD_WARNING;
            break;
        case RMAP_COMPILE_ERROR:
            vty_out (zlog_default,LOG_DEBUG, "%% Argument is malformed.%s", VTY_NEWLINE);
            return CMD_WARNING;
            break;
        }
    }
    return CMD_SUCCESS;
}

/* Delete bgp route map rule. */
int
Bgp::bgp_route_match_delete (struct vty *vty, struct route_map_index *index,
                             char *command, char *arg)
{
    int ret;

    ret = route_map_delete_match (index, command, arg);
    if (ret)
    {
        switch (ret)
        {
        case RMAP_RULE_MISSING:
            vty_out (zlog_default,LOG_DEBUG, "%% Cant find rule.%s", VTY_NEWLINE);
            return CMD_WARNING;
            break;
        case RMAP_COMPILE_ERROR:
            vty_out (zlog_default,LOG_DEBUG, "%% Argument is malformed.%s", VTY_NEWLINE);
            return CMD_WARNING;
            break;
        }
    }
    return CMD_SUCCESS;
}

/* Add bgp route map rule. */
int
Bgp::bgp_route_set_add (struct vty *vty, struct route_map_index *index,
                        char *command, char *arg)
{
    int ret;

    ret = route_map_add_set (index, command, arg);
    if (ret)
    {
        switch (ret)
        {
        case RMAP_RULE_MISSING:
            vty_out (zlog_default,LOG_DEBUG, "%% Cant find rule.%s", VTY_NEWLINE);
            return CMD_WARNING;
            break;
        case RMAP_COMPILE_ERROR:
            vty_out (zlog_default,LOG_DEBUG, "%% Argument is malformed.%s", VTY_NEWLINE);
            return CMD_WARNING;
            break;
        }
    }
    return CMD_SUCCESS;
}

/* Delete bgp route map rule. */
int
Bgp::bgp_route_set_delete (struct vty *vty, struct route_map_index *index,
                           char *command, char *arg)
{
    int ret;

    ret = route_map_delete_set (index, command, arg);
    if (ret)
    {
        switch (ret)
        {
        case RMAP_RULE_MISSING:
            vty_out (zlog_default,LOG_DEBUG, "%% Cant find rule.%s", VTY_NEWLINE);
            return CMD_WARNING;
            break;
        case RMAP_COMPILE_ERROR:
            vty_out (zlog_default,LOG_DEBUG, "%% Argument is malformed.%s", VTY_NEWLINE);
            return CMD_WARNING;
            break;
        }
    }
    return CMD_SUCCESS;
}

/* Hook function for updating route_map assignment. */
void
Bgp::bgp_route_map_update ( char * )
{
    int i;
    afi_t afi;
    safi_t safi;
    int direct;
    struct listnode *nn, *nm;
    struct bgp *bgp;
    struct peer_conf *conf;
    struct bgp_filter *filter;

    for (nn = bgp_list->head; nn; nn = nn->next)
        if ((bgp = ( struct bgp * )  nn->data) != NULL)
        {
            for (nm = bgp->peer_conf->head; nm; nm = nm->next)
                if ((conf = ( struct peer_conf * )  nm->data) != NULL)
                {
                    for (afi = AFI_IP; afi < AFI_MAX; afi++)
                        for (safi = SAFI_UNICAST; safi < SAFI_MAX; safi++)
                        {
                            filter = &conf->filter[afi][safi];

                            for (direct = FILTER_IN; direct < FILTER_MAX; direct++)
                            {
                                if (filter->map[direct].name)
                                    filter->map[direct].map = 
                                    route_map_lookup_by_name (filter->map[direct].name);
                                else
                                    filter->map[direct].map = NULL;
                            }
                        }
                }
        }

        /* For redistribute route-map updates. */
    for (nn = bgp_list->head; nn; nn = nn->next)
        if ((bgp = ( struct bgp * ) nn->data) != NULL)
        {
            for (i = 0; i < ZEBRA_ROUTE_MAX; i++)
            {
                if (bgp->rmap[ZEBRA_FAMILY_IPV4][i].name)
                    bgp->rmap[ZEBRA_FAMILY_IPV4][i].map = 
                    route_map_lookup_by_name (bgp->rmap[ZEBRA_FAMILY_IPV4][i].name);
            }
        }
}

DEFUN (match_ip_address, 
       match_ip_address_cmd,
       "match ip address WORD",
       MATCH_STR
       IP_STR
       "Match address of route\n"
       "IP access-list name\n")
{
    return bgp_route_match_add (vty,(struct route_map_index * )  vty->index, "ip address", argv[0]);
}

DEFUN (no_match_ip_address, 
       no_match_ip_address_cmd,
       "no match ip address",
       NO_STR
       MATCH_STR
       IP_STR
       "Match address of route\n")
{
    if (argc == 0)
        return bgp_route_match_delete (vty, ( struct route_map_index * ) vty->index, "ip address", NULL);

    return bgp_route_match_delete (vty, ( struct route_map_index * ) vty->index, "ip address", argv[0]);
}


DEFUN (match_ip_next_hop, 
       match_ip_next_hop_cmd,
       "match ip next-hop WORD",
       MATCH_STR
       IP_STR
       "Match next-hop address of route\n"
       "IP access-list name\n")
{
    return bgp_route_match_add (vty, ( struct route_map_index * ) vty->index, "ip next-hop", argv[0]);
}

DEFUN (no_match_ip_next_hop,
       no_match_ip_next_hop_cmd,
       "no match ip next-hop",
       NO_STR
       MATCH_STR
       IP_STR
       "Match next-hop address of route\n")
{
    if (argc == 0)
        return bgp_route_match_delete (vty, ( struct route_map_index * ) vty->index, "ip next-hop", NULL);

    return bgp_route_match_delete (vty, ( struct route_map_index * ) vty->index, "ip next-hop", argv[0]);
}

DEFUN (match_ip_address_prefix_list, 
       match_ip_address_prefix_list_cmd,
       "match ip address prefix-list WORD",
       MATCH_STR
       IP_STR
       "Match address of route\n"
       "Match entries of prefix-lists\n"
       "IP prefix-list name\n")
{
    return bgp_route_match_add (vty, ( struct route_map_index * ) vty->index, "ip address prefix-list", argv[0]);
}

DEFUN (no_match_ip_address_prefix_list,
       no_match_ip_address_prefix_list_cmd,
       "no match ip address prefix-list",
       NO_STR
       MATCH_STR
       IP_STR
       "Match address of route\n"
       "Match entries of prefix-lists\n")
{
    if (argc == 0)
        return bgp_route_match_delete (vty, ( struct route_map_index *) vty->index, "ip address prefix-list", NULL);

    return bgp_route_match_delete (vty, ( struct route_map_index * ) vty->index, "ip address prefix-list", argv[0]);
}

DEFUN (match_ip_next_hop_prefix_list, 
       match_ip_next_hop_prefix_list_cmd,
       "match ip next-hop prefix-list WORD",
       MATCH_STR
       IP_STR
       "Match next-hop address of route\n"
       "Match entries of prefix-lists\n"
       "IP prefix-list name\n")
{
    return bgp_route_match_add (vty, ( struct route_map_index * ) vty->index, "ip next-hop prefix-list", argv[0]);
}

DEFUN (no_match_ip_next_hop_prefix_list,
       no_match_ip_next_hop_prefix_list_cmd,
       "no match ip next-hop prefix-list",
       NO_STR
       MATCH_STR
       IP_STR
       "Match next-hop address of route\n"
       "Match entries of prefix-lists\n")
{
    if (argc == 0)
        return bgp_route_match_delete (vty, ( struct route_map_index * ) vty->index, "ip next-hop prefix-list", NULL);

    return bgp_route_match_delete (vty, ( struct route_map_index * ) vty->index, "ip next-hop prefix-list", argv[0]);
}

DEFUN (match_metric, 
       match_metric_cmd,
       "match metric <0-4294967295>",
       MATCH_STR
       "Match metric of route\n"
       "Metric value\n")
{
    return bgp_route_match_add (vty,( struct route_map_index * )  vty->index, "metric", argv[0]);
}

DEFUN (no_match_metric,
       no_match_metric_cmd,
       "no match metric",
       NO_STR
       MATCH_STR
       "Match metric of route\n")
{
    if (argc == 0)
        return bgp_route_match_delete (vty, ( struct route_map_index * ) vty->index, "metric", NULL);

    return bgp_route_match_delete (vty, ( struct route_map_index * ) vty->index, "metric", argv[0]);
}


DEFUN (match_community, 
       match_community_cmd,
       "match community WORD",
       MATCH_STR
       "Match BGP community list\n"
       "Community-list name (not community value itself)\n")
{
    return bgp_route_match_add (vty, ( struct route_map_index * ) vty->index, "community", argv[0]);
}

DEFUN (no_match_community,
       no_match_community_cmd,
       "no match community",
       NO_STR
       MATCH_STR
       "Match BGP community list\n")
{
    if (argc == 0)
        return bgp_route_match_delete (vty, ( struct route_map_index *) vty->index, "community", NULL);

    return bgp_route_match_delete (vty, ( struct route_map_index * ) vty->index, "community", argv[0]);
}

DEFUN (match_aspath,
       match_aspath_cmd,
       "match as-path WORD",
       MATCH_STR
       "Match BGP AS path list\n"
       "AS path access-list name\n")
{
    int i;
    struct buffer *b;
    char *regstr;
    int first;

    first = 0;
    b = buffer_new (1024);
    for (i = 0; i < argc; i++)
    {
        if (first)
            buffer_putc (b, ' ');
        else
            first = 1;

        buffer_putstr (b,(u_char * )  argv[i]);
    }
    buffer_putc (b, '\0');

    regstr = buffer_getstr (b);
    buffer_free (b);
    
    return bgp_route_match_add (vty, (struct route_map_index * ) vty->index, "as-path", regstr);
}

DEFUN (no_match_aspath,
       no_match_aspath_cmd,
       "no match as-path",
       NO_STR
       MATCH_STR
       "Match BGP AS path list\n")
{
    int i;
    struct buffer *b;
    char *regstr;
    int first;

    if (argc == 0)
        return bgp_route_match_delete (vty, ( struct route_map_index * ) vty->index, "as-path", NULL);

    first = 0;
    b = buffer_new (1024);
    for (i = 0; i < argc; i++)
    {
        if (first)
            buffer_putc (b, ' ');
        else
            first = 1;

        buffer_putstr (b,( u_char * )  argv[i]);
    }
    buffer_putc (b, '\0');

    regstr = buffer_getstr (b);
    buffer_free (b);

    return bgp_route_match_delete (vty, ( struct route_map_index * ) vty->index, "as-path", regstr);
}

DEFUN (set_ip_nexthop,
       set_ip_nexthop_cmd,
       "set ip next-hop A.B.C.D",
       SET_STR
       IP_STR
       "Next hop address\n"
       "IP address of next hop\n")
{
    union sockunion su;
    int ret;

    ret = str2sockunion (argv[0], &su);
    if (ret < 0)
    {
        vty_out (zlog_default,LOG_DEBUG, "%% Malformed Next-hop address%s", VTY_NEWLINE);
        return CMD_WARNING;
    }

    return bgp_route_set_add (vty, ( struct route_map_index * ) vty->index, "ip next-hop", argv[0]);
}

DEFUN (no_set_ip_nexthop,
       no_set_ip_nexthop_cmd,
       "no set ip next-hop",
       NO_STR
       SET_STR
       IP_STR
       "Next hop address\n")
{
    if (argc == 0)
        return bgp_route_set_delete (vty, ( struct route_map_index * ) vty->index, "ip next-hop", NULL);

    return bgp_route_set_delete (vty, ( struct route_map_index * ) vty->index, "ip next-hop", argv[0]);
}


DEFUN (set_metric,
       set_metric_cmd,
       "set metric (<0-4294967295>|<+/-metric>)",
       SET_STR
       "Metric value for destination routing protocol\n"
       "Metric value\n"
       "Add or subtract metric\n")
{
    return bgp_route_set_add (vty, ( struct route_map_index * ) vty->index, "metric", argv[0]);
}

DEFUN (no_set_metric,
       no_set_metric_cmd,
       "no set metric",
       NO_STR
       SET_STR
       "Metric value for destination routing protocol\n")
{
    if (argc == 0)
        return bgp_route_set_delete (vty, ( struct route_map_index * ) vty->index, "metric", NULL);

    return bgp_route_set_delete (vty, ( struct route_map_index * ) vty->index, "metric", argv[0]);
}


DEFUN (set_local_pref,
       set_local_pref_cmd,
       "set local-preference <0-4294967295>",
       SET_STR
       "BGP local preference path attribute\n"
       "Preference value\n")
{
    return bgp_route_set_add (vty, ( struct route_map_index * ) vty->index, "local-preference", argv[0]);
}

DEFUN (no_set_local_pref,
       no_set_local_pref_cmd,
       "no set local-preference",
       NO_STR
       SET_STR
       "BGP local preference path attribute\n")
{
    if (argc == 0)
        return bgp_route_set_delete (vty, ( struct route_map_index * ) vty->index, "local-preference", NULL);

    return bgp_route_set_delete (vty, ( struct route_map_index * ) vty->index, "local-preference", argv[0]);
}

DEFUN (set_weight,
       set_weight_cmd,
       "set weight <0-4294967295>",
       SET_STR
       "BGP weight for routing table\n"
       "Weight value\n")
{
    return bgp_route_set_add (vty, ( struct route_map_index * ) vty->index, "weight", argv[0]);
}

DEFUN (no_set_weight,
       no_set_weight_cmd,
       "no set weight",
       NO_STR
       SET_STR
       "BGP weight for routing table\n")
{
    if (argc == 0)
        return bgp_route_set_delete (vty, ( struct route_map_index * ) vty->index, "weight", NULL);

    return bgp_route_set_delete (vty, ( struct route_map_index * ) vty->index, "weight", argv[0]);
}

DEFUN (set_aspath_prepend,
       set_aspath_prepend_cmd,
       "set as-path prepend .<1-65535>",
       SET_STR
       "Prepend string for a BGP AS-path attribute\n"
       "Prepend to the as-path\n"
       "AS number\n")
{
    int i;
    struct buffer *b;
    char *asstr;
    int first;

    first = 0;
    b = buffer_new (1024);
    for (i = 0; i < argc; i++)
    {
        if (first)
            buffer_putc (b, ' ');
        else
            first = 1;

        buffer_putstr (b, ( u_char * ) argv[i]);
    }
    buffer_putc (b, '\0');

    asstr = buffer_getstr (b);
    buffer_free (b);

    return bgp_route_set_add (vty, ( struct route_map_index * ) vty->index, "as-path prepend", asstr);
}

DEFUN (no_set_aspath_prepend,
       no_set_aspath_prepend_cmd,
       "no set as-path prepend",
       NO_STR
       SET_STR
       "Prepend string for a BGP AS-path attribute\n"
       "Prepend to the as-path\n")
{
    int i;
    struct buffer *b;
    char *asstr;
    int first;

    if (argc == 0)
        return bgp_route_set_delete (vty, ( struct route_map_index * ) vty->index, "as-path prepend", NULL);

    first = 0;
    b = buffer_new (1024);
    for (i = 0; i < argc; i++)
    {
        if (first)
            buffer_putc (b, ' ');
        else
            first = 1;

        buffer_putstr (b, ( u_char * )argv[i]);
    }
    buffer_putc (b, '\0');

    asstr = buffer_getstr (b);
    buffer_free (b);

    return bgp_route_set_delete (vty, ( struct route_map_index * ) vty->index, "as-path prepend", asstr);
}


DEFUN (set_community,
       set_community_cmd,
       "set community .AA:NN",
       SET_STR
       "BGP community attribute\n"
       "Community number in aa:nn format or local-AS|no-advertise|no-export\n")
{
    int i;
    struct buffer *b;
    char *str;
    int first;

    if (argc == 0)
        return bgp_route_set_add (vty, ( struct route_map_index *) vty->index, "community", "none");

    first = 0;
    b = buffer_new (1024);
    for (i = 0; i < argc; i++)
    {
        if (first)
            buffer_putc (b, ' ');
        else
            first = 1;

        buffer_putstr (b, ( u_char * )argv[i]);
    }
    buffer_putc (b, '\0');

    str = buffer_getstr (b);
    buffer_free (b);

    return bgp_route_set_add (vty, ( struct route_map_index * ) vty->index, "community", str);
}


DEFUN (no_set_community,
       no_set_community_cmd,
       "no set community",
       NO_STR
       SET_STR
       "BGP community attribute\n")
{
    int i;
    struct buffer *b;
    char *str;
    int first;

    if (argc == 0)
        return bgp_route_set_delete (vty, ( struct route_map_index * ) vty->index, "community", NULL);

    first = 0;
    b = buffer_new (1024);
    for (i = 0; i < argc; i++)
    {
        if (first)
            buffer_putc (b, ' ');
        else
            first = 1;

        buffer_putstr (b,( u_char * ) argv[i]);
    }
    buffer_putc (b, '\0');

    str = buffer_getstr (b);
    buffer_free (b);

    return bgp_route_set_delete (vty, ( struct route_map_index * )  vty->index, "community", str);
}

DEFUN (set_community_additive,
       set_community_additive_cmd,
       "set community-additive .AA:NN",
       SET_STR
       "BGP community attribute (Add to the existing community)\n"
       "Community number in aa:nn format or local-AS|no-advertise|no-export\n")
{
    int i;
    struct buffer *b;
    char *str;
    int first;

    first = 0;
    b = buffer_new (1024);
    for (i = 0; i < argc; i++)
    {
        if (first)
            buffer_putc (b, ' ');
        else
            first = 1;

        buffer_putstr (b, ( u_char * )argv[i]);
    }
    buffer_putc (b, '\0');

    str = buffer_getstr (b);
    buffer_free (b);

    return bgp_route_set_add (vty, ( struct route_map_index * ) vty->index, "community-additive", str);
}

DEFUN (no_set_community_additive,
       no_set_community_additive_cmd,
       "no set community-additive",
       NO_STR
       SET_STR
       "BGP community attribute (Add to the existing community)\n")
{
    int i;
    struct buffer *b;
    char *str;
    int first;

    if (argc == 0)
        return bgp_route_set_delete (vty, ( struct route_map_index * ) vty->index, "community-additive", NULL);

    first = 0;
    b = buffer_new (1024);
    for (i = 0; i < argc; i++)
    {
        if (first)
            buffer_putc (b, ' ');
        else
            first = 1;

        buffer_putstr (b, ( u_char * )argv[i]);
    }
    buffer_putc (b, '\0');

    str = buffer_getstr (b);
    buffer_free (b);

    return bgp_route_set_delete (vty, ( struct route_map_index * ) vty->index, "community-additive", str);
}

DEFUN (set_community_delete,
       set_community_delete_cmd,
       "set community-delete WORD",
       SET_STR
       "BGP community attribute (Delete from the existing community)\n"
       "Community list (Permitted communities are deleted)\n")
{
    return bgp_route_set_add (vty, ( struct route_map_index * ) vty->index, "community-delete", argv[0]);
}

DEFUN (no_set_community_delete,
       no_set_community_delete_cmd,
       "no set community-delete",
       NO_STR
       SET_STR
       "BGP community attribute (Delete from existing community)\n")
{
    if (argc == 0)
        return bgp_route_set_delete (vty, ( struct route_map_index * ) vty->index, "community-delete", NULL);

    return bgp_route_set_delete (vty, ( struct route_map_index * ) vty->index, "community-delete", argv[0]);
}


DEFUN (set_ecommunity_rt,
       set_ecommunity_rt_cmd,
       "set extcommunity rt .ASN:nn_or_IP-address:nn",
       SET_STR
       "BGP extended community attribute\n"
       "Route Target extened communityt\n"
       "VPN extended community\n")
{
    int i;
    struct buffer *b;
    char *str;
    int first;

    first = 0;
    b = buffer_new (1024);
    for (i = 0; i < argc; i++)
    {
        if (first)
            buffer_putc (b, ' ');
        else
            first = 1;

        buffer_putstr (b, ( u_char * )argv[i]);
    }
    buffer_putc (b, '\0');

    str = buffer_getstr (b);
    buffer_free (b);

    return bgp_route_set_add (vty,( struct route_map_index * )  vty->index, "extcommunity rt", str);
}

DEFUN (no_set_ecommunity_rt,
       no_set_ecommunity_rt_cmd,
       "no set extcommunity rt",
       NO_STR
       SET_STR
       "BGP extended community attribute\n"
       "Route Target extened communityt\n")
{
    int i;
    struct buffer *b;
    char *str;
    int first;

    if (argc == 0)
        return bgp_route_set_delete (vty, ( struct route_map_index * ) vty->index, "extcommunity rt", NULL);

    first = 0;
    b = buffer_new (1024);
    for (i = 0; i < argc; i++)
    {
        if (first)
            buffer_putc (b, ' ');
        else
            first = 1;

        buffer_putstr (b, ( u_char * )argv[i]);
    }
    buffer_putc (b, '\0');

    str = buffer_getstr (b);
    buffer_free (b);

    return bgp_route_set_delete (vty, ( struct route_map_index * ) vty->index, "extcommunity rt", str);
}


DEFUN (set_ecommunity_soo,
       set_ecommunity_soo_cmd,
       "set extcommunity soo .ASN:nn_or_IP-address:nn",
       SET_STR
       "BGP extended community attribute\n"
       "Site-of-Origin extended community\n"
       "VPN extended community\n")
{
    int i;
    struct buffer *b;
    char *str;
    int first;

    first = 0;
    b = buffer_new (1024);
    for (i = 0; i < argc; i++)
    {
        if (first)
            buffer_putc (b, ' ');
        else
            first = 1;

        buffer_putstr (b, ( u_char * )argv[i]);
    }
    buffer_putc (b, '\0');

    str = buffer_getstr (b);
    buffer_free (b);

    return bgp_route_set_add (vty, ( struct route_map_index * ) vty->index, "extcommunity soo", str);
}

DEFUN (no_set_ecommunity_soo,
       no_set_ecommunity_soo_cmd,
       "no set extcommunity soo",
       NO_STR
       SET_STR
       "BGP extended community attribute\n"
       "Site-of-Origin extended community\n")
{
    int i;
    struct buffer *b;
    char *str;
    int first;

    if (argc == 0)
        return bgp_route_set_delete (vty, ( struct route_map_index * ) vty->index, "extcommunity soo", NULL);

    first = 0;
    b = buffer_new (1024);
    for (i = 0; i < argc; i++)
    {
        if (first)
            buffer_putc (b, ' ');
        else
            first = 1;

        buffer_putstr (b,( u_char * ) argv[i]);
    }
    buffer_putc (b, '\0');

    str = buffer_getstr (b);
    buffer_free (b);

    return bgp_route_set_delete (vty, ( struct route_map_index * ) vty->index, "extcommunity soo", str);
}


DEFUN (set_origin,
       set_origin_cmd,
       "set origin (egp|igp|incomplete)",
       SET_STR
       "BGP origin code\n"
       "remote EGP\n"
       "local IGP\n"
       "unknown heritage\n")
{
    return bgp_route_set_add (vty, ( struct route_map_index * ) vty->index, "origin", argv[0]);
}

DEFUN (no_set_origin,
       no_set_origin_cmd,
       "no set origin",
       NO_STR
       SET_STR
       "BGP origin code\n")
{
    if (argc == 0)
        return bgp_route_set_delete (vty, ( struct route_map_index * ) vty->index, "origin", NULL);

    return bgp_route_set_delete (vty, ( struct route_map_index * ) vty->index, "origin", argv[0]);
}


DEFUN (set_atomic_aggregate,
       set_atomic_aggregate_cmd,
       "set atomic-aggregate",
       SET_STR
       "BGP atomic aggregate attribute\n" )
{
    return bgp_route_set_add (vty, ( struct route_map_index *) vty->index, "atomic-aggregate", NULL);
}

DEFUN (no_set_atomic_aggregate,
       no_set_atomic_aggregate_cmd,
       "no set atomic-aggregate",
       NO_STR
       SET_STR
       "BGP atomic aggregate attribute\n" )
{
    return bgp_route_set_delete (vty, ( struct route_map_index * ) vty->index, "atomic-aggregate", NULL);
}

DEFUN (set_aggregator_as,
       set_aggregator_as_cmd,
       "set aggregator as <1-65535> A.B.C.D",
       SET_STR
       "BGP aggregator attribute\n"
       "AS number of aggregator\n"
       "AS number\n"
       "IP address of aggregator\n")
{
    int ret;
    as_t as;
    struct in_addr address;
    char *endptr = NULL;
    char *argstr;

    as = strtoul (argv[0], &endptr, 10);
    if (as == 0 || *endptr != '\0')
    {
        vty_out (zlog_default,LOG_DEBUG, "AS path value malformed%s", VTY_NEWLINE);
        return CMD_WARNING;
    }

    ret = inet_aton (argv[1], &address);
    if (ret == 0)
    {
        vty_out (zlog_default,LOG_DEBUG, "Aggregator IP address is invalid%s", VTY_NEWLINE);
        return CMD_WARNING;
    }

    argstr = ( char * ) XMALLOC (MTYPE_ROUTE_MAP_COMPILED,
                                 strlen (argv[0]) + strlen (argv[1]) + 2);

    sprintf (argstr, "%s %s", argv[0], argv[1]);

    ret = bgp_route_set_add (vty, ( struct route_map_index * ) vty->index, "aggregator as", argstr);

    XFREE (MTYPE_ROUTE_MAP_COMPILED, argstr);

    return ret;
}

DEFUN (no_set_aggregator_as,
       no_set_aggregator_as_cmd,
       "no set aggregator as",
       NO_STR
       SET_STR
       "BGP aggregator attribute\n"
       "AS number of aggregator\n")
{
    int ret;
    as_t as;
    struct in_addr address;
    char *endptr = NULL;
    char *argstr;

    if (argv == 0)
        return bgp_route_set_delete (vty, ( struct route_map_index * ) vty->index, "aggregator as", NULL);

    as = strtoul (argv[0], &endptr, 10);
    if (as == 0 || *endptr != '\0')
    {
        vty_out (zlog_default,LOG_DEBUG, "AS path value malformed%s", VTY_NEWLINE);
        return CMD_WARNING;
    }

    ret = inet_aton (argv[1], &address);
    if (ret == 0)
    {
        vty_out (zlog_default,LOG_DEBUG, "Aggregator IP address is invalid%s", VTY_NEWLINE);
        return CMD_WARNING;
    }

    argstr = ( char * ) XMALLOC (MTYPE_ROUTE_MAP_COMPILED,
                                 strlen (argv[0]) + strlen (argv[1]) + 2);

    sprintf (argstr, "%s %s", argv[0], argv[1]);

    ret = bgp_route_set_delete (vty, ( struct route_map_index * ) vty->index, "aggregator as", argstr);

    XFREE (MTYPE_ROUTE_MAP_COMPILED, argstr);

    return ret;
}





DEFUN (set_originator_id,
       set_originator_id_cmd,
       "set originator-id A.B.C.D",
       SET_STR
       "BGP originator ID attribute\n"
       "IP address of originator\n")
{
    return bgp_route_set_add (vty,( struct route_map_index * )  vty->index, "originator-id", argv[0]);
}

DEFUN (no_set_originator_id,
       no_set_originator_id_cmd,
       "no set originator-id",
       NO_STR
       SET_STR
       "BGP originator ID attribute\n")
{
    if (argc == 0)
        return bgp_route_set_delete (vty,( struct route_map_index * )  vty->index, "originator-id", NULL);

    return bgp_route_set_delete (vty,( struct route_map_index * )  vty->index, "originator-id", argv[0]);
}


/* Initialization of route map. */
void
Bgp::bgp_route_map_init ()
{
    route_map_init ();

    route_map_init_vty ();

    route_map_install_match (&route_match_ip_address_cmd);
    route_map_install_match (&route_match_ip_next_hop_cmd);
    route_map_install_match (&route_match_ip_address_prefix_list_cmd);
    route_map_install_match (&route_match_ip_next_hop_prefix_list_cmd);
    route_map_install_match (&route_match_aspath_cmd);
    route_map_install_match (&route_match_community_cmd);
    route_map_install_match (&route_match_metric_cmd);

    route_map_install_set (&route_set_ip_nexthop_cmd);
    route_map_install_set (&route_set_local_pref_cmd);
    route_map_install_set (&route_set_weight_cmd);
    route_map_install_set (&route_set_metric_cmd);
    route_map_install_set (&route_set_aspath_prepend_cmd);
    route_map_install_set (&route_set_origin_cmd);
    route_map_install_set (&route_set_atomic_aggregate_cmd);
    route_map_install_set (&route_set_aggregator_as_cmd);
    route_map_install_set (&route_set_community_cmd);
    route_map_install_set (&route_set_community_additive_cmd);
    route_map_install_set (&route_set_community_delete_cmd);
    route_map_install_set (&route_set_originator_id_cmd);
    route_map_install_set (&route_set_ecommunity_rt_cmd);
    route_map_install_set (&route_set_ecommunity_soo_cmd);

    install_element (RMAP_NODE, &match_ip_address_cmd);
    install_element (RMAP_NODE, &no_match_ip_address_cmd);
    install_element (RMAP_NODE, &no_match_ip_address_val_cmd);
    install_element (RMAP_NODE, &match_ip_next_hop_cmd);
    install_element (RMAP_NODE, &no_match_ip_next_hop_cmd);
    install_element (RMAP_NODE, &no_match_ip_next_hop_val_cmd);
    install_element (RMAP_NODE, &match_ip_address_prefix_list_cmd);
    install_element (RMAP_NODE, &no_match_ip_address_prefix_list_cmd);
    install_element (RMAP_NODE, &no_match_ip_address_prefix_list_val_cmd);
    install_element (RMAP_NODE, &match_ip_next_hop_prefix_list_cmd);
    install_element (RMAP_NODE, &no_match_ip_next_hop_prefix_list_cmd);
    install_element (RMAP_NODE, &no_match_ip_next_hop_prefix_list_val_cmd);
    install_element (RMAP_NODE, &match_aspath_cmd);
    install_element (RMAP_NODE, &no_match_aspath_cmd);
    install_element (RMAP_NODE, &no_match_aspath_val_cmd);
    install_element (RMAP_NODE, &match_metric_cmd);
    install_element (RMAP_NODE, &no_match_metric_cmd);
    install_element (RMAP_NODE, &no_match_metric_val_cmd);
    install_element (RMAP_NODE, &match_community_cmd);
    install_element (RMAP_NODE, &no_match_community_cmd);
    install_element (RMAP_NODE, &no_match_community_val_cmd);
    install_element (RMAP_NODE, &set_ip_nexthop_cmd);
    install_element (RMAP_NODE, &no_set_ip_nexthop_cmd);
    install_element (RMAP_NODE, &no_set_ip_nexthop_val_cmd);
    install_element (RMAP_NODE, &set_local_pref_cmd);
    install_element (RMAP_NODE, &no_set_local_pref_cmd);
    install_element (RMAP_NODE, &no_set_local_pref_val_cmd);
    install_element (RMAP_NODE, &set_weight_cmd);
    install_element (RMAP_NODE, &no_set_weight_cmd);
    install_element (RMAP_NODE, &no_set_weight_val_cmd);
    install_element (RMAP_NODE, &set_metric_cmd);
    install_element (RMAP_NODE, &no_set_metric_cmd);
    install_element (RMAP_NODE, &no_set_metric_val_cmd);
    install_element (RMAP_NODE, &set_aspath_prepend_cmd);
    install_element (RMAP_NODE, &no_set_aspath_prepend_cmd);
    install_element (RMAP_NODE, &no_set_aspath_prepend_val_cmd);
    install_element (RMAP_NODE, &set_origin_cmd);
    install_element (RMAP_NODE, &no_set_origin_cmd);
    install_element (RMAP_NODE, &no_set_origin_val_cmd);
    install_element (RMAP_NODE, &set_atomic_aggregate_cmd);
    install_element (RMAP_NODE, &no_set_atomic_aggregate_cmd);
    install_element (RMAP_NODE, &set_aggregator_as_cmd);
    install_element (RMAP_NODE, &no_set_aggregator_as_cmd);
    install_element (RMAP_NODE, &no_set_aggregator_as_val_cmd);
    install_element (RMAP_NODE, &set_community_cmd);
    install_element (RMAP_NODE, &set_community_none_cmd);
    install_element (RMAP_NODE, &no_set_community_cmd);
    install_element (RMAP_NODE, &no_set_community_val_cmd);
    install_element (RMAP_NODE, &no_set_community_none_cmd);
    install_element (RMAP_NODE, &set_community_additive_cmd);
    install_element (RMAP_NODE, &no_set_community_additive_cmd);
    install_element (RMAP_NODE, &no_set_community_additive_val_cmd);
    install_element (RMAP_NODE, &set_community_delete_cmd);
    install_element (RMAP_NODE, &no_set_community_delete_cmd);
    install_element (RMAP_NODE, &no_set_community_delete_val_cmd);
    install_element (RMAP_NODE, &set_ecommunity_rt_cmd);
    install_element (RMAP_NODE, &no_set_ecommunity_rt_cmd);
    install_element (RMAP_NODE, &no_set_ecommunity_rt_val_cmd);
    install_element (RMAP_NODE, &set_ecommunity_soo_cmd);
    install_element (RMAP_NODE, &no_set_ecommunity_soo_cmd);
    install_element (RMAP_NODE, &no_set_ecommunity_soo_val_cmd);
    install_element (RMAP_NODE, &set_originator_id_cmd);
    install_element (RMAP_NODE, &no_set_originator_id_cmd);
    install_element (RMAP_NODE, &no_set_originator_id_val_cmd);

}

////////////////////////////////////////////////
////////////////////////////////////////////////
///bgpd.c///////////////////////////////////////
////////////////////////////////////////////////


/* Set BGP's router identifier. */
int
Bgp::bgp_router_id_set (struct vty *vty, char *id_str)
{
    struct bgp *bgp;
    struct in_addr id;
    int ret;
    struct peer_conf *conf;
    struct listnode *nn;

    ret = inet_aton (id_str, &id);
    if (!ret)
    {
        vty_out (zlog_default,LOG_DEBUG, "Malformed bgp router identifier%s", VTY_NEWLINE);
        return CMD_WARNING;
    }

    /* Set identifier to BGP structure. */
    bgp = ( struct bgp * ) bgp_get_default();

    if (CHECK_FLAG (bgp->config, BGP_CONFIG_ROUTER_ID)
        && bgp->id.s_addr == id.s_addr)
      return CMD_SUCCESS;

    bgp->id = id;
    
    if(Bgp::use_log_fp_) {
      sprintf(new_line,"#%s#\n",id_str);
    }
    
    // Register my IP address 
    str2sockunion (id_str,&bgp->su);

    if(!Bgp::Ip2BgpMap) { 
      cerr <<" Fatal Error: No BGP registry has been initiated!"
	   <<" use the \"new BgpRegistry\" command in your tcl"
	   <<" script to create a BGP registry before creating"
	   <<" any bgp routers"<<endl;  
      exit(1);
    }


    Bgp::Ip2BgpMap->AddEntry(this,bgp->su);

    SET_FLAG (bgp->config, BGP_CONFIG_ROUTER_ID);

    /* Set all peer's local identifier with this value. */
    for (nn = bgp->peer_conf->head; nn; nn = nn->next)
        if ((conf = ( struct peer_conf * )  nn->data) != NULL)
        {
            conf->peer->local_id = id;
            /* Reset all BGP sessions */
            BGP_EVENT_ADD (conf->peer, BGP_Stop);
        }

    return CMD_SUCCESS;
}

/* Unset BGP router identifier. */
int
Bgp::bgp_router_id_unset (struct vty *vty, char *id_str)
{
    int ret;
    struct bgp *bgp;
    struct in_addr id;
    struct peer_conf *conf;
    struct listnode *nn;

    bgp = ( struct bgp * ) bgp_get_default();

    if (id_str)
    {
        ret = inet_aton (id_str, &id);
        if (!ret)
        {
            vty_out (zlog_default,LOG_DEBUG, "Malformed bgp router identifier%s", VTY_NEWLINE);
            return CMD_WARNING;
        }

        if (!IPV4_ADDR_SAME (&bgp->id, &id))
        {
            vty_out (zlog_default,LOG_DEBUG, "bgp router-id doesnt match%s", VTY_NEWLINE);
            return CMD_WARNING;
        }
    }

    if (! CHECK_FLAG (bgp->config, BGP_CONFIG_ROUTER_ID))
        return CMD_SUCCESS;

    bgp->id.s_addr = 0;
    UNSET_FLAG (bgp->config, BGP_CONFIG_ROUTER_ID);
    for (nn = bgp->peer_conf->head; nn; nn = nn->next)
        if ((conf =( struct peer_conf * ) nn->data) != NULL)
        {
            conf->peer->local_id.s_addr = 0;
        }

    /* Reset all BGP sessions */
    for (nn = bgp->peer_conf->head; nn; nn = nn->next)
        if ((conf = ( struct peer_conf * )nn->data) != NULL)
        {
            BGP_EVENT_ADD (conf->peer, BGP_Stop);
        }

    return CMD_SUCCESS;
}

DEFUN (bgp_router_id, 
       bgp_router_id_cmd,
       "bgp router-id A.B.C.D",
       "BGP specific commands\n"
       "Override configured router identifier\n"
       "Manually configured router identifier\n")
{
    return bgp_router_id_set (vty, argv[0]);
}

DEFUN (no_bgp_router_id, 
       no_bgp_router_id_cmd,
       "no bgp router-id",
       NO_STR
       "BGP specific commands\n"
       "Override configured router identifier\n")
{
    if (argc == 0)
        return bgp_router_id_unset (vty, NULL);

    return bgp_router_id_unset (vty, argv[0]);
}

/* Set BGP's global timers. */
int
Bgp::bgp_timers_set (struct vty *vty, char *keep_str, char *hold_str, int set)
{
    struct bgp *bgp;
    struct peer_conf *conf;
    struct listnode *nn;
    unsigned long keepalive = 0;
    unsigned long holdtime = 0;
    char *endptr = NULL;

    if (set)
    {
        /* keepalive value check. */
        keepalive = strtoul (keep_str, &endptr, 10);

        if (keepalive == ULONG_MAX || *endptr != '\0')
        {
            vty_out (zlog_default,LOG_DEBUG, "%% keepalive time value must be positive integer%s",
                     VTY_NEWLINE);
            return CMD_WARNING;
        }
        if (keepalive > 65535)
        {
            vty_out (zlog_default,LOG_DEBUG, "%% keepalive time value must be <0-65535>%s", VTY_NEWLINE);
            return CMD_WARNING;
        }

        /* Holdtime value check. */
        holdtime = strtoul (hold_str, &endptr, 10);

        if (holdtime == ULONG_MAX || *endptr != '\0')
        {
            vty_out (zlog_default,LOG_DEBUG, "%% hold time value must be positive integer%s", VTY_NEWLINE);
            return CMD_WARNING;
        }
        if (holdtime > 65535)
        {
            vty_out (zlog_default,LOG_DEBUG, "%% hold time value must be <0,3-65535>%s", VTY_NEWLINE);
            return CMD_WARNING;
        }
        if (holdtime < 3 && holdtime != 0)
        {
            vty_out (zlog_default,LOG_DEBUG, "%% hold time value must be either 0 or greater than 3%s",
                     VTY_NEWLINE);
            return CMD_WARNING;
        }
    }

    /* Set identifier to BGP structure. */
    bgp = ( struct bgp * ) bgp_get_default();

    /* Set value to the configuration. */
    if (set)
    {
        bgp->default_holdtime = holdtime;
        bgp->default_keepalive = (keepalive < holdtime / 3 ? keepalive : holdtime / 3);
    } else
    {
        bgp->default_holdtime = BGP_DEFAULT_HOLDTIME;
        bgp->default_keepalive = BGP_DEFAULT_KEEPALIVE;
    }

    /* Set all peer's global timers with this value. */
    for (nn = bgp->peer_conf->head; nn; nn = nn->next)
        if ((conf  = (struct peer_conf * ) nn->data) != NULL)
        {
            conf->peer->global_holdtime = bgp->default_holdtime;
            conf->peer->global_keepalive = bgp->default_keepalive;
        }

    return CMD_SUCCESS;
}

DEFUN (bgp_timers, 
       bgp_timers_cmd,
       "timers bgp <0-65535> <0-65535>",
       "Adjust routing timers\n"
       "BGP timers\n"
       "Keepalive interval\n"
       "Holdtime\n")
{
    return bgp_timers_set (vty, argv[0], argv[1], 1);
}

DEFUN (no_bgp_timers, 
       no_bgp_timers_cmd,
       "no timers bgp",
       NO_STR
       "Adjust routing timers\n"
       "BGP timers\n")
{
    return bgp_timers_set (vty, NULL, NULL, 0);
}

/* BGP's cluster-id control. */
int
Bgp::bgp_cluster_id_set (struct vty *vty, char *cluster_str)
{
    int ret;
    struct bgp *bgp;
    struct in_addr cluster;

    ret = inet_aton (cluster_str, &cluster);
    if (!ret)
    {
        vty_out (zlog_default,LOG_DEBUG, "Malformed bgp cluster identifier%s", VTY_NEWLINE);
        return CMD_WARNING;
    }
    bgp = ( struct bgp * ) bgp_get_default();
    bgp->cluster = cluster;
    bgp->config |= BGP_CONFIG_CLUSTER_ID;

    return CMD_SUCCESS;
}

int
Bgp::bgp_cluster_id_unset (struct vty *vty, char *cluster_str)
{
    int ret;
    struct bgp *bgp;
    struct in_addr cluster;

    bgp = ( struct bgp * ) bgp_get_default();

    if (cluster_str)
    {
        ret = inet_aton (cluster_str, &cluster);
        if (!ret)
        {
            vty_out (zlog_default,LOG_DEBUG, "Malformed bgp cluster identifier%s", VTY_NEWLINE);
            return CMD_WARNING;
        }
        if (! IPV4_ADDR_SAME (&bgp->cluster, &cluster))
        {
            vty_out (zlog_default,LOG_DEBUG, "bgp cluster-id doesnt match%s", VTY_NEWLINE);
            return CMD_WARNING;
        }
    }
    bgp->cluster.s_addr = 0;
    bgp->config &= ~BGP_CONFIG_CLUSTER_ID;

    return CMD_SUCCESS;
}

DEFUN (bgp_cluster_id, 
       bgp_cluster_id_cmd,
       "bgp cluster-id A.B.C.D",
       "BGP specific commands\n"
       "Configure Route-Reflector Cluster-id\n"
       "Route-Reflector Cluster-id in IP address format\n")
{
    return bgp_cluster_id_set (vty, argv[0]);
}


DEFUN (no_bgp_cluster_id, 
       no_bgp_cluster_id_cmd,
       "no bgp cluster-id",
       NO_STR
       "BGP specific commands\n"
       "Configure Route-Reflector Cluster-id\n")
{
    if (argc == 0)
        return bgp_cluster_id_unset (vty, NULL);

    return bgp_cluster_id_unset (vty, argv[0]);
}


int
Bgp::bgp_confederation_id_set (struct vty *vty, char *id_str)
{
    struct bgp *bgp;
    as_t as = 0;
    unsigned long input_as = 0;
    char *endptr = NULL;
    struct peer *peer;
    struct listnode *nn;
    int old_confed_flag;  /* Old Confederations status */

    bgp =( struct bgp * )  bgp_get_default();

    if (id_str)
    {
        input_as = strtoul (id_str, &endptr, 10);
        if ( *endptr != '\0' || input_as < 1 || input_as > 65535)
        {
            vty_out (zlog_default,LOG_DEBUG, "AS value error%s", VTY_NEWLINE);
            return CMD_WARNING;
        }
        as = input_as;
        /* Remember - were we doing CONFEDs before? */
        old_confed_flag = CHECK_FLAG (bgp->config, BGP_CONFIG_CONFEDERATION);
        bgp->confederation_id = as;
        SET_FLAG (bgp->config, BGP_CONFIG_CONFEDERATION);

        /*
         * how to handle already setup peers?
         * Answer - If we were doing CONFEDs already 
         *               - this is just an external AS change
         *               - just Reset EBGP sessions, not CONFED sessions
         *          If we were not doing CONFEDs before
         *               - Reset all EBGP sessions
         */
        for (nn = peer_list->head; nn; nn = nn->next)
            if ((peer = ( struct peer * ) nn->data) != NULL)
            {
                /* We're looking for peers who's AS is not local or part of
                       our CONFED*/
                if (old_confed_flag)
                {
                    if (peer_sort (peer) == BGP_PEER_EBGP)
                    {
                        peer->local_as = as;
                        BGP_EVENT_ADD (peer, BGP_Stop);
                    }
                } else
                {
                    /* Not doign CONFEDs before, so reset every non-local
                           session */
                    if (peer_sort (peer) != BGP_PEER_IBGP)
                    {
                        /* Reset the local_as to be our EBGP one */
                        if (peer_sort (peer) == BGP_PEER_EBGP)
                            peer->local_as = as;
                        BGP_EVENT_ADD (peer, BGP_Stop);
                    }
                }
            }
        return CMD_SUCCESS;
    } else
    {
        vty_out (zlog_default,LOG_DEBUG, "No AS Number provided%s", VTY_NEWLINE);
        return CMD_WARNING;
    }
    return CMD_WARNING;
}

int
Bgp::bgp_confederation_id_unset (struct vty *vty, char *id_str)
{
    struct bgp *bgp;
    as_t as;
    unsigned long input_as = 0;
    char *endptr = NULL;
    struct peer *peer;
    struct listnode *nn;

    bgp = ( struct bgp* ) bgp_get_default();

    if (id_str)
    {
        input_as = strtoul (id_str, &endptr, 10);
        if ( *endptr != '\0' || input_as < 1 || input_as > 65535)
        {
            vty_out (zlog_default,LOG_DEBUG, "%% AS value error%s", VTY_NEWLINE);
            return CMD_WARNING;
        }
	as = input_as;
        if (bgp->confederation_id != as)
        {
            vty_out (zlog_default,LOG_DEBUG, "%% AS value does not match%s", VTY_NEWLINE);
            return CMD_WARNING;
        }

        bgp->confederation_id = 0;
        UNSET_FLAG (bgp->config, BGP_CONFIG_CONFEDERATION);

        /*
         * How do we handle all EBGP peers if we have no external AS?
         * Assumption - No Confed ID == no CONFEDERATIONS, so
         * clear all EBGP *AND* CONFED peers and bring up with no spoofing.
         */
        for (nn = peer_list->head; nn; nn = nn->next)
            if ((peer = ( struct peer * )  nn->data) != NULL)
            {
                /* We're looking for peers who's AS is not local */
                if (peer_sort (peer) != BGP_PEER_IBGP)
                {
                    peer->local_as = bgp->as;
                    BGP_EVENT_ADD (peer, BGP_Stop);
                }
            }
        return CMD_SUCCESS;
    } else
    {
        vty_out (zlog_default,LOG_DEBUG, "%% No AS Number provided%s", VTY_NEWLINE);
        return CMD_WARNING;
    }
    return CMD_WARNING;     
}

/* Is an AS part of the confed or not? */
int
Bgp::bgp_confederation_peers_check (struct bgp *bgp, as_t as)
{
    int i;

    if (bgp == NULL)
        return 0;

    for (i = 0; i < bgp->confederation_peers_cnt; i++)
    {
        if (bgp->confederation_peers[i] == as)
            return 1;
    }

    return 0;
}

/* Add an AS to the CONFED set */
void
Bgp::bgp_confederation_peers_add (struct bgp *bgp, as_t as)
{
    bgp->confederation_peers = ( as_t * ) XREALLOC (MTYPE_BGP_CONFED_LIST, 
                                                    bgp->confederation_peers,
                                                    bgp->confederation_peers_cnt + 1);
    bgp->confederation_peers[bgp->confederation_peers_cnt] = as;
    bgp->confederation_peers_cnt++;
}

void
Bgp::bgp_confederation_peers_remove (struct bgp *bgp, as_t as)
{
    int i;
    int j;

    for (i = 0; i < bgp->confederation_peers_cnt; i++)
    {
        if (bgp->confederation_peers[i] == as)
        {
            /* Remove this entry */
            for (j = i+1; j < bgp->confederation_peers_cnt; j++)
            {
                bgp->confederation_peers[j-1] = bgp->confederation_peers[j];
            }
        }
    }

    bgp->confederation_peers_cnt--;

    if (bgp->confederation_peers_cnt == 0)
    {
        bgp->confederation_peers = NULL;
    } else
    {
        bgp->confederation_peers = ( as_t * )XREALLOC(MTYPE_BGP_CONFED_LIST,
                                                      bgp->confederation_peers,
                                                      bgp->confederation_peers_cnt);
    }
}

int
Bgp::bgp_confederation_peers_set (struct vty *vty, int argc, char *argv[])
{
    struct bgp *bgp;
    as_t as;
    unsigned long input_as = 0;
    int i;
    char *endptr = NULL;

    bgp = (struct bgp* ) bgp_get_default();

    for (i = 0; i < argc; i++)
    {
        input_as = strtoul (argv[i], &endptr, 10);
        if ( input_as < 1 || input_as > 65535)
        {
            vty_out (zlog_default,LOG_DEBUG, "AS Value error (%s), ignoring%s",
                     argv[i], VTY_NEWLINE);
        } else
        {
	    as = input_as;
            if (bgp->as == as)
            {
                vty_out (zlog_default,LOG_DEBUG, "%% Local member-AS not allowed in confed peer list%s",
                         VTY_NEWLINE);
                continue;
            }
            if (! bgp_confederation_peers_check (bgp, as))
            {
                struct peer *peer;
                struct listnode *nn;

                /* Its not there already, so add it */
                bgp_confederation_peers_add (bgp, as);

                /* Now reset any peer who's remote AS has just joined
               the CONFED unless its an iBGP peer */
                for (nn = peer_list->head; nn; nn = nn->next)
                    if ((peer = ( struct peer * ) nn->data) != NULL)
                    {
                        if (peer->as == as)
                        {
                            /* If the AS added to the list */
                            if (CHECK_FLAG (bgp->config, BGP_CONFIG_CONFEDERATION))
                            {
                                peer->local_as = bgp->as;
                                BGP_EVENT_ADD (peer, BGP_Stop);
                            }
                        }
                    }
            } else
            {
                /* Silently ignore repeated ASs */
            }
        }
    }
    return CMD_SUCCESS;
}

int
Bgp::bgp_confederation_peers_unset (struct vty *vty, int argc, char *argv[])
{
    struct bgp *bgp;
    as_t as;
    unsigned long input_as = 0;
    int i;
    char *endptr = NULL;

    bgp = ( struct bgp * ) bgp_get_default();

    for (i = 0; i < argc; i++)
    {
        input_as = strtoul (argv[i], &endptr, 10);

        if ( input_as < 1 || input_as > 65535)
            continue;

	as = input_as;

        if (! bgp_confederation_peers_check(bgp, as))
        {
            /* Its not there already, so silently ignore this*/
        } else
        {
            struct peer *peer;
            struct listnode *nn;

            /* Its there - we need to remove it */
            bgp_confederation_peers_remove (bgp, as);

            /* Now reset any peer who's remote AS has just been
               removed from the CONFED */
            for (nn = peer_list->head; nn; nn = nn->next)
                if ((peer = ( struct peer * ) nn->data) != NULL)
                {
                    if (peer->as == as)
                    {
                        /* Set the peer's local-as correctly */
                        if (CHECK_FLAG (bgp->config, BGP_CONFIG_CONFEDERATION))
                        {
                            peer->local_as = bgp->confederation_id;
                            BGP_EVENT_ADD (peer, BGP_Stop);
                        }
                    }
                }
        }
    }
    return CMD_SUCCESS;
}

void
Bgp::bgp_confederation_peers_print (struct vty *vty, struct bgp *bgp)
{
    int i;

    for (i = 0; i < bgp->confederation_peers_cnt; i++)
    {
       vty_out (zlog_default,LOG_DEBUG, " ");

       vty_out (zlog_default,LOG_DEBUG, "%d", bgp->confederation_peers[i]);
    }
}

DEFUN (bgp_confederation_peers, 
       bgp_confederation_peers_cmd,
       "bgp confederation peers .<1-65535>",
       "BGP specific commands\n"
       "AS confederation parameters\n"
       "Peer ASs in BGP confederation\n"
       AS_STR)
{
    return bgp_confederation_peers_set(vty, argc, argv);
}

DEFUN (bgp_confederation_identifier, 
       bgp_confederation_identifier_cmd,
       "bgp confederation identifier <1-65535>",
       "BGP specific commands\n"
       "AS confederation parameters\n"
       "AS number\n"
       "Set routing domain confederation AS\n")
{
    return bgp_confederation_id_set(vty, argv[0]);
}

DEFUN (no_bgp_confederation_peers, 
       no_bgp_confederation_peers_cmd,
       "no bgp confederation peers .<1-65535>",
       NO_STR
       "BGP specific commands\n"
       "AS confederation parameters\n"
       "Peer ASs in BGP confederation\n"
       AS_STR)
{
    return bgp_confederation_peers_unset(vty, argc, argv);
}

DEFUN (no_bgp_confederation_identifier, 
       no_bgp_confederation_identifier_cmd,
       "no bgp confederation identifier <1-65535>",
       NO_STR
       "BGP specific commands\n"
       "AS confederation parameters\n"
       "AS number\n"
       "Set routing domain confederation AS\n")
{
    return bgp_confederation_id_unset(vty, argv[0]);
}

/* "no bgp client-to-client reflection" configuration. */
DEFUN (no_bgp_client_to_client_reflection,
       no_bgp_client_to_client_reflection_cmd,
       "no bgp client-to-client reflection",
       NO_STR
       "BGP specific commands\n"
       "Configure client to client route reflection\n"
       "reflection of routes allowed\n")
{
    struct bgp *bgp;

    bgp = ( struct bgp * ) bgp_get_default();
    SET_FLAG (bgp->config, BGP_CONFIG_NO_CLIENT_TO_CLIENT);
    return CMD_SUCCESS;
}

DEFUN (bgp_client_to_client_reflection,
       bgp_client_to_client_reflection_cmd,
       "bgp client-to-client reflection",
       "BGP specific commands\n"
       "Configure client to client route reflection\n"
       "reflection of routes allowed\n")
{
    struct bgp *bgp;

    bgp = ( struct bgp* ) bgp_get_default();
    UNSET_FLAG (bgp->config, BGP_CONFIG_NO_CLIENT_TO_CLIENT);
    return CMD_SUCCESS;
}

/* "bgp always-compare-med" configuration. */
DEFUN (bgp_always_compare_med,
       bgp_always_compare_med_cmd,
       "bgp always-compare-med",
       "BGP specific commands\n"
       "Allow comparing MED from different neighbors\n")
{
    struct bgp *bgp;

    bgp = ( struct bgp* ) bgp_get_default();
    SET_FLAG (bgp->config, BGP_CONFIG_ALWAYS_COMPARE_MED);
    return CMD_SUCCESS;
}

DEFUN (no_bgp_always_compare_med,
       no_bgp_always_compare_med_cmd,
       "no bgp always-compare-med",
       NO_STR
       "BGP specific commands\n"
       "Allow comparing MED from different neighbors\n")
{
    struct bgp *bgp;

    bgp = ( struct bgp* ) bgp_get_default();
    UNSET_FLAG (bgp->config, BGP_CONFIG_ALWAYS_COMPARE_MED);
    return CMD_SUCCESS;
}

/* "bgp deterministic-med" configuration. */
DEFUN (bgp_deterministic_med,
       bgp_deterministic_med_cmd,
       "bgp deterministic-med",
       "BGP specific commands\n"
       "Pick the best-MED path among paths advertised from the neighboring AS\n")
{
    struct bgp *bgp;

    bgp = ( struct bgp * ) bgp_get_default();
    SET_FLAG (bgp->config, BGP_CONFIG_DETERMINISTIC_MED);
    return CMD_SUCCESS;
}

DEFUN (no_bgp_deterministic_med,
       no_bgp_deterministic_med_cmd,
       "no bgp deterministic-med",
       NO_STR
       "BGP specific commands\n"
       "Pick the best-MED path among paths advertised from the neighboring AS\n")
{
    struct bgp *bgp;

    bgp = ( struct bgp * ) bgp_get_default();
    UNSET_FLAG (bgp->config, BGP_CONFIG_DETERMINISTIC_MED);
    return CMD_SUCCESS;
}

/* "bgp enforce-first-as" configuration. */
DEFUN (bgp_enforce_first_as,
       bgp_enforce_first_as_cmd,
       "bgp enforce-first-as",
       BGP_STR
       "Enforce the first AS for EBGP routes\n")
{
    struct bgp *bgp;

    bgp = ( struct bgp * ) bgp_get_default();
    SET_FLAG (bgp->config, BGP_CONFIG_ENFORCE_FIRST_AS);
    return CMD_SUCCESS;
}

DEFUN (no_bgp_enforce_first_as,
       no_bgp_enforce_first_as_cmd,
       "no bgp enforce-first-as",
       NO_STR
       BGP_STR
       "Enforce the first AS for EBGP routes\n")
{
    struct bgp *bgp;

    bgp = ( struct bgp * ) bgp_get_default();
    UNSET_FLAG (bgp->config, BGP_CONFIG_ENFORCE_FIRST_AS);
    return CMD_SUCCESS;
}

/* "bgp bestpath compare-routerid" configuration.  */
DEFUN (bgp_bestpath_compare_router_id,
       bgp_bestpath_compare_router_id_cmd,
       "bgp bestpath compare-routerid",
       "BGP specific commands\n"
       "Change the default bestpath selection\n"
       "Compare router-id for identical EBGP paths\n")
{
    struct bgp *bgp;

    bgp = ( struct bgp * ) bgp_get_default();
    SET_FLAG (bgp->config, BGP_CONFIG_COMPARE_ROUTER_ID);
    return CMD_SUCCESS;
}

DEFUN (no_bgp_bestpath_compare_router_id,
       no_bgp_bestpath_compare_router_id_cmd,
       "no bgp bestpath compare-routerid",
       NO_STR
       "BGP specific commands\n"
       "Change the default bestpath selection\n"
       "Compare router-id for identical EBGP paths\n")
{
    struct bgp *bgp;

    bgp = ( struct bgp * ) bgp_get_default();
    UNSET_FLAG (bgp->config, BGP_CONFIG_COMPARE_ROUTER_ID);
    return CMD_SUCCESS;
}

/* "bgp bestpath as-path ignore" configuration.  */
DEFUN (bgp_bestpath_aspath_ignore,
       bgp_bestpath_aspath_ignore_cmd,
       "bgp bestpath as-path ignore",
       "BGP specific commands\n"
       "Change the default bestpath selection\n"
       "AS-path attribute\n"
       "Ignore as-path length in selecting a route\n")
{
    struct bgp *bgp;

    bgp = ( struct bgp * ) bgp_get_default();
    SET_FLAG (bgp->config, BGP_CONFIG_ASPATH_IGNORE);
    return CMD_SUCCESS;
}

DEFUN (no_bgp_bestpath_aspath_ignore,
       no_bgp_bestpath_aspath_ignore_cmd,
       "no bgp bestpath as-path ignore",
       NO_STR
       "BGP specific commands\n"
       "Change the default bestpath selection\n"
       "AS-path attribute\n"
       "Ignore as-path length in selecting a route\n")
{
    struct bgp *bgp;

    bgp = ( struct bgp * )bgp_get_default();
    UNSET_FLAG (bgp->config, BGP_CONFIG_ASPATH_IGNORE);
    return CMD_SUCCESS;
}


/* "bgp bestpath med" configuration. */
DEFUN (bgp_bestpath_med,
       bgp_bestpath_med_cmd,
       "bgp bestpath med (confed|missing-as-worst)",
       "BGP specific commands\n"
       "Change the default bestpath selection\n"
       "MED attribute\n"
       "Compare MED among confederation paths\n"
       "Treat missing MED as the least preferred one\n")
{
    struct bgp *bgp;

    bgp = ( struct bgp * )bgp_get_default();

    if (strcmp (argv[0], "confed") == 0)
        SET_FLAG (bgp->config, BGP_CONFIG_MED_CONFED);
    else
        SET_FLAG (bgp->config, BGP_CONFIG_MED_MISSING_AS_WORST);

    return CMD_SUCCESS;
}

DEFUN (bgp_bestpath_med2,
       bgp_bestpath_med2_cmd,
       "bgp bestpath med confed missing-as-worst",
       "BGP specific commands\n"
       "Change the default bestpath selection\n"
       "MED attribute\n"
       "Compare MED among confederation paths\n"
       "Treat missing MED as the least preferred one\n")
{
    struct bgp *bgp;

    bgp = ( struct bgp * )bgp_get_default();
    SET_FLAG (bgp->config, BGP_CONFIG_MED_CONFED);
    SET_FLAG (bgp->config, BGP_CONFIG_MED_MISSING_AS_WORST);
    return CMD_SUCCESS;
}


DEFUN (no_bgp_bestpath_med,
       no_bgp_bestpath_med_cmd,
       "no bgp bestpath med (confed|missing-as-worst)",
       NO_STR
       "BGP specific commands\n"
       "Change the default bestpath selection\n"
       "MED attribute\n"
       "Compare MED among confederation paths\n"
       "Treat missing MED as the least preferred one\n")
{
    struct bgp *bgp;

    bgp = ( struct bgp * )bgp_get_default();

    if (strcmp (argv[0], "confed") == 0)
        UNSET_FLAG (bgp->config, BGP_CONFIG_MED_CONFED);
    else
        UNSET_FLAG (bgp->config, BGP_CONFIG_MED_MISSING_AS_WORST);

    return CMD_SUCCESS;
}

DEFUN (no_bgp_bestpath_med2,
       no_bgp_bestpath_med2_cmd,
       "no bgp bestpath med confed missing-as-worst",
       NO_STR
       "BGP specific commands\n"
       "Change the default bestpath selection\n"
       "MED attribute\n"
       "Compare MED among confederation paths\n"
       "Treat missing MED as the least preferred one\n")
{
    struct bgp *bgp;

    bgp = ( struct bgp * )bgp_get_default();
    UNSET_FLAG (bgp->config, BGP_CONFIG_MED_CONFED);
    UNSET_FLAG (bgp->config, BGP_CONFIG_MED_MISSING_AS_WORST);
    return CMD_SUCCESS;
}


DEFUN (bgp_default_local_preference,
       bgp_default_local_preference_cmd,
       "bgp default local-preference <0-4294967295>",
       "BGP specific commands\n"
       "Configure BGP defaults\n"
       "local preference (higher=more preferred)\n"
       "Configure default local preference value\n")
{
    struct bgp *bgp;

    bgp = ( struct bgp * )bgp_get_default();
    bgp->default_local_pref = atoi(argv[0]);
    return CMD_SUCCESS;
}

DEFUN (no_bgp_default_local_preference,
       no_bgp_default_local_preference_cmd,
       "no bgp default local-preference",
       NO_STR
       "BGP specific commands\n"
       "Configure BGP defaults\n"
       "local preference (higher=more preferred)\n")
{
    struct bgp *bgp;

    bgp =( struct bgp * ) bgp_get_default();
    bgp->default_local_pref = BGP_DEFAULT_LOCAL_PREF;
    return CMD_SUCCESS;
}


/* allocate New peer object */
extern "C" {
#include "bgp/c-lib/hash.h"
}

struct peer *
Bgp::peer_new ()
{
    struct peer *new_peer;

    /* Allocate New peer. */
    new_peer = new struct peer;
    mstat[MTYPE_BGP_PEER].alloc++;
    
    /* zebra 0.93b has memset to zero *new_peer. we clear fields instead. */

    new_peer->as = 0;
    new_peer->local_as = 0;
    new_peer->ttl = 0;
    new_peer->desc = NULL;
    new_peer->host = NULL;
    memset(&new_peer->su,0,sizeof(union sockunion));
    new_peer->uptime = 0;
    new_peer->readtime = 0;
    memset(&new_peer->nexthop,0,sizeof(struct bgp_nexthop));
    memset(&new_peer->afc, 0, AFI_MAX * SAFI_MAX * sizeof(u_char));
    memset(&new_peer->afc_nego, 0, AFI_MAX * SAFI_MAX * sizeof(u_char));
    memset(&new_peer->afc_adv, 0, AFI_MAX * SAFI_MAX * sizeof(u_char));
    memset(&new_peer->afc_recv, 0, AFI_MAX * SAFI_MAX * sizeof(u_char));
    new_peer->refresh_adv = 0;
    new_peer->refresh_nego_old = 0;
    new_peer->refresh_nego_new = 0;
    memset(&new_peer->af_flags, 0, AFI_MAX * SAFI_MAX * sizeof(u_int32_t));
    new_peer->config = 0;
    new_peer->holdtime = 0;
    new_peer->keepalive = 0;
    new_peer->connect = 0;
    new_peer->routeadv = 0;

    new_peer->global_holdtime = 0;
    new_peer->global_keepalive = 0;
    new_peer->v_routeadv = 0;

    new_peer->open_in = 0;
    new_peer->open_out = 0;
    new_peer->update_in = 0;
    new_peer->update_out = 0;
    new_peer->update_time = 0;
    new_peer->keepalive_in = 0;
    new_peer->keepalive_out = 0;
    new_peer->notify_in = 0;
    new_peer->notify_out = 0;
    new_peer->refresh_in = 0;
    new_peer->refresh_out = 0;
    new_peer->established = 0;
    new_peer->dropped = 0;
#ifdef HAVE_ZEBRA_93b
    new_peer->synctime = 0;
#endif
    new_peer->target = NULL;

    /* Set default value. */
    new_peer->v_start = BGP_INIT_START_TIMER;
    new_peer->v_connect = BGP_DEFAULT_CONNECT_RETRY;
    new_peer->v_holdtime = BGP_DEFAULT_HOLDTIME;
    new_peer->v_keepalive = BGP_DEFAULT_KEEPALIVE;
    new_peer->v_asorig = BGP_DEFAULT_ASORIGINATE;
    new_peer->status = Idle;
    new_peer->ostatus = Idle;
    new_peer->version = BGP_VERSION_4;
    new_peer->weight = 0;
    //    new_peer->translate_update  = 0;
    new_peer->flags = 0 ;
    new_peer->sflags = 0 ;

    SET_FLAG (new_peer->af_flags[AFI_IP][SAFI_UNICAST], PEER_FLAG_SEND_COMMUNITY);
    SET_FLAG (new_peer->af_flags[AFI_IP][SAFI_UNICAST], PEER_FLAG_SEND_EXT_COMMUNITY);
    SET_FLAG (new_peer->flags, PEER_FLAG_CAPABILITY_ROUTE_REFRESH);
    SET_FLAG (new_peer->sflags, PEER_STATUS_CAPABILITY_OPEN);

    new_peer->ibuf = stream_new (BGP_MAX_PACKET_SIZE);
    new_peer->obuf = stream_fifo_new ();
#ifdef HAVE_ZEBRA_93b
    new_peer->work = stream_new (BGP_MAX_PACKET_SIZE);
    bgp_sync_init (new_peer);
#endif
    new_peer->conf = list_new ();

#ifndef HAVE_ZEBRA_93b    
    /* Not used */
    new_peer->adj_in[AFI_IP][SAFI_UNICAST] = route_table_init ();
    new_peer->adj_out[AFI_IP][SAFI_UNICAST] = route_table_init ();
    new_peer->t_routeadv_list = NULL;
    new_peer->top_adv = NULL;
    
#endif

    new_peer->t_read = NULL;  
    new_peer->t_write = NULL;
    new_peer->t_start = NULL;
    new_peer->t_connect = NULL;
    new_peer->t_holdtime = NULL;
    new_peer->t_keepalive = NULL;
    new_peer->t_asorig = NULL;
    new_peer->t_routeadv = NULL;

    new_peer->remote_id.s_addr = 0;
    new_peer->local_id.s_addr = 0;

    new_peer->su_local = NULL;
    new_peer->su_remote = NULL;
    new_peer->log = NULL;
    new_peer->packet_size = 0 ; 

    /* Create Agents for this new_peer */
    new_peer->LocalAgent  = NULL;
#ifdef HAVE_PDNS_BGP    
    new_peer->is_peer_remote = false;
#endif 
    memset(&new_peer->notify,0,sizeof(struct bgp_notify));

    return new_peer;
}

/* Check peer's AS number and determin is this peer IBPG or EBGP */
int
Bgp::peer_sort (struct peer *peer)
{
    /* Find the relevant BGP structure */
    struct bgp *bgp;
    struct peer_conf *conf;
    struct listnode *nn;

    /* This becomes slightly more complicated as we have to find the
       CONFEDERATION list, so we can see if this is a BGP_PEER_CONFED */
    bgp = NULL;
    for (nn = peer->conf->head; nn; nn = nn->next)
        if ((conf = ( struct peer_conf* ) nn->data) != NULL)
        {
            bgp = conf->bgp;
        }

    if (bgp && CHECK_FLAG(bgp->config, BGP_CONFIG_CONFEDERATION))
    {
        if (peer->local_as == 0)
            return BGP_PEER_INTERNAL;

        if (peer->local_as == peer->as)
        {
            if (peer->local_as == bgp->confederation_id)
                return BGP_PEER_EBGP;
            else
                return BGP_PEER_IBGP;
        }

        if (bgp_confederation_peers_check(bgp, peer->as))
            return BGP_PEER_CONFED;

        return BGP_PEER_EBGP;
    } else
    {
        return(peer->local_as == 0
               ? BGP_PEER_INTERNAL : peer->local_as == peer->as
               ? BGP_PEER_IBGP : BGP_PEER_EBGP);
    }
}

int
Bgp::peer_list_cmp (struct peer *p1, struct peer *p2)
{
    return sockunion_cmp (&p1->su, &p2->su);
}

int
Bgp::peer_conf_cmp (struct peer_conf *p1, struct peer_conf *p2)
{
    return sockunion_cmp (&p1->peer->su, &p2->peer->su);
}

struct peer_conf *
Bgp::peer_conf_new()
{
    struct peer_conf *pconf;

    pconf = ( struct peer_conf * ) XMALLOC (MTYPE_PEER_CONF, sizeof (struct peer_conf));
    memset (pconf, 0, sizeof (struct peer_conf));
    return pconf;
}

void
Bgp::peer_conf_free (struct peer_conf *pconf)
{
    XFREE (MTYPE_PEER_CONF, pconf);
}

void
Bgp::peer_conf_delete (struct peer_conf *conf)
{
    int i;
    afi_t afi;
    safi_t safi;
    struct bgp_filter *filter;

    for (afi = AFI_IP; afi < AFI_MAX; afi++)
        for (safi = SAFI_UNICAST; safi < SAFI_MAX; safi++)
        {
            filter = &conf->filter[afi][safi];

            for (i = FILTER_IN; i < FILTER_MAX; i++)
            {
                if (filter->dlist[i].name)
                    free (filter->dlist[i].name);
                if (filter->plist[i].name)
                    free (filter->plist[i].name);
                if (filter->aslist[i].name)
                    free (filter->aslist[i].name);
                if (filter->map[i].name)
                    free (filter->map[i].name);
            }
        }
    peer_conf_free (conf);
}

/* BGP instance creation by `router bgp' commands. */
struct bgp *
Bgp::bgp_create ()
{
    struct bgp *bgp;
    afi_t afi;
    safi_t safi;

    bgp =( struct bgp* )  XMALLOC (MTYPE_BGP, sizeof (struct bgp));
    memset (bgp, 0, sizeof (struct bgp));

    bgp->peer_conf = list_new ();
    bgp->peer_conf->cmp = (int (Bgp::*)(void *, void *)) &Bgp::peer_conf_cmp;

    for (afi = AFI_IP; afi < AFI_MAX; afi++)
        for (safi = SAFI_UNICAST; safi < SAFI_MAX; safi++)
        {
            bgp->route[afi][safi] = route_table_init ();
            bgp->aggregate[afi][safi] = route_table_init ();
            bgp->rib[afi][safi] = route_table_init ();
        }

    bgp->default_local_pref = BGP_DEFAULT_LOCAL_PREF;
    bgp->default_holdtime = BGP_DEFAULT_HOLDTIME;
    bgp->default_keepalive = BGP_DEFAULT_KEEPALIVE;

    return bgp;
}

/* Return first entry of BGP. */
struct bgp *
Bgp::bgp_get_default ()
{
    if (bgp_list->head)
        return( struct bgp * ) bgp_list->head->data;
    return NULL;
}

/* Lookup BGP entry. */
struct bgp *
Bgp::bgp_lookup (as_t as, char *name)
{
    struct bgp *bgp;
    struct listnode *nn;
    for (nn = bgp_list->head; nn; nn = nn->next)
        if ((bgp = ( struct bgp* ) nn->data) != NULL)
            if (bgp->as == as
                && ((bgp->name == NULL && name == NULL) 
                    || (bgp->name && name && strcmp (bgp->name, name) == 0)))
                return bgp;
    return NULL;
}

/* Lookup BGP structure by view name. */
struct bgp *
Bgp::bgp_lookup_by_name (char *name)
{
    struct bgp *bgp;
    struct listnode *nn;
    for (nn = bgp_list->head; nn; nn = nn->next)
        if ((bgp = ( struct bgp* ) nn->data) != NULL)
            if ((bgp->name == NULL && name == NULL)
                || (bgp->name && name && strcmp (bgp->name, name) == 0))
                return bgp;
    return NULL;
}

/* Called from VTY commands. */
int
Bgp::bgp_get (struct vty *vty, as_t as, char *name)
{
    struct bgp *bgp;

    if (name)
      {
	vty_out (zlog_default,LOG_DEBUG, "Please specify 'bgp multiple-instance' first%s",
		 VTY_NEWLINE);
	return CMD_WARNING;
      }
    
    /* Get first BGP structure if exists. */
    bgp = bgp_get_default ();
    
    if (bgp)
      {
	if (bgp->as != as)
	  {
	    vty_out (zlog_default,LOG_DEBUG, "BGP is already running; AS is %d%s", bgp->as,
		     VTY_NEWLINE);
	    return CMD_WARNING;
	  }
	vty->index = bgp;
	return CMD_SUCCESS;
      }
    
    bgp = bgp_create ();
    bgp->as = as;
    listnode_add (bgp_list, bgp);
    
    vty->index = bgp;
    return CMD_SUCCESS;
    
    return CMD_SUCCESS;
}

int
Bgp::bgp_get_by_str (struct vty *vty, char *as_str, char *name)
{
    char *endptr = NULL;
    as_t as;
    unsigned long input_as = 0;

    /* Convert string to number. */
    input_as = strtoul (as_str, &endptr, 10);
    if ( *endptr != '\0' || input_as < 1 || input_as > 65535)
    {
        vty_out (zlog_default,LOG_DEBUG, "AS value error%s", VTY_NEWLINE);
        return CMD_WARNING;
    }
    as = input_as;

    return bgp_get (vty, as, name);
}

/* Delete BGP instance. */
void
Bgp::bgp_delete (struct bgp *bgp)
{
    struct peer_conf *conf;
    struct listnode *nn;
    struct listnode *next;
    afi_t afi;
    safi_t safi;

    /* Delete static route. */
    bgp_static_delete (bgp);

    for (nn = bgp->peer_conf->head; nn; nn = next)
    {
        conf = ( struct peer_conf * ) nn->data;
        next = nn->next;
        peer_delete (conf->peer);
    }

    /* Clear peer_conf */
    list_delete (bgp->peer_conf);

    listnode_delete (bgp_list, bgp);

    if (bgp->name)
        free (bgp->name);

    for (afi = AFI_IP; afi < AFI_MAX; afi++)
        for (safi = SAFI_UNICAST; safi < SAFI_MAX; safi++)
        {
            if (bgp->route[afi][safi])
                XFREE (MTYPE_ROUTE_TABLE, bgp->route[afi][safi]);
            if (bgp->aggregate[afi][safi])
                XFREE (MTYPE_ROUTE_TABLE,bgp->aggregate[afi][safi]) ;
            if (bgp->rib[afi][safi])
                XFREE (MTYPE_ROUTE_TABLE,bgp->rib[afi][safi]);
        }

    XFREE (MTYPE_BGP, bgp);
}

/* This function is called from VTY command.  Act as a wrapper of
   bgp_delte (). */
int
Bgp::bgp_destroy (struct vty *vty, char *as_str, char *name)
{
    struct bgp *bgp;
    char *endptr = NULL;
    as_t as;
    unsigned long input_as = 0;
    /* struct in_addr id; */

    /* Convert string to number. */
    input_as = strtoul (as_str, &endptr, 10);
    if ( *endptr != '\0' || input_as < 1 || input_as > 65535)
    {
        vty_out (zlog_default,LOG_DEBUG, "AS value error%s", VTY_NEWLINE);
        return CMD_WARNING;
    }
    as = input_as;

    /* Lookup bgp structure. */
    bgp = bgp_lookup (as, name);

    if (!bgp)
    {
        vty_out (zlog_default,LOG_DEBUG, "Cant find BGP instance%s", VTY_NEWLINE);
        return CMD_WARNING;
    }

    bgp_delete (bgp);

    return CMD_SUCCESS;
}

/* `router bgp' commands. */
DEFUN (router_bgp, 
       router_bgp_cmd, 
       "router bgp <1-65535>",
       ROUTER_STR
       BGP_STR
       AS_STR)
{ 
    return bgp_get_by_str (vty, argv[0], NULL);
}

/* `no router bgp' commands. */
DEFUN (no_router_bgp,
       no_router_bgp_cmd,
       "no router bgp <1-65535>",
       NO_STR
       ROUTER_STR
       BGP_STR
       AS_STR)
{
    return bgp_destroy (vty, argv[0], NULL);
}

/* Peer identification.

   Peer structure is identified by it's IP address, local AS number,
   remote AS number and local router-id.  Normally, local router-id
   identification is used only for Merit MRT like route server
   configuration.

   When user configure the peer under specific BGP instance node, only
   IP address and local AS number are used for looking up.  If the
   peer's remote AS number and user configuration AS number is
   different, the peer's AS number is changed. */

struct peer *
Bgp::peer_lookup_with_local_as (union sockunion *su, as_t local_as)
{
    struct peer *peer;
    struct listnode *nn;
    for (nn = peer_list->head; nn; nn = nn->next)
        if ((peer =( struct peer * )  nn->data) != NULL)
        {
            if (sockunion_same (&peer->su, su) 
                && peer->local_as == local_as)
                return peer;
        }
    return NULL;
}

/* Accepting remote BGP connection, at least remote connection's
   source IP address is configured as a peer.  This function check the
   existance of the IP address. */

struct peer *
Bgp::peer_lookup_by_su (union sockunion *su)
{
    struct peer *peer;
    struct listnode *nn;
    for (nn = peer_list->head; nn; nn = nn->next)
        if ((peer = ( struct peer * ) nn->data) != NULL)
        {
            if (sockunion_same (&peer->su, su)
                && ! CHECK_FLAG (peer->sflags, PEER_STATUS_ACCEPT_PEER))
                return peer;
        }
    return NULL;
}

/* BGP Open packet includes remote router's AS number and router-id.
   We lookup local peer with those information.  First loop check
   exact match peer including remote router-id.  Second loop check
   anonymous router-id peer.  */

struct peer *
Bgp::peer_lookup_with_open (union sockunion *su, as_t remote_as,
                            struct in_addr *remote_id, int *as)
{
    struct peer *peer;
    struct listnode *nn;
    for (nn = peer_list->head; nn; nn = nn->next)
        if ((peer = ( struct peer * ) nn->data) != NULL)
        {
            if (sockunion_same (&peer->su, su)
                && ! CHECK_FLAG (peer->sflags, PEER_STATUS_ACCEPT_PEER))
            {
                if (peer->as == remote_as
                    && peer->remote_id.s_addr == remote_id->s_addr)
                    return peer;
                if (peer->as == remote_as)
                    *as = 1;
            }
        }
    for (nn = peer_list->head; nn; nn = nn->next)
        if ((peer = ( struct peer * ) nn->data) != NULL)
        {
            if (sockunion_same (&peer->su, su)
                &&  ! CHECK_FLAG (peer->sflags, PEER_STATUS_ACCEPT_PEER))
            {
                if (peer->as == remote_as
                    && peer->remote_id.s_addr == 0)
                    return peer;
                if (peer->as == remote_as)
                    *as = 1;
            }
        }
    return NULL;
}

struct peer_conf *
Bgp::peer_conf_lookup (struct bgp *bgp, union sockunion *su, int afi)
{
    struct listnode *nn;
    struct peer_conf *conf;
    for (nn = bgp->peer_conf->head; nn; nn = nn->next)
        if ((conf = ( struct peer_conf * ) nn->data) != NULL)
        {
            if (sockunion_same (&conf->peer->su, su))
                return conf;
        }
    return NULL;
}

/* Utility function for lookup peer from VTY commands. */
struct peer_conf *
Bgp::peer_conf_lookup_vty (struct vty *vty, char *ip_str, int afi)
{
    int ret;
    struct bgp *bgp;
    union sockunion su;
    struct peer_conf *conf;

    bgp = bgp_get_default();

    ret = str2sockunion (ip_str, &su);
    if (ret < 0)
    {
        vty_out (zlog_default,LOG_DEBUG, "Malformed address: %s%s", ip_str, VTY_NEWLINE);
        return NULL;
    }

    conf = peer_conf_lookup (bgp, &su, afi);
    if (! conf)
    {
        vty_out (zlog_default,LOG_DEBUG, "Cant find peer: %s%s", ip_str, VTY_NEWLINE);
        return NULL;
    }
    return conf;
}

struct peer_conf *
Bgp::peer_conf_lookup_existing (struct bgp *bgp, union sockunion *su)
{
    struct listnode *nn;
    struct peer_conf *conf;
    for (nn = bgp->peer_conf->head; nn; nn = nn->next)
        if ((conf = ( struct peer_conf * ) nn->data) != NULL)
        {
            if (sockunion_same (&conf->peer->su, su))
                return conf;
        }
    return NULL;
}

/* Display peer uptime. */
char *
Bgp::peer_uptime (time_t uptime2, char *buf, size_t len)
{
    time_t uptime1;
    struct tm *tm;

    /* Check buffer length. */
    if (len < BGP_UPTIME_LEN)
    {
        zlog_warn ("peer_uptime (): buffer shortage %d\n", len);
        return "";
    }

    /* If there is no connection has been done before print `never'. */
    if (uptime2 == 0)
    {
        snprintf (buf, len, "never   ");
        return buf;
    }

    /* Get current time. */
    double simulation_time;
    simulation_time = Scheduler::instance().clock();
    time_t clock = (int)simulation_time + start_time;
    uptime1 = clock;
    uptime1 -= uptime2;
    tm = gmtime (&uptime1);

    /* Making formatted timer strings. */
#define ONE_DAY_SECOND 60*60*24
#define ONE_WEEK_SECOND 60*60*24*7

    if (uptime1 < ONE_DAY_SECOND)
        snprintf (buf, len, "%02d:%02d:%02d", 
                  tm->tm_hour, tm->tm_min, tm->tm_sec);
    else if (uptime1 < ONE_WEEK_SECOND)
        snprintf (buf, len, "%dd%02dh%02dm", 
                  tm->tm_yday, tm->tm_hour, tm->tm_min);
    else
        snprintf (buf, len, "%02dw%dd%02dh", 
                  tm->tm_yday/7, tm->tm_yday - ((tm->tm_yday/7) * 7), tm->tm_hour);
    return buf;
}

/* If peer is configured at least one address family return 1. */
int
Bgp::peer_active (struct peer *peer)
{
    if (peer->afc[AFI_IP][SAFI_UNICAST]
        //|| peer->afc[AFI_IP][SAFI_MULTICAST]
	//        || peer->afc[AFI_IP6][SAFI_UNICAST]
	//        || peer->afc[AFI_IP6][SAFI_MULTICAST]
	)
        return 1;
    return 0;
}

struct peer *
Bgp::peer_create (union sockunion *su, as_t local_as, struct in_addr id,
                  as_t remote_as, u_int32_t holdtime, u_int32_t keepalive)
{
    struct peer *peer;
    char buf[SU_ADDRSTRLEN];

    peer = peer_new ();
    int nbytes = 100;
    peer->su = *su;
    peer->local_as = local_as;
    peer->as = remote_as;    
    peer->local_id = id;
    peer->global_holdtime = holdtime;
    peer->global_keepalive = keepalive;
    listnode_add_sort (peer_list, peer);

    double simulation_time;
    simulation_time = Scheduler::instance().clock();

    /* Last read time set */
    peer->readtime = start_time + (int) simulation_time;

    /* Default TTL set. */
    peer->ttl = (peer_sort (peer) == BGP_PEER_IBGP ? 255 : 1);

    /* Make peer's address string. */
    sockunion2str (su, buf, SU_ADDRSTRLEN);
    peer->host = strdup (buf);

    if (peer_sort (peer) == BGP_PEER_IBGP)
      peer->v_routeadv = BGP_DEFAULT_IBGP_ROUTEADV;
    else
      peer->v_routeadv = BGP_DEFAULT_EBGP_ROUTEADV;

    /* Set up peer's events and timers. */
    bgp_timer_set (peer);

    return peer;
}

/* Make accept BGP peer.  Called from bgp_accept (). */
struct peer *
Bgp::peer_create_accept ()
{
    struct peer *peer;

    peer = peer_new ();

    listnode_add_sort (peer_list, peer);

    return peer;
}

/* Change peer's AS number */
int
Bgp::peer_as_change (struct peer *peer, as_t as)
{
    /* Stop peer. */
    bgp_stop (peer);

    peer->as = as;

     /* Advertisement-interval reset */
    if (peer_sort (peer) == BGP_PEER_IBGP)
      peer->v_routeadv = BGP_DEFAULT_IBGP_ROUTEADV;
    else
      peer->v_routeadv = BGP_DEFAULT_EBGP_ROUTEADV;
    
    /* ebgp-multihop reset. */

    return CMD_SUCCESS;
}

void
Bgp::peer_af_flag_reset (afi_t afi, safi_t safi, struct peer_conf *conf)
{
    struct peer *peer;
    struct bgp_filter *filter;
    int i;

    peer = conf->peer;
    filter = &conf->filter[afi][safi];

    /* Clear neighbor filter and route-map */
    for (i = FILTER_IN; i < FILTER_MAX; i++)
    {
        if (filter->dlist[i].name)
        {
            free (filter->dlist[i].name);
            filter->dlist[i].name = NULL;
        }
        if (filter->plist[i].name)
        {
            free (filter->plist[i].name);
            filter->plist[i].name = NULL; 
        }
        if (filter->aslist[i].name)
        {
            free (filter->aslist[i].name);
            filter->aslist[i].name = NULL;
        }
        if (filter->map[i].name)
        {
            free (filter->map[i].name);
            filter->map[i].name = NULL;
        }
    }

    /* Clear neighbor next-hop-self */
    UNSET_FLAG (peer->af_flags[afi][safi], PEER_FLAG_NEXTHOP_SELF);

    /* Clear neighbor send-community */
    SET_FLAG (peer->af_flags[afi][safi], PEER_FLAG_SEND_COMMUNITY);
    SET_FLAG (peer->af_flags[afi][safi], PEER_FLAG_SEND_EXT_COMMUNITY);

    /* Clear neighbor route-reflector-client */
    UNSET_FLAG (peer->af_flags[afi][safi], PEER_FLAG_REFLECTOR_CLIENT);

    /* Clear neighbor route-server-client */
    UNSET_FLAG (peer->af_flags[afi][safi], PEER_FLAG_RSERVER_CLIENT);

    /* Clear neighbor soft-reconfiguration inbound */
    UNSET_FLAG (peer->af_flags[afi][safi], PEER_FLAG_SOFT_RECONFIG);

    /* Clear neighbor maximum-prefix */
    conf->pmax[afi][safi] = 0;
    conf->pmax_warning[afi][safi] =  0;
}

struct peer_conf *
Bgp::peer_conf_create (int afi, int safi, struct peer *peer)
{
    struct peer_conf *conf;
    int active;

    /* Make New peer configuration then link it to the peer. */
    conf = peer_conf_new ();
    conf->peer = peer;
    listnode_add_sort (peer->conf, conf);

    /* Store peer's active status. */
    active = peer_active (peer);

    conf->afc[afi][SAFI_UNICAST] = 1;
    peer->afc[afi][SAFI_UNICAST]++;
   
    /* If this configuration activate the peer, set start timer. */
    if (! active && peer_active (peer) && Bgp::default_randomize)
        bgp_timer_set (peer);

    return conf;
}

void
Bgp::peer_conf_active (int afi, int safi, struct peer_conf *conf)
{
    int active;
    struct peer *peer;

    peer = conf->peer;
    active = peer_active (peer);

    conf->afc[afi][safi] = 1;
    conf->peer->afc[afi][safi]++;

    /* If this configuration activate the peer, set start timer. */
    if (! active && peer_active (peer))
        bgp_timer_set (peer);
    else
        BGP_EVENT_ADD (peer, BGP_Stop);
}

void
Bgp::peer_conf_deactive (int afi, int safi, struct peer_conf *conf)
{
    struct peer *peer;

    peer = conf->peer;

    /* Must be configured. */
    if (! conf->afc[afi][safi])
        return;

    conf->afc[afi][safi] = 0;
    peer->afc[afi][safi]--; 

    /* Clear peer Per AF configuration */
    peer_af_flag_reset (afi, safi, conf);

    BGP_EVENT_ADD (peer, BGP_Stop);
}

/* Make or change remote peer's AS number. */
int
Bgp::peer_remote_as (struct vty *vty, char *ip_str, char *as_str, int afi, int safi)
{
    int ret;
    struct bgp *bgp;
    char *endptr = NULL;
    as_t as;
    unsigned long input_as = 0;
    union sockunion su;
    struct peer *peer;
    struct peer_conf *conf;

    ret = str2sockunion (ip_str, &su);
    if (ret < 0)
    {
        vty_out (zlog_default,LOG_DEBUG, "Malformed address: %s%s", ip_str, VTY_NEWLINE);
        return CMD_WARNING;
    }

    input_as = strtoul (as_str, &endptr, 10);
    if (*endptr != '\0' || input_as < 1 || input_as > 65535)
    {
        vty_out (zlog_default,LOG_DEBUG, "AS value error: %s%s", as_str, VTY_NEWLINE);
        return CMD_WARNING;
    }
    as = input_as;

    bgp = bgp_get_default();

    peer = peer_lookup_with_local_as (&su, bgp->as);
    if (CHECK_FLAG(bgp->config, BGP_CONFIG_CONFEDERATION) && ! peer)
    {
        peer = peer_lookup_with_local_as (&su, bgp->confederation_id);
    }

    if (peer)
    {
        /* Lookup peer_conf */
        conf = peer_conf_lookup (bgp, &su, afi);

        if (! conf)
        {
            /* New peer configuration. */
            conf = peer_conf_create (afi, safi, peer);
            conf->bgp = bgp;
            listnode_add_sort (bgp->peer_conf, conf);
        }

        /* Existing peer's AS number change. */
        if (peer->as != as)
            peer_as_change (peer, as);

        /* Existing peer's SAFI change. */
        /* XXXX need code here. */;
    } else
    {
        /* Real peer creation. */

        /* If the peer is not part of our CONFED, and its not an iBGP peer then
       spoof the source AS */
        if (CHECK_FLAG (bgp->config, BGP_CONFIG_CONFEDERATION) 
            && ! bgp_confederation_peers_check(bgp, as) 
            && bgp->as != as)
        {
            peer = peer_create (&su, bgp->confederation_id,
                                bgp->id, as, bgp->default_holdtime,
                                bgp->default_keepalive);

        } else
        {
            peer = peer_create (&su, bgp->as, bgp->id, as,
                                bgp->default_holdtime,
                                bgp->default_keepalive);

        }

        /* If this is IPv4 unicast configuration and "no bgp default
           ipv4-unicast" is specified. */
        if (CHECK_FLAG (bgp->config, BGP_CONFIG_NO_DEFAULT_IPV4)
            && afi == AFI_IP && safi == SAFI_UNICAST)
            conf = peer_conf_create (0, 0, peer);
        else
            conf = peer_conf_create (afi, safi, peer);

        conf->bgp = bgp;
        listnode_add_sort (bgp->peer_conf, conf);
    }

    return CMD_SUCCESS;
}

int
Bgp::peer_activate (struct vty *vty, char *ip_str, int afi, int safi)
{
    int ret;
    union sockunion su;
    struct bgp *bgp;
    struct peer_conf *conf;

    bgp = ( struct bgp * ) bgp_get_default();

    /* Lookup peer. */
    ret = str2sockunion (ip_str, &su);
    if (ret < 0)
    {
        vty_out (zlog_default,LOG_DEBUG, "Malformed address: %s%s", ip_str, VTY_NEWLINE);
        return CMD_WARNING;
    }

    conf = peer_conf_lookup_existing (bgp, &su);
    if (! conf)
    {
        vty_out (zlog_default,LOG_DEBUG, "%% Specify remote-as or peer-group commands first%s",
                 VTY_NEWLINE);
        return CMD_WARNING;
    }

    /* Activate the address family configuration. */
    if (! conf->afc[afi][safi])
        peer_conf_active (afi, safi, conf);

    return CMD_SUCCESS;
}

int
Bgp::peer_deactivate (struct vty *vty, char *ip_str, int afi, int safi)
{
    int ret;
    union sockunion su;
    struct bgp *bgp;
    struct peer_conf *conf;

    bgp = ( struct bgp * ) bgp_get_default();

    /* Lookup peer. */
    ret = str2sockunion (ip_str, &su);
    if (ret < 0)
    {
        vty_out (zlog_default,LOG_DEBUG, "Malformed address: %s%s", ip_str, VTY_NEWLINE);
        return CMD_WARNING;
    }

    conf = peer_conf_lookup_existing (bgp, &su);
    if (! conf)
    {
        vty_out (zlog_default,LOG_DEBUG, "%% Specify remote-as or peer-group commands first%s",
                 VTY_NEWLINE);
        return CMD_WARNING;
    }

    /* De-activate the address family configuration. */
    if (conf->afc[afi][safi])
        peer_conf_deactive (afi, safi, conf);

    return CMD_SUCCESS;
}

/* Delete peer from confguration. */
void
Bgp::peer_delete (struct peer *peer)
{
    struct peer_conf *conf;
    struct listnode *nn;

    /* Withdraw all information from routing table.  We can not use
       BGP_EVENT_ADD (peer, BGP_Stop) at here.  Because the event is
       executed after peer structure is deleted. */
    if (0) printf("\n%s: DELETE PEER",name());
    bgp_stop (peer);
    fsm_change_status (peer, Idle);

    /* Delete peer_conf link from BGP structure. */
    for (nn = peer->conf->head; nn; nn = nn->next)
        if ((conf = ( struct peer_conf * ) nn->data) != NULL)
        {
            listnode_delete (conf->bgp->peer_conf, conf);
        }

        /* Free peer_conf structure. */
    peer->conf->del = (void (Bgp::*) (void *)) &Bgp::peer_conf_delete;
    list_delete (peer->conf);
    peer->conf = NULL;

    /* Stop all timers. */
    BGP_TIMER_OFF (peer->t_start);
    BGP_TIMER_OFF (peer->t_keepalive);
    BGP_TIMER_OFF (peer->t_holdtime);
    BGP_TIMER_OFF (peer->t_connect);
    BGP_TIMER_OFF (peer->t_asorig);
    BGP_TIMER_OFF (peer->t_routeadv);

    /* Delete from all peer list. */
    listnode_delete (peer_list, peer);

    if (peer->ibuf)
        stream_free (peer->ibuf);

    if (peer->obuf)
        stream_fifo_free (peer->obuf);
#ifdef HAVE_ZEBRA_93b
    if (peer->work)
      stream_free (peer->work);

    afi_t afi;
    safi_t safi;
    
    for (afi = AFI_IP; afi < AFI_MAX; afi++)
      for (safi = SAFI_UNICAST; safi < SAFI_MAX; safi++)
	{
	  if (peer->sync[afi][safi])
	    XFREE (MTYPE_TMP, peer->sync[afi][safi]);
	  peer->sync[afi][safi] = NULL;
	  
	  hash_free (peer->hash[afi][safi]);
	}
    //bgp_sync_delete (peer);

#endif

    /* Free allocated host character. */
    if (peer->host)
        free (peer->host);

    /* Local and remote addresses. */
    if (peer->su_local)
        XFREE (MTYPE_TMP, peer->su_local);
    if (peer->su_remote)
        XFREE (MTYPE_TMP, peer->su_remote);

#ifndef HAVE_ZEBRA_93b
    if (peer->adj_in[AFI_IP][SAFI_UNICAST])
        XFREE (MTYPE_ROUTE_TABLE,peer->adj_in [AFI_IP][SAFI_UNICAST]   );
    if (peer->adj_out[AFI_IP][SAFI_UNICAST])
        XFREE (MTYPE_ROUTE_TABLE,peer->adj_out[AFI_IP][SAFI_UNICAST]   );
#endif
    /* Free peer structure. */
    delete peer;
    mstat[MTYPE_BGP_PEER].alloc--;
}

int
Bgp::peer_destroy (struct vty *vty, char *ip_str, char *as_str, int afi, int safi)
{
    int ret;
    struct bgp *bgp;
    char *endptr = NULL;
    as_t as = 0;
    unsigned long input_as = 0;
    union sockunion su;
    struct peer *peer;

    ret = str2sockunion (ip_str, &su);
    if (ret < 0)
    {
        vty_out (zlog_default,LOG_DEBUG, "Malformed address: %s%s", ip_str, VTY_NEWLINE);
        return CMD_WARNING;
    }

    if (as_str)
    {
        input_as = strtoul (as_str, &endptr, 10);
        if ( *endptr != '\0' || input_as < 1 || input_as > 65535)
        {
            vty_out (zlog_default,LOG_DEBUG, "AS value error: %s%s", as_str, VTY_NEWLINE);
            return CMD_WARNING;
        }
	as = input_as;
    }

    bgp = ( struct bgp * ) bgp_get_default();

    peer = peer_lookup_with_local_as (&su, bgp->as);
    if (CHECK_FLAG(bgp->config, BGP_CONFIG_CONFEDERATION) && !peer)
    {
        peer = peer_lookup_with_local_as (&su, bgp->confederation_id);
    }

    if (! peer)
    {
        vty_out (zlog_default,LOG_DEBUG, "Cant find peer: %s%s", ip_str, VTY_NEWLINE);
        return CMD_WARNING;
    }
    if (as_str && peer->as != as)
    {
        vty_out (zlog_default,LOG_DEBUG, "AS mismatch%s", VTY_NEWLINE);
        return CMD_WARNING;
    }

    peer_delete (peer);

    return CMD_SUCCESS;
}


/* Change specified peer flag. */
int
Bgp::peer_change_af_flag (struct vty *vty, char *ip_str, afi_t afi, safi_t safi,
                          u_int16_t flag, enum flag_change_type type)
{
    struct peer *peer;
    struct peer_conf *conf;

    conf = peer_conf_lookup_vty (vty, ip_str, afi);
    if (! conf)
        return CMD_WARNING;
    if (! conf->afc[afi][safi])
    {
        vty_out (zlog_default,LOG_DEBUG, "%% Activate the neighbor for the address family first%s",
                 VTY_NEWLINE);
        return CMD_WARNING;
    }

    peer = conf->peer;

    if (type == flag_change_set
        || type == flag_change_set_reset)
    {
        if (CHECK_FLAG (peer->af_flags[afi][safi], flag))
            return CMD_WARNING;

        SET_FLAG (peer->af_flags[afi][safi], flag);
        if (type == flag_change_set_reset)
            BGP_EVENT_ADD (peer, BGP_Stop);
    } else
    {
        if (! CHECK_FLAG (peer->af_flags[afi][safi], flag))
            return CMD_WARNING;

        UNSET_FLAG (peer->af_flags[afi][safi], flag);
        if (type == flag_change_unset_reset)
            BGP_EVENT_ADD (peer, BGP_Stop);
    }

    return CMD_SUCCESS;
}

/* Change specified peer flag. */
int
Bgp::peer_change_flag (struct vty *vty, char *ip_str, int afi, u_int16_t flag,
                       int set)
{
    struct peer *peer;
    struct peer_conf *conf;

    conf = peer_conf_lookup_vty (vty, ip_str, afi);
    if (! conf)
        return CMD_WARNING;
    peer = conf->peer;

    if (set)
        SET_FLAG (peer->flags, flag);
    else
        UNSET_FLAG (peer->flags, flag);
    return CMD_SUCCESS;
}

/* Change specified peer flag with resetting the connection.  If the
   flag is not changed nothing occur. */
int
Bgp::peer_change_flag_with_reset (struct vty *vty, char *ip_str, int afi,
                                  u_int16_t flag, int set)
{
    struct peer *peer;
    struct peer_conf *conf;

    conf = peer_conf_lookup_vty (vty, ip_str, afi);
    if (! conf)
        return CMD_WARNING;
    peer = conf->peer;

    if (set)
    {
        if (! CHECK_FLAG (peer->flags, flag))
        {
            SET_FLAG (peer->flags, flag);
            BGP_EVENT_ADD (peer, BGP_Stop);
        }
    } else
    {
        if (CHECK_FLAG (peer->flags, flag))
        {
            UNSET_FLAG (peer->flags, flag);
            BGP_EVENT_ADD (peer, BGP_Stop);
        }
    }
    return CMD_SUCCESS;
}

DEFUN (neighbor_remote_as,
       neighbor_remote_as_cmd,
       NEIGHBOR_CMD "remote-as <1-65535>",
       NEIGHBOR_STR
       NEIGHBOR_ADDR_STR
       "Specify a BGP neighbor\n"
       AS_STR)
{
    if (0) printf("\n%s: Creating peer IP %s AS %s",name(),argv[0],argv[1]);
    return peer_remote_as (vty, argv[0], argv[1], AFI_IP, SAFI_UNICAST);
}

DEFUN (neighbor_activate,
       neighbor_activate_cmd,
       NEIGHBOR_CMD "activate",
       NEIGHBOR_STR
       NEIGHBOR_ADDR_STR
       "Enable the Address Family for this Neighbor\n")
{
    return peer_activate (vty, argv[0], bgp_node_afi (vty),
                          bgp_node_safi (vty));
}

DEFUN (no_neighbor_activate,
       no_neighbor_activate_cmd,
       NO_NEIGHBOR_CMD "activate",
       NO_STR
       NEIGHBOR_STR
       NEIGHBOR_ADDR_STR
       "Enable the Address Family for this Neighbor\n")
{
    return peer_deactivate (vty, argv[0], bgp_node_afi (vty),
                            bgp_node_safi (vty));
}

DEFUN (no_neighbor,
       no_neighbor_cmd,
       NO_NEIGHBOR_CMD,
       NO_STR
       NEIGHBOR_STR
       NEIGHBOR_ADDR_STR)
{
    return peer_destroy (vty, argv[0], NULL, AFI_IP, SAFI_UNICAST);
}

DEFUN (no_neighbor_remote_as,
       no_neighbor_remote_as_cmd,
       NO_NEIGHBOR_CMD "remote-as <1-65535>",
       NO_STR
       NEIGHBOR_STR
       NEIGHBOR_ADDR_STR
       "Specify a BGP neighbor\n"
       AS_STR)
{
    return peer_destroy (vty, argv[0], argv[1], AFI_IP, SAFI_UNICAST);
}


/* router-id set. */
int
Bgp::peer_router_id (struct vty *vty, char *ip_str, int afi, char *id_str)
{
    struct peer *peer;
    struct peer_conf *conf;
    struct in_addr id;
    int ret;

    conf = peer_conf_lookup_vty (vty, ip_str, afi);
    if (! conf)
        return CMD_WARNING;

    peer = conf->peer;

    if (id_str)
    {
        ret = inet_aton (id_str, &id);
        if (! ret)
        {
            vty_out (zlog_default,LOG_DEBUG, "Malformed router identifier: %s%s", id_str,
                     VTY_NEWLINE);
            return CMD_WARNING;
        }
        peer->remote_id = id;
    } else
    {
        peer->remote_id.s_addr = 0;
    }

    return CMD_SUCCESS;
}

/* neighbor passive. */
DEFUN (neighbor_passive,
       neighbor_passive_cmd,
       NEIGHBOR_CMD "passive",
       NEIGHBOR_STR
       NEIGHBOR_ADDR_STR
       "Dont send open messages to this neighbor\n")
{
    return peer_change_flag_with_reset (vty, argv[0], AFI_IP,
                                        PEER_FLAG_PASSIVE, 1);
}

DEFUN (no_neighbor_passive,
       no_neighbor_passive_cmd,
       NO_NEIGHBOR_CMD "passive",
       NO_STR
       NEIGHBOR_STR
       NEIGHBOR_ADDR_STR
       "Dont send open messages to this neighbor\n")
{
    return peer_change_flag_with_reset (vty, argv[0], AFI_IP,
                                        PEER_FLAG_PASSIVE, 0);
}


/* neighbor shutdown. */
DEFUN (neighbor_shutdown,
       neighbor_shutdown_cmd,
       NEIGHBOR_CMD "shutdown",
       NEIGHBOR_STR
       NEIGHBOR_ADDR_STR
       "Administratively shut down this neighbor\n")
{
    return peer_change_flag_with_reset (vty, argv[0], AFI_IP,
                                        PEER_FLAG_SHUTDOWN, 1);
}

DEFUN (no_neighbor_shutdown,
       no_neighbor_shutdown_cmd,
       NO_NEIGHBOR_CMD "shutdown",
       NO_STRl
       NEIGHBOR_STR
       NEIGHBOR_ADDR_STR
       "Administratively shut down this neighbor\n")
{
    return peer_change_flag_with_reset (vty, argv[0], AFI_IP,
                                        PEER_FLAG_SHUTDOWN, 0);
}


/* neighbor ebgp-multihop. */
int
Bgp::peer_ebgp_multihop_set (struct vty *vty, char *ip_str, char *ttl_str, int afi)
{
    struct peer *peer;
    struct peer_conf *conf;
    int ttl = TTL_MAX;

    conf = peer_conf_lookup_vty (vty, ip_str, afi);
    if (! conf)
        return CMD_WARNING;

    if (ttl_str)
        ttl = atoi (ttl_str);

    if (ttl == 0)
    {
        vty_out (zlog_default,LOG_DEBUG, "TTL value error: %s%s", ttl_str, VTY_NEWLINE);
        return CMD_WARNING;
    }

    peer = conf->peer;
    if (peer_sort (peer) == BGP_PEER_IBGP)
    {
        vty_out (zlog_default,LOG_DEBUG, "peer is IBGP peer%s", VTY_NEWLINE);
        return CMD_WARNING;
    }

    peer->ttl = ttl;

    /* Set runnning connection's ttl. */
    //    if (peer->fd >= 0)
    //sockopt_ttl (peer->su.sa.sa_family, peer->fd, peer->ttl);

    return CMD_SUCCESS;
}

int
Bgp::peer_ebgp_multihop_unset (struct vty *vty, char *ip_str, char *ttl_str,
                               int afi)
{
    struct peer *peer;
    struct peer_conf *conf;
    int ttl = TTL_MAX;

    conf = peer_conf_lookup_vty (vty, ip_str, afi);
    if (! conf)
        return CMD_WARNING;

    if (ttl_str)
        ttl = atoi (ttl_str);

    if (ttl == 0)
    {
        vty_out (zlog_default,LOG_DEBUG, "TTL value error: %s%s", ttl_str, VTY_NEWLINE);
        return CMD_WARNING;
    }

    peer = conf->peer;
    if (peer_sort (peer) == BGP_PEER_IBGP)
    {
        vty_out (zlog_default,LOG_DEBUG, "peer is IBGP peer%s", VTY_NEWLINE);
        return CMD_WARNING;
    }

    /* Set default EBGP TTL. */
    peer->ttl = 1;

    /* Set runnning connection's ttl. */
    //if (peer->fd >= 0)
    //sockopt_ttl (peer->su.sa.sa_family, peer->fd, peer->ttl);

    return CMD_SUCCESS;
}

/* neighbor ebgp-multihop. */
DEFUN (neighbor_ebgp_multihop,
       neighbor_ebgp_multihop_cmd,
       NEIGHBOR_CMD "ebgp-multihop",
       NEIGHBOR_STR
       NEIGHBOR_ADDR_STR
       "Allow EBGP neighbors not on directly connected networks\n")
{
    return peer_ebgp_multihop_set (vty, argv[0], NULL, AFI_IP);
}

DEFUN (neighbor_ebgp_multihop_ttl,
       neighbor_ebgp_multihop_ttl_cmd,
       NEIGHBOR_CMD "ebgp-multihop <1-255>",
       NEIGHBOR_STR
       NEIGHBOR_ADDR_STR
       "Allow EBGP neighbors not on directly connected networks\n"
       "maximum hop count\n")
{
    return peer_ebgp_multihop_set (vty, argv[0], argv[1], AFI_IP);
}

DEFUN (no_neighbor_ebgp_multihop,
       no_neighbor_ebgp_multihop_cmd,
       NO_NEIGHBOR_CMD "ebgp-multihop",
       NO_STR
       NEIGHBOR_STR
       NEIGHBOR_ADDR_STR
       "Allow EBGP neighbors not on directly connected networks\n")
{
    return peer_ebgp_multihop_unset (vty, argv[0], NULL, AFI_IP);
}

DEFUN (no_neighbor_ebgp_multihop_ttl,
       no_neighbor_ebgp_multihop_ttl_cmd,
       NO_NEIGHBOR_CMD "ebgp-multihop <1-255>",
       NO_STR
       NEIGHBOR_STR
       NEIGHBOR_ADDR_STR
       "Allow EBGP neighbors not on directly connected networks\n"
       "maximum hop count\n")
{
    return peer_ebgp_multihop_unset (vty, argv[0], argv[1], AFI_IP);
}

/* neighbor description. */
int
Bgp::peer_description_set (struct vty *vty, char *ip_str, int afi, char *str)
{
    struct peer *peer;
    struct peer_conf *conf;

    conf = peer_conf_lookup_vty (vty, ip_str, afi);
    if (! conf)
        return CMD_WARNING;
    peer = conf->peer;

    if (peer->desc)
        XFREE (MTYPE_TMP, peer->desc);
    peer->desc = str;
    return CMD_SUCCESS;
}

int
Bgp::peer_description_unset (struct vty *vty, char *ip_str, int afi)
{
    struct peer *peer;
    struct peer_conf *conf;

    conf = peer_conf_lookup_vty (vty, ip_str, afi);
    if (! conf)
        return CMD_WARNING;
    peer = conf->peer;

    if (peer->desc)
        XFREE (MTYPE_TMP, peer->desc);
    peer->desc = NULL;
    return CMD_SUCCESS;
}

DEFUN (neighbor_description,
       neighbor_description_cmd,
       NEIGHBOR_CMD "description .LINE",
       NEIGHBOR_STR
       NEIGHBOR_ADDR_STR
       "Neighbor specific description\n"
       "Up to 80 characters describing this neighbor\n")
{
    int i;
    struct buffer *b;
    char *str;

    if (argc == 1)
        return CMD_SUCCESS;

    /* Make string from buffer.  This function should be provided by
       buffer.c. */
    b = buffer_new (1024);
    for (i = 1; i < argc; i++)
    {
        buffer_putstr (b, (u_char *)argv[i]);
        buffer_putc (b, ' ');
    }
    buffer_putc (b, '\0');
    str = buffer_getstr (b);
    buffer_free (b);

    return peer_description_set (vty, argv[0], AFI_IP, str);
}

DEFUN (no_neighbor_description,
       no_neighbor_description_cmd,
       NO_NEIGHBOR_CMD "description",
       NO_STR
       NEIGHBOR_STR
       NEIGHBOR_ADDR_STR
       "Neighbor specific description\n")
{
    return peer_description_unset (vty, argv[0], AFI_IP);
}

/* neighbor next-hop-self. */
DEFUN (neighbor_nexthop_self,
       neighbor_nexthop_self_cmd,
       NEIGHBOR_CMD "next-hop-self",
       NEIGHBOR_STR
       NEIGHBOR_ADDR_STR
       "Disable the next hop calculation for this neighbor\n")
{
    return peer_change_af_flag (vty, argv[0], bgp_node_afi (vty),
                                bgp_node_safi (vty), PEER_FLAG_NEXTHOP_SELF,
                                flag_change_set);
}

DEFUN (no_neighbor_nexthop_self,
       no_neighbor_nexthop_self_cmd,
       NO_NEIGHBOR_CMD "next-hop-self",
       NO_STR
       NEIGHBOR_STR
       NEIGHBOR_ADDR_STR
       "Disable the next hop calculation for this neighbor\n")
{
    return peer_change_af_flag (vty, argv[0], bgp_node_afi (vty),
                                bgp_node_safi (vty), PEER_FLAG_NEXTHOP_SELF,
                                flag_change_unset);
}

/* neighbor send-community. */
DEFUN (neighbor_send_community,
       neighbor_send_community_cmd,
       NEIGHBOR_CMD "send-community",
       NEIGHBOR_STR
       NEIGHBOR_ADDR_STR
       "Send Community attribute to this neighbor (default enable)\n")
{
    return peer_change_af_flag (vty, argv[0], bgp_node_afi (vty), bgp_node_safi (vty),
                                PEER_FLAG_SEND_COMMUNITY, flag_change_set);
}

DEFUN (no_neighbor_send_community,
       no_neighbor_send_community_cmd,
       NO_NEIGHBOR_CMD "send-community",
       NO_STR
       NEIGHBOR_STR
       NEIGHBOR_ADDR_STR
       "Send Community attribute to this neighbor (default enable)\n")
{
    return peer_change_af_flag (vty, argv[0], bgp_node_afi (vty), bgp_node_safi (vty),
                                PEER_FLAG_SEND_COMMUNITY, flag_change_unset);
}

/* neighbor send-community extended. */
DEFUN (neighbor_send_community_type,
       neighbor_send_community_type_cmd,
       NEIGHBOR_CMD "send-community (both|extended|standard)",
       NEIGHBOR_STR
       NEIGHBOR_ADDR_STR
       "Send Community attribute to this neighbor (default enable)\n"
       "Send Standard and Extended Community attributes\n"
       "Send Extended Community attributes\n"
       "Send Standard Community attributes\n")
{
    int ret;

    if (strncmp (argv[1], "s", 1) == 0)
        return peer_change_af_flag (vty, argv[0], bgp_node_afi (vty), bgp_node_safi (vty),
                                    PEER_FLAG_SEND_COMMUNITY, flag_change_set);
    if (strncmp (argv[1], "e", 1) == 0)
        return peer_change_af_flag (vty, argv[0], bgp_node_afi (vty), bgp_node_safi (vty),
                                    PEER_FLAG_SEND_EXT_COMMUNITY, flag_change_set);

    ret = peer_change_af_flag (vty, argv[0], bgp_node_afi (vty), bgp_node_safi (vty),
                               PEER_FLAG_SEND_COMMUNITY, flag_change_set);
    if (ret == CMD_WARNING)
        return CMD_WARNING;
    ret = peer_change_af_flag (vty, argv[0], bgp_node_afi (vty), bgp_node_safi (vty),
                               PEER_FLAG_SEND_EXT_COMMUNITY, flag_change_set);
    if (ret == CMD_WARNING)
        return CMD_WARNING;

    return CMD_SUCCESS;
}

DEFUN (no_neighbor_send_community_type,
       no_neighbor_send_community_type_cmd,
       NO_NEIGHBOR_CMD "send-community (both|extended|standard)",
       NO_STR
       NEIGHBOR_STR
       NEIGHBOR_ADDR_STR
       "Send Community attribute to this neighbor (default enable)\n"
       "Send Standard and Extended Community attributes\n"
       "Send Extended Community attributes\n"
       "Send Standard Community attributes\n")
{
    int ret;

    if (strncmp (argv[1], "s", 1) == 0)
        return peer_change_af_flag (vty, argv[0], bgp_node_afi (vty), bgp_node_safi (vty),
                                    PEER_FLAG_SEND_COMMUNITY, flag_change_unset);
    if (strncmp (argv[1], "e", 1) == 0)
        return peer_change_af_flag (vty, argv[0], bgp_node_afi (vty), bgp_node_safi (vty),
                                    PEER_FLAG_SEND_EXT_COMMUNITY, flag_change_unset);

    ret = peer_change_af_flag (vty, argv[0], bgp_node_afi (vty), bgp_node_safi (vty),
                               PEER_FLAG_SEND_COMMUNITY, flag_change_unset);
    if (ret == CMD_WARNING)
        return CMD_WARNING;
    ret = peer_change_af_flag (vty, argv[0], bgp_node_afi (vty), bgp_node_safi (vty),
                               PEER_FLAG_SEND_EXT_COMMUNITY, flag_change_unset);
    if (ret == CMD_WARNING)
        return CMD_WARNING;

    return CMD_SUCCESS;
}

/* neighbor weight. */
int
Bgp::peer_weight_set (struct vty *vty, char *ip_str, int afi, char *weight_str)
{
    struct peer *peer;
    struct peer_conf *conf;
    unsigned long weight;
    char *endptr = NULL;

    conf = peer_conf_lookup_vty (vty, ip_str, afi);
    if (! conf)
        return CMD_WARNING;
    peer = conf->peer;

    weight = strtoul (weight_str, &endptr, 10);
    if (weight == ULONG_MAX || *endptr != '\0')
    {
        vty_out (zlog_default,LOG_DEBUG, "weight value error%s", VTY_NEWLINE);
        return CMD_WARNING;
    }
    if (weight > 65535)
    {
        vty_out (zlog_default,LOG_DEBUG, "weight value error%s", VTY_NEWLINE);
        return CMD_WARNING;
    }

    /* Set weight flag to peer configure. */
    peer->weight = weight;

    return CMD_SUCCESS;
}

int
Bgp::peer_weight_unset (struct vty *vty, char *ip_str, int afi)
{
    struct peer *peer;
    struct peer_conf *conf;

    conf = peer_conf_lookup_vty (vty, ip_str, afi);
    if (! conf)
        return CMD_WARNING;
    peer = conf->peer;
    peer->weight = 0;

    return CMD_SUCCESS;
}

DEFUN (neighbor_weight,
       neighbor_weight_cmd,
       NEIGHBOR_CMD "weight <0-65535>",
       NEIGHBOR_STR
       NEIGHBOR_ADDR_STR
       "Set default weight for routes from this neighbor\n"
       "default weight\n")
{
    return peer_weight_set (vty, argv[0], AFI_IP, argv[1]);
}

DEFUN (no_neighbor_weight,
       no_neighbor_weight_cmd,
       NO_NEIGHBOR_CMD "weight",
       NO_STR
       NEIGHBOR_STR
       NEIGHBOR_ADDR_STR
       "Set default weight for routes from this neighbor\n")
{
    return peer_weight_unset (vty, argv[0], AFI_IP);
}


/* neighbor soft-reconfig. */
DEFUN (neighbor_soft_reconfiguration,
       neighbor_soft_reconfiguration_cmd,
       NEIGHBOR_CMD "soft-reconfiguration inbound",
       NEIGHBOR_STR
       NEIGHBOR_ADDR_STR
       "Per neighbor soft reconfiguration\n"
       "Allow inbound soft reconfiguration for this neighbor\n")
{
    int ret;
    struct peer *peer;
    struct peer_conf *conf;

    conf = peer_conf_lookup_vty (vty, argv[0], bgp_node_afi (vty));
    if (! conf)
        return CMD_WARNING;

    peer = conf->peer;

    ret = peer_change_af_flag (vty, argv[0], bgp_node_afi (vty), bgp_node_safi (vty),
                               PEER_FLAG_SOFT_RECONFIG, flag_change_set);

    if (ret == CMD_SUCCESS)
    {
        if (peer->status == Established
            && (peer->refresh_nego_old || peer->refresh_nego_new))
            bgp_route_refresh_send (peer, bgp_node_afi (vty), bgp_node_safi (vty));
        else
            BGP_EVENT_ADD (peer, BGP_Stop);
    }

    return CMD_SUCCESS;
}

DEFUN (no_neighbor_soft_reconfiguration,
       no_neighbor_soft_reconfiguration_cmd,
       NO_NEIGHBOR_CMD "soft-reconfiguration inbound",
       NO_STR
       NEIGHBOR_STR
       NEIGHBOR_ADDR_STR
       "Per neighbor soft reconfiguration\n"
       "Allow inbound soft reconfiguration for this neighbor\n")
{
    int ret;
    struct peer *peer;
    struct peer_conf *conf;

    conf = peer_conf_lookup_vty (vty, argv[0], bgp_node_afi (vty));
    if (! conf)
        return CMD_WARNING;

    peer = conf->peer;

    ret = peer_change_af_flag (vty, argv[0], bgp_node_afi (vty), bgp_node_safi (vty),
                               PEER_FLAG_SOFT_RECONFIG, flag_change_unset);

#ifndef  HAVE_ZEBRA_93b
    if (ret == CMD_SUCCESS)
      bgp_adj_clear (peer->adj_in[bgp_node_afi (vty)][bgp_node_safi (vty)],
		     bgp_node_safi (vty));
#else 
    if (ret == CMD_SUCCESS)
      bgp_clear_adj_in(peer, bgp_node_afi (vty), bgp_node_safi (vty));
#endif

    return CMD_SUCCESS;
}


DEFUN (neighbor_route_reflector_client,
       neighbor_route_reflector_client_cmd,
       NEIGHBOR_CMD "route-reflector-client",
       NEIGHBOR_STR
       NEIGHBOR_ADDR_STR
       "Configure a neighbor as Route Reflector client\n")
{
    struct peer *peer;
    struct peer_conf *conf;

    conf = peer_conf_lookup_vty (vty, argv[0], bgp_node_afi (vty));
    if (! conf)
        return CMD_WARNING;

    peer = conf->peer;

    if (peer_sort (peer) != BGP_PEER_IBGP)
    {
        vty_out (zlog_default,LOG_DEBUG, "%% Invalid command. Not an internal neighbor%s",
                 VTY_NEWLINE);
        return CMD_WARNING;
    }

    return peer_change_af_flag (vty, argv[0], bgp_node_afi (vty), bgp_node_safi (vty),
                                PEER_FLAG_REFLECTOR_CLIENT, flag_change_set_reset);
}

DEFUN (no_neighbor_route_reflector_client,
       no_neighbor_route_reflector_client_cmd,
       NO_NEIGHBOR_CMD "route-reflector-client",
       NO_STR
       NEIGHBOR_STR
       NEIGHBOR_ADDR_STR
       "Configure a neighbor as Route Reflector client\n")
{
    return peer_change_af_flag (vty, argv[0], bgp_node_afi (vty), bgp_node_safi (vty),
                                PEER_FLAG_REFLECTOR_CLIENT, flag_change_unset_reset);
}

/* neighbor route-server-client. */
DEFUN (neighbor_route_server_client,
       neighbor_route_server_client_cmd,
       NEIGHBOR_CMD "route-server-client",
       NEIGHBOR_STR
       NEIGHBOR_ADDR_STR
       "Configure a neighbor as Route Server client\n")
{
  struct peer *peer;
  struct peer_conf *conf;

  conf = peer_conf_lookup_vty (vty, argv[0], bgp_node_afi (vty)); 
  if (! conf)
    return CMD_WARNING;

  peer = conf->peer;

  if (peer_sort (peer) != BGP_PEER_EBGP)
    {
      vty_out (zlog_default,LOG_DEBUG, "%% Invalid command. Not an external neighbor%s",
                 VTY_NEWLINE);
      return CMD_WARNING;
    }

  return peer_change_af_flag (vty, argv[0], bgp_node_afi (vty), bgp_node_safi (vty),
			      PEER_FLAG_RSERVER_CLIENT, flag_change_set_reset);
}

DEFUN (no_neighbor_route_server_client,
       no_neighbor_route_server_client_cmd,
       NO_NEIGHBOR_CMD "route-server-client",
       NO_STR
       NEIGHBOR_STR
       NEIGHBOR_ADDR_STR
       "Configure a neighbor as Route Server client\n")
{
  return peer_change_af_flag (vty, argv[0], bgp_node_afi (vty), bgp_node_safi (vty),
			      PEER_FLAG_RSERVER_CLIENT, flag_change_unset_reset);
}

/* neighbor capability route-refresh. */
DEFUN (neighbor_capability_route_refresh,
       neighbor_capability_route_refresh_cmd,
       NEIGHBOR_CMD "capability route-refresh",
       NEIGHBOR_STR
       NEIGHBOR_ADDR_STR
       "Outbound capability configuration\n"
       "Advertise route-refresh capability to this neighbor\n")
{
    return peer_change_flag_with_reset (vty, argv[0], AFI_IP, 
                                        PEER_FLAG_CAPABILITY_ROUTE_REFRESH, 1);
}

DEFUN (no_neighbor_capability_route_refresh,
       no_neighbor_capability_route_refresh_cmd,
       NO_NEIGHBOR_CMD "capability route-refresh",
       NO_STR
       NEIGHBOR_STR
       NEIGHBOR_ADDR_STR
       "Outbound capability configuration\n"
       "Advertise route-refresh capability to this neighbor\n")
{
    return peer_change_flag_with_reset (vty, argv[0], AFI_IP,
                                        PEER_FLAG_CAPABILITY_ROUTE_REFRESH, 0);
}

/* neighbor transparent-as */
DEFUN (neighbor_transparent_as,
       neighbor_transparent_as_cmd,
       NEIGHBOR_CMD "transparent-as",
       NEIGHBOR_STR
       NEIGHBOR_ADDR_STR
       "Do not append my AS number even peer is EBGP peer\n")
{
    return peer_change_flag_with_reset (vty, argv[0], AFI_IP, 
                                        PEER_FLAG_TRANSPARENT_AS, 1);
}

DEFUN (no_neighbor_transparent_as,
       no_neighbor_transparent_as_cmd,
       NO_NEIGHBOR_CMD "transparent-as",
       NO_STR
       NEIGHBOR_STR
       NEIGHBOR_ADDR_STR
       "Do not append my AS number even peer is EBGP peer\n")
{
    return peer_change_flag_with_reset (vty, argv[0], AFI_IP,
                                        PEER_FLAG_TRANSPARENT_AS, 0);
}

/* neighbor transparent-nexthop */
DEFUN (neighbor_transparent_nexthop,
       neighbor_transparent_nexthop_cmd,
       NEIGHBOR_CMD "transparent-nexthop",
       NEIGHBOR_STR
       NEIGHBOR_ADDR_STR
       "Do not change nexthop even peer is EBGP peer\n")
{
    return peer_change_flag_with_reset (vty, argv[0], AFI_IP, 
                                        PEER_FLAG_TRANSPARENT_NEXTHOP, 1);
}

DEFUN (no_neighbor_transparent_nexthop,
       no_neighbor_transparent_nexthop_cmd,
       NO_NEIGHBOR_CMD "transparent-nexthop",
       NO_STR
       NEIGHBOR_STR
       NEIGHBOR_ADDR_STR
       "Do not change nexthop even peer is EBGP peer\n")
{
    return peer_change_flag_with_reset (vty, argv[0], AFI_IP,
                                        PEER_FLAG_TRANSPARENT_NEXTHOP, 0);
}

/* neighbor dont-capability-negotiate */
DEFUN (neighbor_dont_capability_negotiate,
       neighbor_dont_capability_negotiate_cmd,
       NEIGHBOR_CMD "dont-capability-negotiate",
       NEIGHBOR_STR
       NEIGHBOR_ADDR_STR
       "Do not perform capability negotiation\n")
{
    return peer_change_flag (vty, argv[0], AFI_IP,
                             PEER_FLAG_DONT_CAPABILITY, 1);
}

DEFUN (no_neighbor_dont_capability_negotiate,
       no_neighbor_dont_capability_negotiate_cmd,
       NO_NEIGHBOR_CMD "dont-capability-negotiate",
       NO_STR
       NEIGHBOR_STR
       NEIGHBOR_ADDR_STR
       "Do not perform capability negotiation\n")
{
    return peer_change_flag (vty, argv[0], AFI_IP,
                             PEER_FLAG_DONT_CAPABILITY, 0);
}

/* Override capability negotiation. */
int
Bgp::peer_override_capability (struct vty *vty, char *ip_str, int afi, int set)
{
    struct peer *peer;
    struct peer_conf *conf;

    conf = peer_conf_lookup_vty (vty, ip_str, afi);
    if (! conf)
        return CMD_WARNING;
    peer = conf->peer;

    if (set)
    {
        if (CHECK_FLAG (peer->flags, PEER_FLAG_STRICT_CAP_MATCH))
        {
            vty_out (zlog_default,LOG_DEBUG, "Cant set override-capability and strict-capability-match at the same time%s", VTY_NEWLINE);
            return CMD_WARNING;
        }
        SET_FLAG (peer->flags, PEER_FLAG_OVERRIDE_CAPABILITY);
    } else
        UNSET_FLAG (peer->flags, PEER_FLAG_OVERRIDE_CAPABILITY);
    return CMD_SUCCESS;
}

/* Override capability negotiation. */
DEFUN (neighbor_override_capability,
       neighbor_override_capability_cmd,
       NEIGHBOR_CMD "override-capability",
       NEIGHBOR_STR
       NEIGHBOR_ADDR_STR
       "Override capability negotiation result\n")
{
    return peer_override_capability (vty, argv[0], AFI_IP, 1);
}

DEFUN (no_neighbor_override_capability,
       no_neighbor_override_capability_cmd,
       NO_NEIGHBOR_CMD "override-capability",
       NO_STR
       NEIGHBOR_STR
       NEIGHBOR_ADDR_STR
       "Override capability negotiation result\n")
{
    return peer_override_capability (vty, argv[0], AFI_IP, 0);
}

/* Strict capability match. */
int
Bgp::peer_strict_capability (struct vty *vty, char *ip_str, int afi, int set)
{
    struct peer *peer;
    struct peer_conf *conf;

    conf = peer_conf_lookup_vty (vty, ip_str, afi);
    if (! conf)
        return CMD_WARNING;
    peer = conf->peer;

    if (set)
    {
        if (CHECK_FLAG (peer->flags, PEER_FLAG_OVERRIDE_CAPABILITY))
        {
            vty_out (zlog_default,LOG_DEBUG, "Cant set override-capability and strict-capability-match at the same time%s", VTY_NEWLINE);
            return CMD_WARNING;
        }
        SET_FLAG (peer->flags, PEER_FLAG_STRICT_CAP_MATCH);
    } else
        UNSET_FLAG (peer->flags, PEER_FLAG_STRICT_CAP_MATCH);
    return CMD_SUCCESS;
}

DEFUN (neighbor_strict_capability,
       neighbor_strict_capability_cmd,
       NEIGHBOR_CMD "strict-capability-match",
       NEIGHBOR_STR
       NEIGHBOR_ADDR_STR
       "Strict capability negotiation match\n")
{
    return peer_strict_capability (vty, argv[0], AFI_IP, 1);
}

DEFUN (no_neighbor_strict_capability,
       no_neighbor_strict_capability_cmd,
       NO_NEIGHBOR_CMD "strict-capability-match",
       NO_STR
       NEIGHBOR_STR
       NEIGHBOR_ADDR_STR
       "Strict capability negotiation match\n")
{
    return peer_strict_capability (vty, argv[0], AFI_IP, 0);
}

int
Bgp::peer_timers_set (struct vty *vty, char *ip_str, int afi,
                      char *keep_str, char *hold_str)
{
    struct peer *peer;
    struct peer_conf *conf;
    unsigned long keepalive;
    unsigned long holdtime;
    char *endptr = NULL;

    conf = peer_conf_lookup_vty (vty, ip_str, afi);
    if (! conf)
        return CMD_WARNING;

    peer = conf->peer;

    /* keepalive value check. */
    keepalive = strtoul (keep_str, &endptr, 10);

    if (keepalive == ULONG_MAX || *endptr != '\0')
    {
        vty_out (zlog_default,LOG_DEBUG, "%% keepalive time value must be positive integer%s",
                 VTY_NEWLINE);
        return CMD_WARNING;
    }
    if (keepalive > 65535)
    {
        vty_out (zlog_default,LOG_DEBUG, "%% keepalive time value must be <0-65535>%s", VTY_NEWLINE);
        return CMD_WARNING;
    }

    /* Holdtime value check. */
    holdtime = strtoul (hold_str, &endptr, 10);

    if (holdtime == ULONG_MAX || *endptr != '\0')
    {
        vty_out (zlog_default,LOG_DEBUG, "%% hold time value must be positive integer%s", VTY_NEWLINE);
        return CMD_WARNING;
    }
    if (holdtime > 65535)
    {
        vty_out (zlog_default,LOG_DEBUG, "%% hold time value must be <0,3-65535>%s", VTY_NEWLINE);
        return CMD_WARNING;
    }
    if (holdtime < 3 && holdtime != 0)
    {
        vty_out (zlog_default,LOG_DEBUG, "%% hold time value must be either 0 or greater than 3%s",
                 VTY_NEWLINE);
        return CMD_WARNING;
    }

    /* Set value to the configuration. */
    peer->config |= PEER_CONFIG_TIMER;
    peer->holdtime = holdtime;
    peer->keepalive = (keepalive < holdtime / 3 ? keepalive : holdtime / 3);

    return CMD_SUCCESS;
}

int
Bgp::peer_timers_unset (struct vty *vty, char *ip_str, int afi)
{
    struct peer *peer;
    struct peer_conf *conf;

    conf = peer_conf_lookup_vty (vty, ip_str, afi);
    if (! conf)
        return CMD_WARNING;

    peer = conf->peer;

    /* Clear configuration. */
    peer->config &= ~PEER_CONFIG_TIMER;
    peer->keepalive = 0;
    peer->holdtime = 0;

    return CMD_SUCCESS;
}

DEFUN (neighbor_timers,
       neighbor_timers_cmd,
       NEIGHBOR_CMD "timers <0-65535> <0-65535>",
       NEIGHBOR_STR
       NEIGHBOR_ADDR_STR
       "BGP per neighbor timers\n"
       "Keepalive interval\n"
       "Holdtime\n")
{
    return peer_timers_set (vty, argv[0], AFI_IP, argv[1], argv[2]);
}

DEFUN (no_neighbor_timers,
       no_neighbor_timers_cmd,
       NO_NEIGHBOR_CMD "timers",
       NO_STR
       NEIGHBOR_STR
       NEIGHBOR_ADDR_STR
       "BGP per neighbor timers\n")
{
    return peer_timers_unset (vty, argv[0], AFI_IP);
}

int
Bgp::peer_timers_connect_set (struct vty *vty, char *ip_str, int afi,
                              char *time_str)
{
    struct peer *peer;
    struct peer_conf *conf;
    unsigned long connect;
    char *endptr = NULL;

    conf = peer_conf_lookup_vty (vty, ip_str, afi);
    if (! conf)
        return CMD_WARNING;

    peer = conf->peer;

    /* Hold time value check. */
    connect = strtoul (time_str, &endptr, 10);

    if (connect == ULONG_MAX || *endptr != '\0')
    {
        vty_out (zlog_default,LOG_DEBUG, "connect time value must be positive integer%s",
                 VTY_NEWLINE);
        return CMD_WARNING;
    }
    if (connect > 65535)
    {
        vty_out (zlog_default,LOG_DEBUG, "connect time value must be <0-65535>%s", VTY_NEWLINE);
        return CMD_WARNING;
    }

    /* Set value to the configuration. */
    peer->config |= PEER_CONFIG_CONNECT;
    peer->connect = connect;

    /* Set value to timer setting. */
    peer->v_connect = connect;

    return CMD_SUCCESS;
}

int
Bgp::peer_timers_connect_unset (struct vty *vty, char *ip_str, int afi)
{
    struct peer *peer;
    struct peer_conf *conf;

    conf = peer_conf_lookup_vty (vty, ip_str, afi);
    if (! conf)
        return CMD_WARNING;
    peer = conf->peer;

    /* Clear configuration. */
    UNSET_FLAG (peer->config, PEER_CONFIG_CONNECT);
    peer->connect = 0;

    /* Set timer setting to default value. */
    peer->v_connect = BGP_DEFAULT_CONNECT_RETRY;

    return CMD_SUCCESS;
}

DEFUN (neighbor_timers_connect,
       neighbor_timers_connect_cmd,
       NEIGHBOR_CMD "timers connect <0-65535>",
       NEIGHBOR_STR
       NEIGHBOR_ADDR_STR
       "BGP per neighbor timers\n"
       "BGP connect timer\n"
       "Connect timer\n")
{
    return peer_timers_connect_set (vty, argv[0], AFI_IP, argv[1]);
}

DEFUN (no_neighbor_timers_connect,
       no_neighbor_timers_connect_cmd,
       NO_NEIGHBOR_CMD "timers connect [TIMER]",
       NO_STR
       NEIGHBOR_STR
       NEIGHBOR_ADDR_STR
       "BGP per neighbor timers\n"
       "BGP connect timer\n"
       "Connect timer\n")
{
    return peer_timers_connect_unset (vty, argv[0], AFI_IP);
}

int
Bgp::peer_version (struct vty *vty, char *ip_str, int afi, char *str)
{
    struct peer *peer;
    struct peer_conf *conf;

    conf = peer_conf_lookup_vty (vty, ip_str, afi);
    if (! conf)
        return CMD_WARNING;
    peer = conf->peer;

    /* BGP version string check. */
    if (str)
    {
        if (strcmp (str, "4") == 0)
            peer->version = BGP_VERSION_4;
        else if (strcmp (str, "4-") == 0)
            peer->version = BGP_VERSION_MP_4_DRAFT_00;
        else
            vty_out (zlog_default,LOG_DEBUG, "BGP version malformed!%s", VTY_NEWLINE);
    } else
        peer->version = BGP_VERSION_4;

    return CMD_SUCCESS;
}

DEFUN (neighbor_version,
       neighbor_version_cmd,
       NEIGHBOR_CMD "version (4|4-)",
       NEIGHBOR_STR
       NEIGHBOR_ADDR_STR
       "Neighbors BGP version\n"
       "Border Gateway Protocol 4\n"
       "Multiprotocol Extensions for BGP-4(Old Draft)\n")
{
    return peer_version (vty, argv[0], AFI_IP, argv[1]);
}

DEFUN (no_neighbor_version,
       no_neighbor_version_cmd,
       NO_NEIGHBOR_CMD "version",
       NO_STR
       NEIGHBOR_STR
       NEIGHBOR_ADDR_STR
       "Neighbors BGP version\n")
{
    return peer_version (vty, argv[0], AFI_IP, NULL);
}

/* Update distribute list. */
void
Bgp::bgp_distribute_update (struct access_list *access)
{
    afi_t afi;
    safi_t safi;
    int direct;
    struct listnode *nn, *nm;
    struct bgp *bgp;
    struct peer_conf *conf;
    struct bgp_filter *filter;
    for (nn = bgp_list->head; nn; nn = nn->next)
        if ((bgp = ( struct bgp * ) nn->data) != NULL)
        {
            for (nm = bgp->peer_conf->head; nm; nm = nm->next)
                if ((conf = ( struct peer_conf * ) nm->data) != NULL)
                {
                    for (afi = AFI_IP; afi < AFI_MAX; afi++)
                        for (safi = SAFI_UNICAST; safi < SAFI_MAX; safi++)
                        {
                            filter = &conf->filter[afi][safi];

                            for (direct = FILTER_IN; direct < FILTER_MAX; direct++)
                            {
                                if (filter->dlist[direct].name)
                                    filter->dlist[direct].alist = 
                                    access_list_lookup (afi, filter->dlist[direct].name);
                                else
                                    filter->dlist[direct].alist = NULL;
                            }
                        }
                }
        }
}

/* Set prefix list to the peer. */
int
Bgp::bgp_prefix_list_set (struct vty *vty, char *ip_str, afi_t afi, safi_t safi,
                          char *name_str, char *direct_str)
{
    struct peer_conf *conf;
    int direct;
    struct bgp_filter *filter;

    conf = peer_conf_lookup_vty (vty, ip_str, afi);
    if (! conf)
        return CMD_WARNING;
    if (! conf->afc[afi][safi])
    {
        vty_out (zlog_default,LOG_DEBUG, "%% Activate the neighbor for the address family first%s",
                 VTY_NEWLINE);
        return CMD_WARNING;
    }

    /* Check filter direction. */
    if (strncmp (direct_str, "i", 1) == 0)
        direct = FILTER_IN;
    else if (strncmp (direct_str, "o", 1) == 0)
        direct = FILTER_OUT;
    else
    {
        vty_out (zlog_default,LOG_DEBUG, "vty, filter direction must be [in|out]%s", VTY_NEWLINE);
        return CMD_WARNING;
    }

    filter = &conf->filter[afi][safi];

    if (filter->plist[direct].name)
        free (filter->plist[direct].name);
    filter->plist[direct].name = strdup (name_str);
    filter->plist[direct].plist = prefix_list_lookup (afi, name_str);

    return CMD_SUCCESS;
}

int
Bgp::bgp_prefix_list_unset (struct vty *vty, char *ip_str, afi_t afi, safi_t safi,
                            char *name_str, char *direct_str)
{
    struct peer_conf *conf;
    int direct;
    struct bgp_filter *filter;

    conf = peer_conf_lookup_vty (vty, ip_str, afi);
    if (! conf)
        return CMD_WARNING;

    /* Check filter direction. */
    if (strncmp (direct_str, "i", 1) == 0)
        direct = FILTER_IN;
    else if (strncmp (direct_str, "o", 1) == 0)
        direct = FILTER_OUT;
    else
    {
        vty_out (zlog_default,LOG_DEBUG, "filter direction must be [in|out]%s", VTY_NEWLINE);
        return CMD_WARNING;
    }

    filter = &conf->filter[afi][safi];

    if (! filter->plist[direct].name)
    {
        vty_out (zlog_default,LOG_DEBUG, "There is no such filter: %s%s", name_str, VTY_NEWLINE);
        return CMD_WARNING;
    }
    if (strcmp (filter->plist[direct].name, name_str) != 0)
    {
        vty_out (zlog_default,LOG_DEBUG, "There is no such filter: %s%s", name_str, VTY_NEWLINE);
        return CMD_WARNING;
    }
    free (filter->plist[direct].name);
    filter->plist[direct].name = NULL;
    filter->plist[direct].plist = NULL;

    return CMD_SUCCESS;
}

/* Update prefix-list list. */
void
Bgp::bgp_prefix_list_update ()
{
    struct listnode *nn, *nm;
    struct bgp *bgp;
    struct peer_conf *conf;
    struct bgp_filter *filter;
    afi_t afi;
    safi_t safi;
    int direct;
    for (nn = bgp_list->head ; nn; nn = nn->next)
        if ((bgp = ( struct bgp * ) nn->data) != NULL)
        {
            for (nm = bgp->peer_conf->head; nm; nm = nm->next)
                if ((conf = ( struct peer_conf * ) nm->data) != NULL)
                {
                    for (afi = AFI_IP; afi < AFI_MAX; afi++)
                        for (safi = SAFI_UNICAST; safi < SAFI_MAX; safi++)
                        {
                            filter = &conf->filter[afi][safi];

                            for (direct = FILTER_IN; direct < FILTER_MAX; direct++)
                            {
                                if (filter->plist[direct].name)
                                    filter->plist[direct].plist = 
                                    prefix_list_lookup (afi, filter->plist[direct].name);
                                else
                                    filter->plist[direct].plist = NULL;
                            }
                        }
                }
        }
}

DEFUN (neighbor_prefix_list,
       neighbor_prefix_list_cmd,
       NEIGHBOR_CMD "prefix-list WORD (in|out)",
       NEIGHBOR_STR
       NEIGHBOR_ADDR_STR
       "Filter updates to/from this neighbor\n"
       "Name of a prefix list\n"
       "Filter incoming updates\n"
       "Filter outgoing updates\n")
{
    return bgp_prefix_list_set (vty, argv[0], AFI_IP, bgp_node_safi (vty),
                                argv[1], argv[2]);
}

DEFUN (no_neighbor_prefix_list,
       no_neighbor_prefix_list_cmd,
       NO_NEIGHBOR_CMD "prefix-list WORD (in|out)",
       NO_STR
       NEIGHBOR_STR
       NEIGHBOR_ADDR_STR
       "Filter updates to/from this neighbor\n"
       "Name of a prefix list\n"
       "Filter incoming updates\n"
       "Filter outgoing updates\n")
{
    return bgp_prefix_list_unset (vty, argv[0], AFI_IP, bgp_node_safi (vty),
                                  argv[1], argv[2]);
}



int
Bgp::bgp_aslist_set (struct vty *vty, char *ip_str, afi_t afi, safi_t safi,
                     char *name_str, char *direct_str)
{

    struct peer_conf *conf;
    int direct;
    struct bgp_filter *filter;

    conf = peer_conf_lookup_vty (vty, ip_str, afi);
    if (! conf)
        return CMD_WARNING;
    if (! conf->afc[afi][safi])
    {
        vty_out (zlog_default,LOG_DEBUG, "%% Activate the neighbor for the address family first%s",
                 VTY_NEWLINE);
        return CMD_WARNING;
    }

    /* Check filter direction. */
    if (strncmp (direct_str, "i", 1) == 0)
        direct = FILTER_IN;
    else if (strncmp (direct_str, "o", 1) == 0)
        direct = FILTER_OUT;
    else
    {
        vty_out (zlog_default,LOG_DEBUG, "filter direction must be [in|out]%s", VTY_NEWLINE);
        return CMD_WARNING;
    }

    filter = &conf->filter[afi][safi];

    if (filter->aslist[direct].name)
        free (filter->aslist[direct].name);

    filter->aslist[direct].name = strdup (name_str);
    filter->aslist[direct].aslist = as_list_lookup (name_str);

    return CMD_SUCCESS;
}

int
Bgp::bgp_aslist_unset (struct vty *vty, char *ip_str, afi_t afi, safi_t safi,
                       char *name_str, char *direct_str)
{
    struct peer_conf *conf;
    int direct;
    struct bgp_filter *filter;

    conf = peer_conf_lookup_vty (vty, ip_str, afi);
    if (! conf)
        return CMD_WARNING;
    if (! conf->afc[afi][safi])
    {
        vty_out (zlog_default,LOG_DEBUG, "%% Activate the neighbor for the address family first%s",
                 VTY_NEWLINE);
        return CMD_WARNING;
    }

    /* Check filter direction. */
    if (strncmp (direct_str, "i", 1) == 0)
        direct = FILTER_IN;
    else if (strncmp (direct_str, "o", 1) == 0)
        direct = FILTER_OUT;
    else
    {
        vty_out (zlog_default,LOG_DEBUG, "filter direction must be [in|out]%s", VTY_NEWLINE);
        return CMD_WARNING;
    }

    filter = &conf->filter[afi][safi];

    if (! filter->aslist[direct].name)
    {
        vty_out (zlog_default,LOG_DEBUG, "There is no such filter: %s%s", name_str, VTY_NEWLINE);
        return CMD_WARNING;
    }
    if (strcmp (filter->aslist[direct].name, name_str) != 0)
    {
        vty_out (zlog_default,LOG_DEBUG, "There is no such filter: %s%s", name_str, VTY_NEWLINE);
        return CMD_WARNING;
    }
    free (filter->aslist[direct].name);
    filter->aslist[direct].name = NULL;
    filter->aslist[direct].aslist = NULL;

    return CMD_SUCCESS;
}

void
Bgp::bgp_aslist_update ()
{
    afi_t afi;
    safi_t safi;
    int direct;
    struct listnode *nn, *nm;
    struct bgp *bgp;
    struct peer_conf *conf;
    struct bgp_filter *filter;
    for (nn = bgp_list->head; nn; nn = nn->next)
        if ((bgp = ( struct bgp * ) nn->data) != NULL)
        {
            for (nm = bgp->peer_conf->head; nm; nm = nm->next)
                if ((conf = ( struct peer_conf * ) nm->data) != NULL)
                {
                    for (afi = AFI_IP; afi < AFI_MAX; afi++)
                        for (safi = SAFI_UNICAST; safi < SAFI_MAX; safi++)
                        {
                            filter = &conf->filter[afi][safi];

                            for (direct = FILTER_IN; direct < FILTER_MAX; direct++)
                            {
                                if (filter->aslist[direct].name)
                                    filter->aslist[direct].aslist = 
                                    as_list_lookup (filter->aslist[direct].name);
                                else
                                    filter->aslist[direct].aslist = NULL;
                            }
                        }
                }
        }
}

DEFUN (neighbor_filter_list,
       neighbor_filter_list_cmd,
       NEIGHBOR_CMD "filter-list WORD (in|out)",
       NEIGHBOR_STR
       NEIGHBOR_ADDR_STR
       "Establish BGP filters\n"
       "AS path access-list name\n"
       "Filter incoming routes\n"
       "Filter outgoing routes\n")
{
    return bgp_aslist_set (vty, argv[0], AFI_IP, bgp_node_safi (vty),
                           argv[1], argv[2]);
}

DEFUN (no_neighbor_filter_list,
       no_neighbor_filter_list_cmd,
       NO_NEIGHBOR_CMD "filter-list WORD (in|out)",
       NO_STR
       NEIGHBOR_STR
       NEIGHBOR_ADDR_STR
       "Establish BGP filters\n"
       "AS path access-list name\n"
       "Filter incoming routes\n"
       "Filter outgoing routes\n")
{
    return bgp_aslist_unset (vty, argv[0], AFI_IP, bgp_node_safi (vty),
                             argv[1], argv[2]);
}


/* Set route-map to the peer. */
int
Bgp::bgp_route_map_set (struct vty *vty, char *ip_str, afi_t afi, safi_t safi,
                        char *name_str, char *direct_str)
{
    struct peer_conf *conf;
    int direct;
    struct bgp_filter *filter;

    conf = peer_conf_lookup_vty (vty, ip_str, afi);
    if (! conf)
        return CMD_WARNING;
    if (! conf->afc[afi][safi])
    {
        vty_out (zlog_default,LOG_DEBUG, "%% Activate the neighbor for the address family first%s",
                 VTY_NEWLINE);
        return CMD_WARNING;
    }

    /* Check filter direction. */
    if (strncmp (direct_str, "i", 1) == 0)
        direct = FILTER_IN;
    else if (strncmp (direct_str, "o", 1) == 0)
        direct = FILTER_OUT;
    else
    {
        vty_out (zlog_default,LOG_DEBUG, "filter direction must be [in|out]%s", VTY_NEWLINE);
        return CMD_WARNING;
    }

    filter = &conf->filter[afi][safi];

    if (filter->map[direct].name)
        free (filter->map[direct].name);

    filter->map[direct].name = strdup (name_str);
    filter->map[direct].map = route_map_lookup_by_name (name_str);

    return CMD_SUCCESS;
}

/* Unset route-map from the peer. */
int
Bgp::bgp_route_map_unset (struct vty *vty, char *ip_str, afi_t afi, safi_t safi,
                          char *name_str, char *direct_str)
{
    struct peer_conf *conf;
    int direct;
    struct bgp_filter *filter;

    conf = peer_conf_lookup_vty (vty, ip_str, afi);
    if (! conf)
        return CMD_WARNING;
    if (! conf->afc[afi][safi])
    {
        vty_out (zlog_default,LOG_DEBUG, "%% Activate the neighbor for the address family first%s",
                 VTY_NEWLINE);
        return CMD_WARNING;
    }

    /* Check filter direction. */
    if (strncmp (direct_str, "i", 1) == 0)
        direct = FILTER_IN;
    else if (strncmp (direct_str, "o", 1) == 0)
        direct = FILTER_OUT;
    else
    {
        vty_out (zlog_default,LOG_DEBUG, "filter direction must be [in|out]%s", VTY_NEWLINE);
        return CMD_WARNING;
    }

    filter = &conf->filter[afi][safi];

    if (! filter->map[direct].name)
    {
        vty_out (zlog_default,LOG_DEBUG, "There is no such filter: %s%s", name_str, VTY_NEWLINE);
        return CMD_WARNING;
    }
    if (strcmp (filter->map[direct].name, name_str) != 0)
    {
        vty_out (zlog_default,LOG_DEBUG, "There is no such filter: %s%s", name_str, VTY_NEWLINE);
        return CMD_WARNING;
    }

    free (filter->map[direct].name);
    filter->map[direct].name = NULL;
    filter->map[direct].map = NULL;

    return CMD_SUCCESS;
}

DEFUN (neighbor_route_map,
       neighbor_route_map_cmd,
       NEIGHBOR_CMD "route-map WORD (in|out)",
       NEIGHBOR_STR
       NEIGHBOR_ADDR_STR
       "Apply route map to neighbor\n"
       "Name of route map\n"
       "Apply map to incoming routes\n"
       "Apply map to outbound routes\n")
{
    return bgp_route_map_set (vty, argv[0], AFI_IP, bgp_node_safi (vty),
                              argv[1], argv[2]);
}

DEFUN (no_neighbor_route_map,
       no_neighbor_route_map_cmd,
       NO_NEIGHBOR_CMD "route-map WORD (in|out)",
       NO_STR
       NEIGHBOR_STR
       NEIGHBOR_ADDR_STR
       "Apply route map to neighbor\n"
       "Name of route map\n"
       "Apply map to incoming routes\n"
       "Apply map to outbound routes\n")
{
    return bgp_route_map_unset (vty, argv[0], AFI_IP, bgp_node_safi (vty),
                                argv[1], argv[2]);
}

int
Bgp::bgp_maximum_prefix_set (struct vty *vty, char *ip_str, afi_t afi, safi_t safi,
                             char *num_str, int warning)
{
    struct peer_conf *conf;
    unsigned long num;
    char *endptr = NULL;

    /* Lookup peer configuration. */
    conf = peer_conf_lookup_vty (vty, ip_str, afi);
    if (! conf)
        return CMD_WARNING;
    if (! conf->afc[afi][safi])
    {
        vty_out (zlog_default,LOG_DEBUG, "%% Activate the neighbor for the address family first%s",
                 VTY_NEWLINE);
        return CMD_WARNING;
    }

    /* Convert string to unsigned long. */
    num = strtoul (num_str, &endptr, 10);
    if (num == ULONG_MAX || *endptr != '\0')
    {
        vty_out (zlog_default,LOG_DEBUG, "%% maximum-prefix count must be positive integer%s",
                 VTY_NEWLINE);
        return CMD_WARNING;
    }

    /* Set maximum prefix value. */
    conf->pmax[afi][safi] = num;
    conf->pmax_warning[afi][safi] = (warning ? 1 : 0);

    return CMD_SUCCESS;
}

int
Bgp::bgp_maximum_prefix_unset (struct vty *vty, char *ip_str,
                               afi_t afi, safi_t safi)
{
    struct peer_conf *conf;

    /* Lookup peer configuration. */
    conf = peer_conf_lookup_vty (vty, ip_str, afi);
    if (! conf)
        return CMD_WARNING;
    if (! conf->afc[afi][safi])
    {
        vty_out (zlog_default,LOG_DEBUG, "%% Activate the neighbor for the address family first%s",
                 VTY_NEWLINE);
        return CMD_WARNING;
    }

    conf->pmax[afi][safi] = 0;
    conf->pmax_warning[afi][safi] =  0;

    return CMD_SUCCESS;
}

/* Maximum number of prefix configuration.  prefix count is different
   for each peer configuration.  So this configuration can be set for
   each peer configuration. */
DEFUN (neighbor_maximum_prefix,
       neighbor_maximum_prefix_cmd,
       NEIGHBOR_CMD "maximum-prefix <1-4294967295>",
       NEIGHBOR_STR
       NEIGHBOR_ADDR_STR
       "Maximum number of prefix accept from this peer\n"
       "maximum no. of prefix limit\n")
{
    return bgp_maximum_prefix_set (vty, argv[0], bgp_node_afi (vty),
                                   bgp_node_safi (vty), argv[1], 0);
}

DEFUN (no_neighbor_maximum_prefix,
       no_neighbor_maximum_prefix_cmd,
       NO_NEIGHBOR_CMD "maximum-prefix",
       NO_STR
       NEIGHBOR_STR
       NEIGHBOR_ADDR_STR
       "Maximum number of prefix accept from this peer\n")
{
    return bgp_maximum_prefix_unset (vty, argv[0], bgp_node_afi (vty),
                                     bgp_node_safi (vty));
}


int
Bgp::peer_have_afi (struct peer *peer, int afi)
{
  return((afi == AFI_IP && (peer->afc[AFI_IP][SAFI_UNICAST]
			      //                 || peer->afc[AFI_IP][SAFI_MULTICAST])
			    )
	   //           || (afi == AFI_IP6 && (peer->afc[AFI_IP6][SAFI_UNICAST] 
	   //                                  || peer->afc[AFI_IP6][SAFI_MULTICAST]))
	   ));
}

/* `clear ip bgp' functions. */
int
Bgp::clear_bgp (struct vty *vty, int afi, enum clear_type type, char *arg)
{
    int cleared;
    struct peer *peer;
    struct listnode *nn;
    as_t as;
    unsigned long as_ul;
    char *endptr = NULL;
    union sockunion su;
    int ret;

    /* Clear all bgp neighbors. */
    if (type == clear_all)
    {
        for (nn = peer_list->head; nn; nn = nn->next)
            if ((peer = ( struct peer * ) nn->data) != NULL)
            {
                if (peer_have_afi (peer, afi))
                {
                    if (! CHECK_FLAG (peer->flags, PEER_FLAG_SHUTDOWN))
                    {
                        UNSET_FLAG (peer->sflags, PEER_STATUS_PREFIX_OVERFLOW);
                        peer->v_start = BGP_INIT_START_TIMER;
                        BGP_EVENT_ADD (peer, BGP_Stop);
                    }
                }
            }
        vty_out (zlog_default,LOG_DEBUG, "All bgp neighbors cleared%s", VTY_NEWLINE);

        return CMD_SUCCESS;
    }
    /* Clear specified peer.  Arg is string of the peer. */
    else if (type == clear_peer)
    {
        cleared = 0;

        /* Make sockunion for lookup. */
        ret = str2sockunion (arg, &su);
        if (ret < 0)
        {
            vty_out (zlog_default,LOG_DEBUG, "Malformed address: %s%s", arg, VTY_NEWLINE);
            return CMD_WARNING;
        }
        for (nn = peer_list->head; nn; nn = nn->next)
            if (( peer = ( struct peer * ) nn->data) != NULL)
            {
                if (peer_have_afi (peer, afi) && sockunion_same (&peer->su, &su))
                {
                    if (! CHECK_FLAG (peer->flags, PEER_FLAG_SHUTDOWN))
                    {
                        UNSET_FLAG (peer->sflags, PEER_STATUS_PREFIX_OVERFLOW);
                        peer->v_start = BGP_INIT_START_TIMER;
                        BGP_EVENT_ADD (peer, BGP_Stop);
                    }
                    cleared = 1;
                }
            }

        if (cleared)
            vty_out (zlog_default,LOG_DEBUG, "neighbor %s is cleared%s", arg, VTY_NEWLINE);
        else
            vty_out (zlog_default,LOG_DEBUG, "%%BGP: Unknown neighbor - \"%s\"%s", arg, VTY_NEWLINE);

        return CMD_SUCCESS;
    }
    /* AS based clear. */
    else if (type == clear_as)
    {
        cleared = 0;

        as_ul = strtoul(arg, &endptr, 10);

        if ((as_ul == ULONG_MAX) || (*endptr != '\0') || (as_ul > USHRT_MAX))
        {
            vty_out (zlog_default,LOG_DEBUG, "Invalid neighbor specifier: %s%s", arg, 
                     VTY_NEWLINE);
            return CMD_SUCCESS;
        }

        as = (as_t) as_ul;
        for (nn = peer_list->head; nn; nn = nn->next)
            if ((peer = ( struct peer* ) nn->data) != NULL)
            {
                if (peer_have_afi (peer, afi) && peer->as == as)
                {
                    if (! CHECK_FLAG (peer->flags, PEER_FLAG_SHUTDOWN))
                    {
                        UNSET_FLAG (peer->sflags, PEER_STATUS_PREFIX_OVERFLOW);
                        peer->v_start = BGP_INIT_START_TIMER;
                        BGP_EVENT_ADD (peer, BGP_Stop);
                    }
                    cleared = 1;
                }
            }
        if (cleared)
            vty_out (zlog_default,LOG_DEBUG, "All neighbors which AS is %s cleared%s", arg, 
                     VTY_NEWLINE);
        else
            vty_out (zlog_default,LOG_DEBUG, "%%BGP: No peer is configured with AS %s%s", arg,
                     VTY_NEWLINE);

        return CMD_SUCCESS;
    }

    /* Not reached. */
    return CMD_SUCCESS;
}

DEFUN (clear_ip_bgp_all,
       clear_ip_bgp_all_cmd,
       "clear ip bgp *",
       CLEAR_STR
       IP_STR
       BGP_STR
       "Clear all peers\n")
{
    return clear_bgp (vty, AFI_IP, clear_all, NULL);
}

DEFUN (clear_ip_bgp_peer,
       clear_ip_bgp_peer_cmd, 
       "clear ip bgp (A.B.C.D|X:X::X:X)",
       CLEAR_STR
       IP_STR
       BGP_STR
       "BGP neighbor IP address to clear\n"
       "BGP neighbor IPv6 address to clear\n")
{
    return clear_bgp (vty, AFI_IP, clear_peer, argv[0]);
}

DEFUN (clear_ip_bgp_as,
       clear_ip_bgp_as_cmd,
       "clear ip bgp <1-65535>",
       CLEAR_STR
       IP_STR
       BGP_STR
       "Clear peers with the AS number\n")
{
    return clear_bgp (vty, AFI_IP, clear_as, argv[0]);
}       



/* Clear ip bgp neighbor soft in. */
int
Bgp::clear_bgp_soft_in (struct vty *vty, afi_t afi, safi_t safi, enum clear_type type, char *arg, int soft)
{
    int ret;
    union sockunion su;
    struct peer *peer;
    struct listnode *nn;
    as_t as = 0;
    unsigned long as_ul;
    char *endptr = NULL;
    int find = 0;

    if (type == clear_peer)
    {
        /* Looking up peer with IP address string. */
        ret = str2sockunion (arg, &su);
        if (ret < 0)
        {
            vty_out (zlog_default,LOG_DEBUG, "Malformed address: %s%s", arg, VTY_NEWLINE);
            return CMD_WARNING;
        }
    }

    if (type == clear_as)
    {
        as_ul = strtoul(arg, &endptr, 10);
        if ((as_ul == ULONG_MAX) || (*endptr != '\0') || (as_ul > USHRT_MAX))
        {
            vty_out (zlog_default,LOG_DEBUG, "Invalid neighbor specifier: %s%s", arg, VTY_NEWLINE);
            return CMD_WARNING;
        }
        as = (as_t) as_ul;
    }
    for (nn = peer_list->head; nn; nn = nn->next)
        if ((peer = ( struct peer * ) nn->data) != NULL)
        {
            if ((type == clear_peer && sockunion_same (&peer->su, &su))
                || (type == clear_as && peer->as == as)
                || type == clear_all)
            {
                find = 1;
                if (peer->afc[afi][safi])
                {
                    if (peer->status == Established)
                    {
                        if (soft)
                        {
                            /* If neighbor has soft reconfiguration inbound flag.
                           Use Adj-RIB-In database. */
                            if (CHECK_FLAG (peer->af_flags[afi][safi], PEER_FLAG_SOFT_RECONFIG))
                            {
                                bgp_soft_reconfig_in (peer, afi, safi);
                                vty_out (zlog_default,LOG_DEBUG, "neighbor %s is inbound cleared (s)%s",
                                         peer->host, VTY_NEWLINE);
                            } else
                            {
                                /* If neighbor has route refresh capability, send route refresh
                                   message to the peer. */
                                if (peer->refresh_nego_old || peer->refresh_nego_new)
                                {
                                    bgp_route_refresh_send (peer, afi, safi);
                                    vty_out (zlog_default,LOG_DEBUG, "neighbor %s is inbound cleared (r)%s",
                                             peer->host, VTY_NEWLINE);
                                } else
                                    vty_out (zlog_default,LOG_DEBUG, "%%BGP: Inbound soft reconfig for %s not possible as it%s      has neither refresh capability, nor inbound soft reconfig%s", peer->host, VTY_NEWLINE, VTY_NEWLINE);
                            }
                        } else
                        {
                            /* If neighbor has route refresh capability, send route refresh
                               message to the peer. */
                            if (peer->refresh_nego_old || peer->refresh_nego_new)
                            {
                                bgp_route_refresh_send (peer, afi, safi);
                                vty_out (zlog_default,LOG_DEBUG, "neighbor %s is inbound cleared (r)%s",
                                         peer->host, VTY_NEWLINE);
                            } else
                            {
                                /* If neighbor has soft reconfiguration inbound flag.
                                   Use Adj-RIB-In database. */
                                if (CHECK_FLAG (peer->flags, PEER_FLAG_SOFT_RECONFIG))
                                {
                                    bgp_soft_reconfig_in (peer, afi, safi);
                                    vty_out (zlog_default,LOG_DEBUG, "neighbor %s is inbound cleared (s)%s",
                                             peer->host, VTY_NEWLINE);
                                } else
                                    vty_out (zlog_default,LOG_DEBUG, "%%BGP: Inbound soft reconfig for %s not possible as it%s      has neither refresh capability, nor inbound soft reconfig%s", peer->host, VTY_NEWLINE, VTY_NEWLINE);
                            }
                        }
                    }
                } else if (type == clear_peer || type == clear_as)
                    vty_out (zlog_default,LOG_DEBUG, "%%BGP: Enable %s %s address family for the neighbor %s%s",
                             //afi == AFI_IP6 ? "IPv6" : 
			     "IPv4",
                             //safi == SAFI_MULTICAST ? "Multicast" : 
			     "Unicast",
                             peer->host, VTY_NEWLINE);
            }
        }

    if (! find && type == clear_peer)
    {
        vty_out (zlog_default,LOG_DEBUG, "%%BGP: Unknown neighbor - \"%s\"%s", arg, VTY_NEWLINE);
        return CMD_WARNING;
    }
    if (! find && type == clear_as)
    {
        vty_out (zlog_default,LOG_DEBUG, "%%BGP: No peer is configured with AS %s%s", arg, VTY_NEWLINE);
        return CMD_WARNING;
    }

    return CMD_SUCCESS;
}

DEFUN (clear_ip_bgp_peer_soft_in,
       clear_ip_bgp_peer_soft_in_cmd,
       "clear ip bgp A.B.C.D soft in",
       CLEAR_STR
       IP_STR
       BGP_STR
       "BGP neighbor address to clear\n"
       "Soft reconfig\n"
       "Soft reconfig inbound update\n")
{
    return clear_bgp_soft_in (vty, AFI_IP, SAFI_UNICAST, clear_peer, argv[0], 1);
}

DEFUN (clear_ip_bgp_peer_in,
       clear_ip_bgp_peer_in_cmd,
       "clear ip bgp A.B.C.D in",
       CLEAR_STR
       IP_STR
       BGP_STR
       "BGP neighbor address to clear\n"
       "Soft reconfig inbound update\n")
{
    return clear_bgp_soft_in (vty, AFI_IP, SAFI_UNICAST, clear_peer, argv[0], 0);
}

DEFUN (clear_ip_bgp_as_soft_in,
       clear_ip_bgp_as_soft_in_cmd,
       "clear ip bgp <1-65535> soft in",
       CLEAR_STR
       IP_STR
       BGP_STR
       "Clear peers with the AS number\n"
       "Soft reconfig\n"
       "Soft reconfig inbound update\n")
{
    return clear_bgp_soft_in (vty, AFI_IP, SAFI_UNICAST, clear_as, argv[0], 1);
}

DEFUN (clear_ip_bgp_as_in,
       clear_ip_bgp_as_in_cmd,
       "clear ip bgp <1-65535> in",
       CLEAR_STR
       IP_STR
       BGP_STR
       "Clear peers with the AS number\n"
       "Soft reconfig inbound update\n")
{
    return clear_bgp_soft_in (vty, AFI_IP, SAFI_UNICAST, clear_as, argv[0], 0);
}

DEFUN (clear_ip_bgp_all_soft_in,
       clear_ip_bgp_all_soft_in_cmd,
       "clear ip bgp * soft in",
       CLEAR_STR
       IP_STR
       BGP_STR
       "Clear all peers\n"
       "Soft reconfig\n"
       "Soft reconfig inbound update\n")
{
    return clear_bgp_soft_in (vty, AFI_IP, SAFI_UNICAST, clear_all, NULL, 1);
}

DEFUN (clear_ip_bgp_all_in,
       clear_ip_bgp_all_in_cmd,
       "clear ip bgp * in",
       CLEAR_STR
       IP_STR
       BGP_STR
       "Clear all peers\n"
       "Soft reconfig inbound update\n")
{
    return clear_bgp_soft_in (vty, AFI_IP, SAFI_UNICAST, clear_all, NULL, 0);
}

/* Clear ip bgp neighbor soft out. */
int
Bgp::clear_bgp_soft_out (struct vty *vty, afi_t afi, safi_t safi, enum clear_type type, char *arg)
{
    int ret;
    union sockunion su;
    struct peer *peer;
    struct listnode *nn;
    as_t as = 0;
    unsigned long as_ul;
    char *endptr = NULL;
    int find = 0;

    if (type == clear_peer)
    {
        /* Looking up peer with IP address string. */
        ret = str2sockunion (arg, &su);
        if (ret < 0)
        {
            vty_out (zlog_default,LOG_DEBUG, "Malformed address: %s%s", arg, VTY_NEWLINE);
            return CMD_WARNING;
        }
    }

    if (type == clear_as)
    {
        as_ul = strtoul(arg, &endptr, 10);
        if ((as_ul == ULONG_MAX) || (*endptr != '\0') || (as_ul > USHRT_MAX))
        {
            vty_out (zlog_default,LOG_DEBUG, "Invalid neighbor specifier: %s%s", arg, VTY_NEWLINE);
            return CMD_WARNING;
        }
        as = (as_t) as_ul;
    }
    for (nn = peer_list->head; nn; nn = nn->next)
        if ((peer = (struct peer * ) nn->data) != NULL)
        {
            if ((type == clear_peer && sockunion_same (&peer->su, &su))
                || (type == clear_as && peer->as == as)
                || type == clear_all)
            {
                find = 1;
                if (peer->afc[afi][safi])
                {
                    if (peer->status == Established)
                    {
                        /* Performing soft out is same as receiving route
                           refresh. */
#ifdef HAVE_ZEBRA_93b
		      bgp_announce_route (peer, afi, safi);
#else 
		      bgp_refresh_table (peer, afi, safi);
#endif
                        vty_out (zlog_default,LOG_DEBUG, "neighbor %s is outbound cleared%s",
                                 peer->host, VTY_NEWLINE);
                    }
                } else if (type == clear_peer || type == clear_as)
                    vty_out (zlog_default,LOG_DEBUG, "%%BGP: Enable %s %s address family for the neighbor %s%s",
                             //afi == AFI_IP6 ? "IPv6" : 
			     "IPv4",
                             //safi == SAFI_MULTICAST ? "Multicast" : 
			     "Unicast",
                             peer->host, VTY_NEWLINE);
            }
        }

    if (! find && type == clear_peer)
    {
        vty_out (zlog_default,LOG_DEBUG, "%%BGP: Unknown neighbor - \"%s\"%s", arg, VTY_NEWLINE);
        return CMD_WARNING;
    }
    if (! find && type == clear_as)
    {
        vty_out (zlog_default,LOG_DEBUG, "%%BGP: No peer is configured with AS %s%s", arg, VTY_NEWLINE);
        return CMD_WARNING;
    }

    return CMD_SUCCESS;
}

DEFUN (clear_ip_bgp_peer_soft_out,
       clear_ip_bgp_peer_soft_out_cmd,
       "clear ip bgp A.B.C.D soft out",
       CLEAR_STR
       IP_STR
       BGP_STR
       "BGP neighbor address to clear\n"
       "Soft reconfig\n"
       "Soft reconfig outbound update\n")
{
    return clear_bgp_soft_out (vty, AFI_IP, SAFI_UNICAST, clear_peer, argv[0]);
}


DEFUN (clear_ip_bgp_as_soft_out,
       clear_ip_bgp_as_soft_out_cmd,
       "clear ip bgp <1-65535> soft out",
       CLEAR_STR
       IP_STR
       BGP_STR
       "Clear peers with the AS number\n"
       "Soft reconfig\n"
       "Soft reconfig outbound update\n")
{
    return clear_bgp_soft_out (vty, AFI_IP, SAFI_UNICAST, clear_as, argv[0]);
}


DEFUN (clear_ip_bgp_all_soft_out,
       clear_ip_bgp_all_soft_out_cmd,
       "clear ip bgp * soft out",
       CLEAR_STR
       IP_STR
       BGP_STR
       "Clear all peers\n"
       "Soft reconfig\n"
       "Soft reconfig outbound update\n")
{
    return clear_bgp_soft_out (vty, AFI_IP, SAFI_UNICAST, clear_all, NULL);
}


/* soft reset both inbound and outbound */
DEFUN (clear_ip_bgp_peer_soft,
       clear_ip_bgp_peer_soft_cmd,
       "clear ip bgp A.B.C.D soft",
       CLEAR_STR
       IP_STR
       BGP_STR
       "BGP neighbor address to clear\n"
       "Soft reconfig\n")
{
    if (clear_bgp_soft_out (vty, AFI_IP, SAFI_UNICAST, clear_peer, argv[0]) == CMD_SUCCESS)
        clear_bgp_soft_in (vty, AFI_IP, SAFI_UNICAST, clear_peer, argv[0], 0);

    return CMD_SUCCESS;
}

DEFUN (clear_ip_bgp_as_soft,
       clear_ip_bgp_as_soft_cmd,
       "clear ip bgp <1-65535> soft",
       CLEAR_STR
       IP_STR
       BGP_STR
       "Clear peers with the AS number\n"
       "Soft reconfig\n")
{
    if (clear_bgp_soft_out (vty, AFI_IP, SAFI_UNICAST, clear_as, argv[0]) == CMD_SUCCESS)
        clear_bgp_soft_in (vty, AFI_IP, SAFI_UNICAST, clear_as, argv[0], 0);

    return CMD_SUCCESS;
}

DEFUN (clear_ip_bgp_all_soft,
       clear_ip_bgp_all_soft_cmd,
       "clear ip bgp * soft",
       CLEAR_STR
       IP_STR
       BGP_STR
       "Clear all peers\n"
       "Soft reconfig\n")
{
    if (clear_bgp_soft_out (vty, AFI_IP, SAFI_UNICAST, clear_all, NULL) == CMD_SUCCESS)
        clear_bgp_soft_in (vty, AFI_IP, SAFI_UNICAST, clear_all, NULL, 0);

    return CMD_SUCCESS;
}

/* Show BGP peer's summary information. */
int
Bgp::bgp_show_summary (struct vty *vty, int afi, int safi)
{
    struct bgp *bgp;
    struct peer *peer;
    struct peer_conf *conf;
    struct listnode *nn;
    struct listnode *nm;
    int count = 0;
    char timebuf[BGP_UPTIME_LEN];
    int len;

    /* Header string for each address family. */
    static char header[] = "Neighbor        V    AS MsgRcvd MsgSent   TblVer  InQ OutQ Up/Down  State/PfxRcd";
    for (nn = bgp_list->head; nn; nn = nn->next)
        if ((bgp = ( struct bgp * ) nn->data) != NULL)
        {
            for (nm = bgp->peer_conf->head; nm; nm = nm->next)
                if ((conf  = ( struct peer_conf * )  nm->data) != NULL)
                {
                    peer = conf->peer;

                    if (conf->afc[afi][safi])
                    {
                        if (! count)
                        {
                            vty_out (zlog_default,LOG_DEBUG,
                                     "BGP router identifier %s, local AS number %d%s",
                                     inet_ntoa (bgp->id), bgp->as, VTY_NEWLINE);
                            vty_out (zlog_default,LOG_DEBUG, 
                                     "%ld BGP AS-PATH entries%s", aspath_count (),
                                     VTY_NEWLINE);
                            vty_out (zlog_default,LOG_DEBUG, 
                                     "%ld BGP community entries%s", community_count (),
                                     VTY_NEWLINE);

                            if (CHECK_FLAG(bgp->config, BGP_CONFIG_DAMPENING))
                                vty_out (zlog_default,LOG_DEBUG, "Dampening enabled.%s", VTY_NEWLINE);
                            vty_out (zlog_default,LOG_DEBUG, "%s", VTY_NEWLINE);
                            vty_out (zlog_default,LOG_DEBUG, "%s%s", header, VTY_NEWLINE);
                        }
                        count++;

			len = vty_out (zlog_default,LOG_DEBUG, "%s", peer->host);
                        len = 16 - len;
                        if (len < 1)
			  vty_out (zlog_default,LOG_DEBUG, "%s%*s", VTY_NEWLINE, 16, " ");
                        else
			  vty_out (zlog_default,LOG_DEBUG, "%*s", len, " ");

                        switch (peer->version)
                        {
                        case BGP_VERSION_4:
                            vty_out (zlog_default,LOG_DEBUG, "4 ");
                            break;
                        case BGP_VERSION_MP_4_DRAFT_00:
                            vty_out (zlog_default,LOG_DEBUG, "4-");
                            break;
                        }

                        vty_out (zlog_default,LOG_DEBUG, "%5d %7d %7d %8d %4d %4ld ",
                                 peer->as,
                                 peer->open_in + peer->update_in +
                                 peer->keepalive_in + peer->notify_in + peer->refresh_in,
                                 peer->open_out + peer->update_out +
                                 peer->keepalive_out + peer->notify_out + peer->refresh_out,
                                 0, 0, peer->obuf->count);

                        vty_out (zlog_default,LOG_DEBUG, "%8s", 
                                 peer_uptime (peer->uptime, timebuf, BGP_UPTIME_LEN));

                        if (peer->status == Established)
                        {
                            vty_out (zlog_default,LOG_DEBUG, " %8ld", conf->pcount[afi][safi]);
                        } else
                        {
                            if (CHECK_FLAG (peer->flags, PEER_FLAG_SHUTDOWN))
                                vty_out (zlog_default,LOG_DEBUG, " Idle (Admin)");
                            else if (CHECK_FLAG (peer->sflags, PEER_STATUS_PREFIX_OVERFLOW))
                                vty_out (zlog_default,LOG_DEBUG, " Idle (PfxCt)");
                            else
                                vty_out (zlog_default,LOG_DEBUG, " %-11s", LOOKUP(bgp_status_msg, peer->status));
                        }

                        vty_out (zlog_default,LOG_DEBUG, "%s", VTY_NEWLINE);
                    }
                }
        }

    if (count)
        vty_out (zlog_default,LOG_DEBUG, "%sTotal number of neighbors %d%s", VTY_NEWLINE,
                 count, VTY_NEWLINE);
    else
        vty_out (zlog_default,LOG_DEBUG, "No %s neighbor is configured%s",
                 afi == AFI_IP ? "IPv4" : "IPv6", VTY_NEWLINE);
    return CMD_SUCCESS;
}

/* `show ip bgp summary' commands. */
DEFUN (show_ip_bgp_summary, 
       show_ip_bgp_summary_cmd,
       "show ip bgp summary",
       SHOW_STR
       IP_STR
       BGP_STR
       "Summary of BGP neighbor status\n")
{
    return bgp_show_summary (vty, AFI_IP, SAFI_UNICAST);
}

/* Return next event time. */
double
Bgp::bgp_next_timer (struct thread *thread)
{
    double timer_now;
    timer_now = Scheduler::instance().clock();
    return thread->u.time - timer_now;
}

void
Bgp::bgp_show_peer_afi (struct vty *vty, struct peer_conf *conf, afi_t afi, safi_t safi)
{
    struct bgp_filter *filter;
    struct peer *p;

    p = conf->peer;
    filter = &conf->filter[afi][safi];

    vty_out (zlog_default,LOG_DEBUG, " For address family: %s %s%s",
             //afi == AFI_IP6 ? "IPv6" : 
	     "IPv4",
             //safi == SAFI_MULTICAST ? "Multicast" : 
	     "Unicast",
             VTY_NEWLINE);
    if (CHECK_FLAG (p->af_flags[afi][safi], PEER_FLAG_REFLECTOR_CLIENT))
        vty_out (zlog_default,LOG_DEBUG, "  Route-Reflector Client%s", VTY_NEWLINE);
    if (CHECK_FLAG (p->af_flags[afi][safi], PEER_FLAG_RSERVER_CLIENT))
        vty_out (zlog_default,LOG_DEBUG, "  Route-Server Client%s", VTY_NEWLINE);
    if (CHECK_FLAG (p->af_flags[afi][safi], PEER_FLAG_SOFT_RECONFIG))
        vty_out (zlog_default,LOG_DEBUG, "  Inbound soft reconfiguration allowed%s", VTY_NEWLINE);
    if (CHECK_FLAG (p->af_flags[afi][safi], PEER_FLAG_NEXTHOP_SELF))
        vty_out (zlog_default,LOG_DEBUG, "  NEXT_HOP is always this router%s", VTY_NEWLINE);
    if (CHECK_FLAG (p->af_flags[afi][safi], PEER_FLAG_SEND_COMMUNITY)
        || CHECK_FLAG (p->af_flags[afi][safi], PEER_FLAG_SEND_EXT_COMMUNITY))
    {
        vty_out (zlog_default,LOG_DEBUG, "  Community attribute sent to this neighbor");
        if (CHECK_FLAG (p->af_flags[afi][safi], PEER_FLAG_SEND_COMMUNITY)
            && CHECK_FLAG (p->af_flags[afi][safi], PEER_FLAG_SEND_EXT_COMMUNITY))
            vty_out (zlog_default,LOG_DEBUG, " (both)%s", VTY_NEWLINE);
        else if (CHECK_FLAG (p->af_flags[afi][safi], PEER_FLAG_SEND_EXT_COMMUNITY))
            vty_out (zlog_default,LOG_DEBUG, " (extended)%s", VTY_NEWLINE);
        else
            vty_out (zlog_default,LOG_DEBUG, " (standard)%s", VTY_NEWLINE);
    }
    if (filter->plist[FILTER_IN].name ||
        filter->dlist[FILTER_IN].name ||
        filter->aslist[FILTER_IN].name ||
        filter->map[FILTER_IN].name)
        vty_out (zlog_default,LOG_DEBUG, "  Inbound path policy configured%s", VTY_NEWLINE);
    if (filter->plist[FILTER_OUT].name ||
        filter->dlist[FILTER_OUT].name ||
        filter->aslist[FILTER_OUT].name ||
        filter->map[FILTER_OUT].name)
        vty_out (zlog_default,LOG_DEBUG, "  Outbound path policy configured%s", VTY_NEWLINE);

    /* prefix-list */
    if (filter->plist[FILTER_IN].name)
        vty_out (zlog_default,LOG_DEBUG, "  Incoming update prefix filter list is %s%s%s",
                 filter->plist[FILTER_IN].plist ? "*" : "",
                 filter->plist[FILTER_IN].name,
                 VTY_NEWLINE);
    if (filter->plist[FILTER_OUT].name)
        vty_out (zlog_default,LOG_DEBUG, "  Outgoing update prefix filter list is %s%s%s",
                 filter->plist[FILTER_OUT].plist ? "*" : "",
                 filter->plist[FILTER_OUT].name,
                 VTY_NEWLINE);

    /* distribute-list */
    if (filter->dlist[FILTER_IN].name)
        vty_out (zlog_default,LOG_DEBUG, "  Incoming update network filter list is %s%s%s",
                 filter->dlist[FILTER_IN].alist ? "*" : "",
                 filter->dlist[FILTER_IN].name,
                 VTY_NEWLINE);
    if (filter->dlist[FILTER_OUT].name)
        vty_out (zlog_default,LOG_DEBUG, "  Outgoing update network filter list is %s%s%s",
                 filter->dlist[FILTER_OUT].alist ? "*" : "",
                 filter->dlist[FILTER_OUT].name,
                 VTY_NEWLINE);

    /* filter-list. */
    if (filter->aslist[FILTER_IN].name)
        vty_out (zlog_default,LOG_DEBUG, "  Incoming update AS path filter list is %s%s%s",
                 filter->aslist[FILTER_IN].aslist ? "*" : "",
                 filter->aslist[FILTER_IN].name,
                 VTY_NEWLINE);
    if (filter->aslist[FILTER_OUT].name)
        vty_out (zlog_default,LOG_DEBUG, "  Outgoing update AS path filter list is %s%s%s",
                 filter->aslist[FILTER_OUT].aslist ? "*" : "",
                 filter->aslist[FILTER_OUT].name,
                 VTY_NEWLINE);

    /* route-map. */
    if (filter->map[FILTER_IN].name)
        vty_out (zlog_default,LOG_DEBUG, "  Route map for incoming advertisements is %s%s%s",
                 filter->map[FILTER_IN].map ? "*" : "",
                 filter->map[FILTER_IN].name,
                 VTY_NEWLINE);
    if (filter->map[FILTER_OUT].name)
        vty_out (zlog_default,LOG_DEBUG, "  Route map for outgoing advertisements is %s%s%s",
                 filter->map[FILTER_OUT].map ? "*" : "",
                 filter->map[FILTER_OUT].name,
                 VTY_NEWLINE);

    vty_out (zlog_default,LOG_DEBUG, "  %ld accepted prefixes",
             conf->pcount[afi][safi]);
    if (conf->pmax[afi][safi])
    {
        vty_out (zlog_default,LOG_DEBUG, ", maximum limit %ld%s",
                 conf->pmax[afi][safi],
                 conf->pmax_warning[afi][safi] ? " (warning-only)" : "");
    }
    vty_out (zlog_default,LOG_DEBUG, "%s", VTY_NEWLINE);

    vty_out (zlog_default,LOG_DEBUG, "%s", VTY_NEWLINE);
}

void
Bgp::bgp_show_peer (struct vty *vty, struct peer_conf *conf, afi_t afi, safi_t safi)
{
    char buf1[BUFSIZ];
    char timebuf[BGP_UPTIME_LEN];
    struct peer *p;

    p = conf->peer;

    /* Configured IP address. */
    vty_out (zlog_default,LOG_DEBUG, "BGP neighbor is %s, ", p->host);
    vty_out (zlog_default,LOG_DEBUG, "remote AS %d, ", p->as);
    vty_out (zlog_default,LOG_DEBUG, "local AS %d, ", p->local_as);
    vty_out (zlog_default,LOG_DEBUG, "%s link%s",
             p->as == p->local_as ? "internal" : "external",
             VTY_NEWLINE);

    /* Description. */
    if (p->desc)
        vty_out (zlog_default,LOG_DEBUG, " Description: %s%s", p->desc, VTY_NEWLINE);

    /* Administrative shutdown. */
    if (CHECK_FLAG (p->flags, PEER_FLAG_SHUTDOWN))
        vty_out (zlog_default,LOG_DEBUG, " Administratively shut down%s", VTY_NEWLINE);

    /* BGP Version. */
    vty_out (zlog_default,LOG_DEBUG, "  BGP version 4");
    if (p->version == BGP_VERSION_MP_4_DRAFT_00)
        vty_out (zlog_default,LOG_DEBUG, "(with draft-00 verion of multiporotocol extension)");
    vty_out (zlog_default,LOG_DEBUG, ", remote router ID %s%s", 
             Bgp::inet_ntop (AF_INET, &p->remote_id, buf1, BUFSIZ),
             VTY_NEWLINE);

    /* Confederation */
    if (bgp_confederation_peers_check (conf->bgp, p->as))
        vty_out (zlog_default,LOG_DEBUG, "  Neighbor under common administration%s", VTY_NEWLINE);

    /* Status. */
    vty_out (zlog_default,LOG_DEBUG, "  BGP state = %s",  
             CHECK_FLAG (p->flags, PEER_FLAG_SHUTDOWN) 
             ? "Idle" : LOOKUP(bgp_status_msg, p->status));
    if (p->status == Established)
        vty_out (zlog_default,LOG_DEBUG, ", up for %8s", 
                 peer_uptime (p->uptime, timebuf, BGP_UPTIME_LEN));
    vty_out (zlog_default,LOG_DEBUG, "%s", VTY_NEWLINE);

    /* read timer */
    vty_out (zlog_default,LOG_DEBUG, "  Last read %s", peer_uptime (p->readtime, timebuf, BGP_UPTIME_LEN));

    /* Configured timer values. */
    vty_out (zlog_default,LOG_DEBUG, ", hold time is %d, keepalive interval is %d seconds%s",
             p->v_holdtime, p->v_keepalive, VTY_NEWLINE);
    if (p->config & PEER_CONFIG_TIMER)
    {
        vty_out (zlog_default,LOG_DEBUG, "  Configured hold time is %d", p->holdtime);
        vty_out (zlog_default,LOG_DEBUG, ", keepalive interval is %d seconds%s",
                 p->keepalive, VTY_NEWLINE);
    }

    /* Capability. */
    if (p->status == Established)
    {
        if ((p->refresh_adv || p->refresh_nego_old || p->refresh_nego_new)
            || (p->afc_adv[AFI_IP][SAFI_UNICAST] || p->afc_recv[AFI_IP][SAFI_UNICAST]) 
	    //            || (p->afc_adv[AFI_IP][SAFI_MULTICAST] || p->afc_recv[AFI_IP][SAFI_MULTICAST]) 
	    )
        {
            vty_out (zlog_default,LOG_DEBUG, "  Neighbor capabilities:%s", VTY_NEWLINE);

            /* Route Refresh */
            if (p->refresh_adv || p->refresh_nego_old || p->refresh_nego_new)
            {
                vty_out (zlog_default,LOG_DEBUG, "    Route refresh:");
                if (p->refresh_adv)
                    vty_out (zlog_default,LOG_DEBUG, " advertised");
                if (p->refresh_nego_old || p->refresh_nego_new)
                {
                    if (p->refresh_adv)
                        vty_out (zlog_default,LOG_DEBUG, " and");
                    vty_out (zlog_default,LOG_DEBUG, " received");
                    if (p->refresh_nego_old && p->refresh_nego_new)
                        vty_out (zlog_default,LOG_DEBUG, " (old and New)");
                    else if (p->refresh_nego_old)
                        vty_out (zlog_default,LOG_DEBUG, " (old)");
                    else
                        vty_out (zlog_default,LOG_DEBUG, " (New)");
                }
                vty_out (zlog_default,LOG_DEBUG, "%s", VTY_NEWLINE);
            }

            /* IPv4 */
            if (p->afc_adv[AFI_IP][SAFI_UNICAST] || p->afc_recv[AFI_IP][SAFI_UNICAST])
            {
                vty_out (zlog_default,LOG_DEBUG, "    Address family IPv4 Unicast:");
                if (p->afc_adv[AFI_IP][SAFI_UNICAST])
                    vty_out (zlog_default,LOG_DEBUG, " advertised");
                if (p->afc_recv[AFI_IP][SAFI_UNICAST])
                {
                    if (p->afc_adv[AFI_IP][SAFI_UNICAST])
                        vty_out (zlog_default,LOG_DEBUG, " and");
                    vty_out (zlog_default,LOG_DEBUG, " received");
                }
                vty_out (zlog_default,LOG_DEBUG, "%s", VTY_NEWLINE);
            }
	    /*            if (p->afc_adv[AFI_IP][SAFI_MULTICAST] || p->afc_recv[AFI_IP][SAFI_MULTICAST])
            {
                vty_out (zlog_default,LOG_DEBUG, "    Address family IPv4 Multicast:");
                if (p->afc_adv[AFI_IP][SAFI_MULTICAST])
                    vty_out (zlog_default,LOG_DEBUG, " advertised");
                if (p->afc_recv[AFI_IP][SAFI_MULTICAST])
                {
                    if (p->afc_adv[AFI_IP][SAFI_MULTICAST])
                        vty_out (zlog_default,LOG_DEBUG, " and");
                    vty_out (zlog_default,LOG_DEBUG, " received");
                }
                vty_out (zlog_default,LOG_DEBUG, "%s", VTY_NEWLINE);
            }
	    */
            /* IPv6 */
        }
    }

    /* Packet counts. */
    vty_out (zlog_default,LOG_DEBUG, "  Received %d messages, %d notifications, %d in queue%s",
            p->open_in + p->update_in + p->keepalive_in,
            p->notify_in, 0, VTY_NEWLINE);
    vty_out (zlog_default,LOG_DEBUG, "  Sent %d messages, %d notifications, %ld in queue%s",
            p->open_out + p->update_out + p->keepalive_out,
            p->notify_out, p->obuf->count, VTY_NEWLINE);
    vty_out (zlog_default,LOG_DEBUG, "  Route refresh request: received %d, sent %d%s",
            p->refresh_in, p->refresh_out, VTY_NEWLINE);

    /* advertisement-interval (Current not supported)*/
    vty_out (zlog_default,LOG_DEBUG, "  Minimum time between advertisement runs is 0 seconds%s",
             VTY_NEWLINE);

    /* Default weight */
    if (p->weight)
        vty_out (zlog_default,LOG_DEBUG, "  Default weight %d%s", p->weight,
                 VTY_NEWLINE);

    vty_out (zlog_default,LOG_DEBUG, "%s", VTY_NEWLINE);

    /* Address Family Information */
    if (p->afc[AFI_IP][SAFI_UNICAST])
        bgp_show_peer_afi (vty, conf, AFI_IP, SAFI_UNICAST);
    //    if (p->afc[AFI_IP][SAFI_MULTICAST])
    //        bgp_show_peer_afi (vty, conf, AFI_IP, SAFI_MULTICAST);
    vty_out (zlog_default,LOG_DEBUG, "  Connections established %d; dropped %d%s",
             p->established, p->dropped,
             VTY_NEWLINE);

    if (CHECK_FLAG (p->sflags, PEER_STATUS_PREFIX_OVERFLOW))
    {
        vty_out (zlog_default,LOG_DEBUG, "  Peer had exceeded the max. no. of prefixes configured.%s", VTY_NEWLINE);
        vty_out (zlog_default,LOG_DEBUG, "  Reduce the no. of prefix and clear ip bgp %s to restore peering%s",
                 p->host, VTY_NEWLINE);
    }

    /* EBGP Multihop */
    if (peer_sort (p) == BGP_PEER_EBGP && p->ttl > 1)
        vty_out (zlog_default,LOG_DEBUG, "  External BGP neighbor may be up to %d hops away.%s",
                 p->ttl, VTY_NEWLINE);

    /* Local address. */
    if (p->su_local)
    {
        vty_out (zlog_default,LOG_DEBUG, "Local host: %s, Local port: %d%s",
                 sockunion2str (p->su_local, buf1, SU_ADDRSTRLEN),
                 ntohs (p->su_local->sin.sin_port),
                 VTY_NEWLINE);
    }

    /* Remote address. */
    if (p->su_remote)
    {
        vty_out (zlog_default,LOG_DEBUG, "Foreign host: %s, Foreign port: %d%s",
                 sockunion2str (p->su_remote, buf1, SU_ADDRSTRLEN),
                 ntohs (p->su_remote->sin.sin_port),
                 VTY_NEWLINE);
    }

    /* Nexthop display. */
    if (p->su_local)
    {
        vty_out (zlog_default,LOG_DEBUG, "Nexthop: %s%s", 
                 Bgp::inet_ntop (AF_INET, &p->nexthop.v4, buf1, BUFSIZ),
                 VTY_NEWLINE);
    }

    /* Timer information. */
    if (p->t_start)
        vty_out (zlog_default,LOG_DEBUG, "Next start timer due in %d seconds%s",
                 bgp_next_timer (p->t_start), VTY_NEWLINE);
    if (p->t_connect)
        vty_out (zlog_default,LOG_DEBUG, "Next connect timer due in %d seconds%s",
                 bgp_next_timer (p->t_connect), VTY_NEWLINE);

    vty_out (zlog_default,LOG_DEBUG, "Read thread: %s  Write thread: %s%s", 
             p->t_read ? "on" : "off",
             p->t_write ? "on" : "off",
             VTY_NEWLINE);

    if (p->notify.code == BGP_NOTIFY_OPEN_ERR
        && p->notify.subcode == BGP_NOTIFY_OPEN_UNSUP_CAPBL)
        bgp_capability_vty_out (vty, p);

    vty_out (zlog_default,LOG_DEBUG, "%s", VTY_NEWLINE);
}

int
Bgp::bgp_show_neighbor (struct vty *vty, int afi, int safi, enum show_type type,
                        char *ip_str)
{
    struct listnode *nn, *nm;
    struct bgp *bgp;
    struct peer_conf *conf;
    union sockunion su;
    int ret;
    int find = 0;

    if (ip_str)
    {
        ret = str2sockunion (ip_str, &su);
        if (ret < 0)
        {
            vty_out (zlog_default,LOG_DEBUG, "Malformed address: %s%s", ip_str, VTY_NEWLINE);
            return CMD_WARNING;
        }
    }
    for (nn = bgp_list->head; nn; nn = nn->next)
        if ((bgp = ( struct bgp * ) nn->data) != NULL)
        {
            for (nm = bgp->peer_conf->head; nm; nm = nm->next)
                if ((conf = ( struct peer_conf * ) nm->data) != NULL)
                {
                    switch (type)
                    {
                    case show_all:
                        if (conf->afc[afi][safi])
                            bgp_show_peer (vty, conf, afi, safi);
                        break;
                    case show_peer:
                        if (conf->afc[afi][safi] 
                            && sockunion_same (&conf->peer->su, &su))
                        {
                            find = 1;
                            bgp_show_peer (vty, conf, afi, safi);
                        }
                        break;
                    }
                }
        }

    if (type == show_peer && ! find)
        vty_out (zlog_default,LOG_DEBUG, "%% No such neighbor or address family%s", VTY_NEWLINE);

    return CMD_SUCCESS;
}

DEFUN (show_ip_bgp_neighbors,
       show_ip_bgp_neighbors_cmd,
       "show ip bgp neighbors",
       SHOW_STR
       IP_STR
       BGP_STR
       "Detailed information on TCP and BGP neighbor connections\n")
{
    return bgp_show_neighbor (vty, AFI_IP, SAFI_UNICAST, show_all, NULL);
}

DEFUN (show_ip_bgp_neighbors_peer,
       show_ip_bgp_neighbors_peer_cmd,
       "show ip bgp neighbors (A.B.C.D|X:X::X:X)",
       SHOW_STR
       IP_STR
       BGP_STR
       "Detailed information on TCP and BGP neighbor connections\n"
       "Neighbor to display information about\n"
       "Neighbor to display information about\n")
{
    return bgp_show_neighbor (vty, AFI_IP, SAFI_UNICAST, show_peer, argv[0]);
}

/* Show BGP's AS paths internal data.  There are both `show ip bgp
   paths' and `show ip mbgp paths'.  Those functions results are the
   same.*/
DEFUN (show_ip_bgp_paths, 
       show_ip_bgp_paths_cmd,
       "show ip bgp paths",
       SHOW_STR
       IP_STR
       BGP_STR
       "Path information\n")
{
    vty_out (zlog_default,LOG_DEBUG, "Address Refcnt Path%s", VTY_NEWLINE);
    aspath_print_all_vty (vty);
    return CMD_SUCCESS;
}

/* Show BGP's community internal data. */
DEFUN (show_ip_bgp_community_info, 
       show_ip_bgp_community_info_cmd,
       "show ip bgp community-info",
       SHOW_STR
       IP_STR
       BGP_STR
       "List all bgp community information\n")
{
    vty_out (zlog_default,LOG_DEBUG, "Address Refcnt Community%s", VTY_NEWLINE);
    community_print_all_vty (vty);
    return CMD_SUCCESS;
}

DEFUN (show_ip_bgp_attr_info, 
       show_ip_bgp_attr_info_cmd,
       "show ip bgp attribute-info",
       SHOW_STR
       IP_STR
       BGP_STR
       "List all bgp attribute information\n")
{


    attrhash_dump (vty);
    return CMD_SUCCESS;
}

void
Bgp::bgp_config_write_filter (struct vty *vty, struct bgp_filter *filter,
                              char *addr)
{
    /* distribute-list. */
    if (filter->dlist[FILTER_IN].name)
        vty_out (zlog_default,LOG_DEBUG, " neighbor %s distribute-list %s in%s", addr, 
                 filter->dlist[FILTER_IN].name, VTY_NEWLINE);
    if (filter->dlist[FILTER_OUT].name)
        vty_out (zlog_default,LOG_DEBUG, " neighbor %s distribute-list %s out%s", addr, 
                 filter->dlist[FILTER_OUT].name, VTY_NEWLINE);

    /* prefix-list. */
    if (filter->plist[FILTER_IN].name)
        vty_out (zlog_default,LOG_DEBUG, " neighbor %s prefix-list %s in%s", addr, 
                 filter->plist[FILTER_IN].name, VTY_NEWLINE);
    if (filter->plist[FILTER_OUT].name)
        vty_out (zlog_default,LOG_DEBUG, " neighbor %s prefix-list %s out%s", addr, 
                 filter->plist[FILTER_OUT].name, VTY_NEWLINE);

    /* filter-list. */
    if (filter->aslist[FILTER_IN].name)
        vty_out (zlog_default,LOG_DEBUG, " neighbor %s filter-list %s in%s", addr, 
                 filter->aslist[FILTER_IN].name, VTY_NEWLINE);
    if (filter->aslist[FILTER_OUT].name)
        vty_out (zlog_default,LOG_DEBUG, " neighbor %s filter-list %s out%s", addr, 
                 filter->aslist[FILTER_OUT].name, VTY_NEWLINE);

    /* route-map. */
    if (filter->map[FILTER_IN].name)
        vty_out (zlog_default,LOG_DEBUG, " neighbor %s route-map %s in%s", addr, 
                 filter->map[FILTER_IN].name, VTY_NEWLINE);
    if (filter->map[FILTER_OUT].name)
        vty_out (zlog_default,LOG_DEBUG, " neighbor %s route-map %s out%s", addr, 
                 filter->map[FILTER_OUT].name, VTY_NEWLINE);
}

/* BGP peer configuration display function. */
void
Bgp::bgp_config_write_peer (struct vty *vty, struct bgp *bgp,
                            struct peer_conf *conf, afi_t afi, safi_t safi)
{
    struct peer *peer;
    char addr[SU_ADDRSTRLEN];
    char buf[SU_ADDRSTRLEN];
    struct bgp_filter *filter;

    peer = conf->peer;
    filter = &conf->filter[afi][safi];
    sockunion2str (&peer->su, addr, SU_ADDRSTRLEN);

    /************************************
     ****** Global to the neighbor ******
     ************************************/
    if (afi == AFI_IP && safi == SAFI_UNICAST)
    {
        /* remote-as. */
        vty_out (zlog_default,LOG_DEBUG, " neighbor %s remote-as %d%s", addr, peer->as,
                 VTY_NEWLINE);

        /* Description. */
        if (peer->desc)
            vty_out (zlog_default,LOG_DEBUG, " neighbor %s description %s%s", addr, peer->desc,
                     VTY_NEWLINE);

        /* Shutdown. */
        if (CHECK_FLAG (peer->flags, PEER_FLAG_SHUTDOWN))
           vty_out (zlog_default,LOG_DEBUG, " neighbor %s shutdown%s", addr, VTY_NEWLINE);

        /* Passive. */
        if (CHECK_FLAG (peer->flags, PEER_FLAG_PASSIVE))
           vty_out (zlog_default,LOG_DEBUG, " neighbor %s passive%s", addr, VTY_NEWLINE);

        /* ebgp-multihop print. */
        if (peer_sort (peer) == BGP_PEER_EBGP && peer->ttl != 1)
           vty_out (zlog_default,LOG_DEBUG, " neighbor %s ebgp-multihop %d%s", addr, peer->ttl,
                     VTY_NEWLINE);

        /* BGP version print. */
        if (peer->version == BGP_VERSION_MP_4_DRAFT_00)
           vty_out (zlog_default,LOG_DEBUG, " neighbor %s version %s%s",
                     addr,"4-", VTY_NEWLINE);

        /* timers. */
        if (peer->config & PEER_CONFIG_TIMER)
           vty_out (zlog_default,LOG_DEBUG, " neighbor %s timers %d %d%s", addr, 
                     peer->keepalive, peer->holdtime, VTY_NEWLINE);
        if (peer->config & PEER_CONFIG_CONNECT)
           vty_out (zlog_default,LOG_DEBUG, " neighbor %s timers connect %d%s", addr, 
                     peer->connect, VTY_NEWLINE);

        /* Default weight. */
        if (peer->weight)
           vty_out (zlog_default,LOG_DEBUG, " neighbor %s weight %d%s", addr, peer->weight,
                     VTY_NEWLINE);

	if (CHECK_FLAG (peer->config, PEER_CONFIG_ROUTEADV))
	  vty_out (zlog_default,LOG_DEBUG, " neighbor %s advertisement-interval %d%s",
		   addr, peer->v_routeadv, VTY_NEWLINE); 
	 
        /* Route refresh. */
        if (! CHECK_FLAG (peer->flags, PEER_FLAG_CAPABILITY_ROUTE_REFRESH))
           vty_out (zlog_default,LOG_DEBUG, " no neighbor %s capability route-refresh%s", addr,
                     VTY_NEWLINE);

        /* dont capability negotiation. */
        if (CHECK_FLAG (peer->flags, PEER_FLAG_DONT_CAPABILITY))
           vty_out (zlog_default,LOG_DEBUG, " neighbor %s dont-capability-negotiate%s", addr,
                     VTY_NEWLINE);

        /* override capability negotiation. */
        if (CHECK_FLAG (peer->flags, PEER_FLAG_OVERRIDE_CAPABILITY))
           vty_out (zlog_default,LOG_DEBUG, " neighbor %s override-capability%s", addr,
                     VTY_NEWLINE);

        /* strict capability negotiation. */
        if (CHECK_FLAG (peer->flags, PEER_FLAG_STRICT_CAP_MATCH))
           vty_out (zlog_default,LOG_DEBUG, " neighbor %s strict-capability-match%s", addr,
                     VTY_NEWLINE);

        if (CHECK_FLAG (bgp->config, BGP_CONFIG_NO_DEFAULT_IPV4))
        {
            if (conf->afc[AFI_IP][SAFI_UNICAST])
               vty_out (zlog_default,LOG_DEBUG, " neighbor %s activate%s", addr, VTY_NEWLINE);
        } else
        {
            if (! conf->afc[AFI_IP][SAFI_UNICAST])
               vty_out (zlog_default,LOG_DEBUG, " no neighbor %s activate%s", addr, VTY_NEWLINE);
        }
    }


    /************************************
     ****** Per AF to the neighbor ******
     ************************************/

    if (! (afi == AFI_IP && safi == SAFI_UNICAST))
       vty_out (zlog_default,LOG_DEBUG, " neighbor %s activate%s", addr, VTY_NEWLINE);

    /* Route reflector client. */
    if (CHECK_FLAG (peer->af_flags[afi][safi], PEER_FLAG_REFLECTOR_CLIENT))
       vty_out (zlog_default,LOG_DEBUG, " neighbor %s route-reflector-client%s", addr, VTY_NEWLINE);

    /* Nexthop self. */
    if (CHECK_FLAG (peer->af_flags[afi][safi], PEER_FLAG_NEXTHOP_SELF))
       vty_out (zlog_default,LOG_DEBUG, " neighbor %s next-hop-self%s", addr, VTY_NEWLINE);

    /* send-community print. */
    if (! (CHECK_FLAG (peer->af_flags[afi][safi], PEER_FLAG_SEND_COMMUNITY)
           && CHECK_FLAG (peer->af_flags[afi][safi], PEER_FLAG_SEND_EXT_COMMUNITY)))
    {
        if (! CHECK_FLAG (peer->af_flags[afi][safi], PEER_FLAG_SEND_COMMUNITY)
            && ! CHECK_FLAG (peer->af_flags[afi][safi], PEER_FLAG_SEND_EXT_COMMUNITY))
           vty_out (zlog_default,LOG_DEBUG, " no neighbor %s send-community both%s",
                     addr, VTY_NEWLINE);
        else if (! CHECK_FLAG (peer->af_flags[afi][safi], PEER_FLAG_SEND_EXT_COMMUNITY))
           vty_out (zlog_default,LOG_DEBUG, " no neighbor %s send-community extended%s",
                     addr, VTY_NEWLINE);
        else
           vty_out (zlog_default,LOG_DEBUG, " no neighbor %s send-community%s",
                     addr, VTY_NEWLINE);
    }

    /* Default information */
    if (CHECK_FLAG (peer->flags, PEER_FLAG_DEFAULT_ORIGINATE)
        && (afi == AFI_IP && safi == SAFI_UNICAST))
       vty_out (zlog_default,LOG_DEBUG, " neighbor %s default-originate%s", addr, VTY_NEWLINE);

    /* Soft reconfiguration inbound. */
    if (CHECK_FLAG (peer->af_flags[afi][safi], PEER_FLAG_SOFT_RECONFIG))
       vty_out (zlog_default,LOG_DEBUG, " neighbor %s soft-reconfiguration inbound%s", addr,
                 VTY_NEWLINE);

    /* maximum-prefix. */
    if (conf->pmax[afi][safi])
       vty_out (zlog_default,LOG_DEBUG, " neighbor %s maximum-prefix %ld%s%s",
                 addr, conf->pmax[afi][safi],
                 conf->pmax_warning[afi][safi] ? " warning-only" : "",
                 VTY_NEWLINE);

    /* Route server client. */
    if (CHECK_FLAG (peer->af_flags[afi][safi], PEER_FLAG_RSERVER_CLIENT))
       vty_out (zlog_default,LOG_DEBUG, " neighbor %s route-server-client%s", addr, VTY_NEWLINE);

    /* translate-update. */
//     if (peer->translate_update
//         && (afi == AFI_IP && safi == SAFI_UNICAST))
//     {
//        vty_out (zlog_default,LOG_DEBUG, " neighbor %s", addr);

//         if (peer->translate_update == SAFI_UNICAST_MULTICAST)
//            vty_out (zlog_default,LOG_DEBUG, " translate-update nlri unicast multicast%s", 
//                      VTY_NEWLINE);
//         else if (peer->translate_update == SAFI_MULTICAST)
//            vty_out (zlog_default,LOG_DEBUG, " translate-update nlri multicast%s", 
//                      VTY_NEWLINE);
//     }

    /* Filter. */
    bgp_config_write_filter (vty, filter, addr);

    /* transparent-as. */
    if (CHECK_FLAG (peer->flags, PEER_FLAG_TRANSPARENT_AS)
        && (afi == AFI_IP && safi == SAFI_UNICAST))
       vty_out (zlog_default,LOG_DEBUG, " neighbor %s transparent-as%s", addr, VTY_NEWLINE);

    /* transparent-nexthop. */
    if (CHECK_FLAG (peer->flags, PEER_FLAG_TRANSPARENT_NEXTHOP)
        && (afi == AFI_IP && safi == SAFI_UNICAST))
       vty_out (zlog_default,LOG_DEBUG, " neighbor %s transparent-nexthop%s", addr,
                 VTY_NEWLINE);
}

/* Display "address-family" configuration header. */
void
Bgp::bgp_config_write_family_header (struct vty *vty, afi_t afi, safi_t safi,
                                     int *write)
{
    if (*write)
        return;

    if (afi == AFI_IP && safi == SAFI_UNICAST)
        return;

   vty_out (zlog_default,LOG_DEBUG, "!%s address-family ", VTY_NEWLINE);

    if (afi == AFI_IP)
    {
      if (safi == SAFI_MULTICAST)
	vty_out (zlog_default,LOG_DEBUG, "ipv4 multicast");
    } 
    //else if (afi == AFI_IP6)
    //vty_out (zlog_default,LOG_DEBUG, "ipv6");

   vty_out (zlog_default,LOG_DEBUG, "%s", VTY_NEWLINE);

    *write = 1;
}

/* Address family based peer configuration display.  */
int
Bgp::bgp_config_write_family (struct vty *vty, struct bgp *bgp, afi_t afi,
                              safi_t safi)
{
    int write = 0;
    struct peer_conf *conf;
    struct listnode *nn;

    bgp_config_write_network (vty, bgp, afi, safi, &write);

    for (nn = bgp->peer_conf->head; nn; nn = nn->next)
        if ((conf = ( struct peer_conf * ) nn->data) != NULL)
        {
            if (conf->afc[afi][safi])
            {
                bgp_config_write_family_header (vty, afi, safi, &write);
                bgp_config_write_peer (vty, bgp, conf, afi, safi);
            }
        }
    if (write)
       vty_out (zlog_default,LOG_DEBUG, " exit-address-family%s", VTY_NEWLINE);

    return write;
}

/* Install bgp related commands. */
void
Bgp::bgp_init ()
{
    /* "bgp router-id" commands. */
    if(cmdvec_init) install_element (CONFIG_NODE, &bgp_router_id_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &no_bgp_router_id_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &no_bgp_router_id_val_cmd);

    /* "timers bgp" commands. */
    if(cmdvec_init) install_element (CONFIG_NODE, &bgp_timers_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &no_bgp_timers_cmd);

    /* "bgp cluster-id" commands. */
    if(cmdvec_init) install_element (CONFIG_NODE, &bgp_cluster_id_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &bgp_cluster_id32_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &no_bgp_cluster_id_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &no_bgp_cluster_id_val_cmd);

    /* "bgp client-to-client reflection" commands */
    if(cmdvec_init) install_element (CONFIG_NODE, &no_bgp_client_to_client_reflection_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &bgp_client_to_client_reflection_cmd);

    /* "bgp always-compare-med" commands */
    if(cmdvec_init) install_element (CONFIG_NODE, &bgp_always_compare_med_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &no_bgp_always_compare_med_cmd);

    /* "bgp deterministic-med" commands */
    if(cmdvec_init) install_element (CONFIG_NODE, &bgp_deterministic_med_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &no_bgp_deterministic_med_cmd);

    /* "bgp enforce-first-as" commands */
    if(cmdvec_init) install_element (CONFIG_NODE, &bgp_enforce_first_as_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &no_bgp_enforce_first_as_cmd);

    /* "bgp bestpath compare-routerid" commands */
    if(cmdvec_init) install_element (CONFIG_NODE, &bgp_bestpath_compare_router_id_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &no_bgp_bestpath_compare_router_id_cmd);

    /* "bgp bestpath as-path ignore" commands */
    if(cmdvec_init) install_element (CONFIG_NODE, &bgp_bestpath_aspath_ignore_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &no_bgp_bestpath_aspath_ignore_cmd);

    /* "bgp bestpath med" commands */
    if(cmdvec_init) install_element (CONFIG_NODE, &bgp_bestpath_med_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &bgp_bestpath_med2_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &bgp_bestpath_med3_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &no_bgp_bestpath_med_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &no_bgp_bestpath_med2_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &no_bgp_bestpath_med3_cmd);

    /* "bgp default local-preference" commands. */
    if(cmdvec_init) install_element (CONFIG_NODE, &bgp_default_local_preference_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &no_bgp_default_local_preference_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &no_bgp_default_local_preference_val_cmd);

    /* "router bgp" commands. */
    if(cmdvec_init) install_element (CONFIG_NODE, &router_bgp_cmd);

    /* "no router bgp" commands. */
    if(cmdvec_init) install_element (CONFIG_NODE, &no_router_bgp_cmd);

    /* "neighbor remote-as" commands. */
    if(cmdvec_init) install_element (CONFIG_NODE, &neighbor_remote_as_cmd);

    if(cmdvec_init) install_element (CONFIG_NODE, &neighbor_activate_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &no_neighbor_activate_cmd);

    /* "no neighbor remote-as" commands. */
    if(cmdvec_init) install_element (CONFIG_NODE, &no_neighbor_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &no_neighbor_remote_as_cmd);

    /* "neighbor passive" commands. */
    if(cmdvec_init) install_element (CONFIG_NODE, &neighbor_passive_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &no_neighbor_passive_cmd);

    /* "neighbor shutdown" commands. */
    if(cmdvec_init) install_element (CONFIG_NODE, &neighbor_shutdown_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &no_neighbor_shutdown_cmd);

    /* "neighbor ebgp-multihop" commands. */
    /* all connections are multihop, since ttl is not set to 1 */ 
    if(0) install_element (CONFIG_NODE, &neighbor_ebgp_multihop_cmd);
    if(0) install_element (CONFIG_NODE, &neighbor_ebgp_multihop_ttl_cmd);
    if(0) install_element (CONFIG_NODE, &no_neighbor_ebgp_multihop_cmd);
    if(0) install_element (CONFIG_NODE, &no_neighbor_ebgp_multihop_ttl_cmd);

    /* "neighbor description" commands. */
    if(cmdvec_init) install_element (CONFIG_NODE, &neighbor_description_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &no_neighbor_description_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &no_neighbor_description_val_cmd);

    /* "neighbor version" commands. */
    if(cmdvec_init) install_element (CONFIG_NODE, &neighbor_version_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &no_neighbor_version_cmd);

    /* "neighbor next-hop-self" commands. */
    if(cmdvec_init) install_element (CONFIG_NODE, &neighbor_nexthop_self_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &no_neighbor_nexthop_self_cmd);

    /* "neighbor send-community" commands.*/
    if(cmdvec_init) install_element (CONFIG_NODE, &neighbor_send_community_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &neighbor_send_community_type_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &no_neighbor_send_community_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &no_neighbor_send_community_type_cmd);

    /* "neighbor weight" commands. */
    if(cmdvec_init) install_element (CONFIG_NODE, &neighbor_weight_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &no_neighbor_weight_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &no_neighbor_weight_val_cmd);

    /* "neighbor softreconfiguration inbound" commands.*/
    if(cmdvec_init) install_element (CONFIG_NODE, &neighbor_soft_reconfiguration_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &no_neighbor_soft_reconfiguration_cmd);

    /* "neighbor route-reflector" commands.*/
    if(cmdvec_init) install_element (CONFIG_NODE, &neighbor_route_reflector_client_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &no_neighbor_route_reflector_client_cmd);

    /* "neighbor route-server" commands.*/
    if(cmdvec_init) install_element (CONFIG_NODE, &neighbor_route_server_client_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &no_neighbor_route_server_client_cmd);

    /* "neighbor capability route-refresh" commands.*/
    if(cmdvec_init) install_element (CONFIG_NODE, &neighbor_capability_route_refresh_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &no_neighbor_capability_route_refresh_cmd);

    /* "neighbor dont-capability-negotiate" commands. */
    if(cmdvec_init) install_element (CONFIG_NODE, &neighbor_dont_capability_negotiate_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &no_neighbor_dont_capability_negotiate_cmd);

    /* "neighbor override-capability" commands. */
    if(cmdvec_init) install_element (CONFIG_NODE, &neighbor_override_capability_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &no_neighbor_override_capability_cmd);

    /* "neighbor strict-capability-match" commands. */
    if(cmdvec_init) install_element (CONFIG_NODE, &neighbor_strict_capability_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &no_neighbor_strict_capability_cmd);

    /* "neighbor timers" commands. */
    if(cmdvec_init) install_element (CONFIG_NODE, &neighbor_timers_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &no_neighbor_timers_cmd);

    /* "neighbor timers connect" commands. */
    if(cmdvec_init) install_element (CONFIG_NODE, &neighbor_timers_connect_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &no_neighbor_timers_connect_cmd);

    /* Filters */
    if(cmdvec_init) install_element (CONFIG_NODE, &neighbor_prefix_list_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &no_neighbor_prefix_list_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &neighbor_filter_list_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &no_neighbor_filter_list_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &neighbor_route_map_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &no_neighbor_route_map_cmd);

    /* "neighbor maximum-prefix" commands. */
    if(cmdvec_init) install_element (CONFIG_NODE, &neighbor_maximum_prefix_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &no_neighbor_maximum_prefix_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &no_neighbor_maximum_prefix_val_cmd);

    /* "bgp confederation" commands. */
    if(cmdvec_init) install_element (CONFIG_NODE, &bgp_confederation_identifier_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &bgp_confederation_peers_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &no_bgp_confederation_identifier_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &no_bgp_confederation_peers_cmd);

    /* "transparent-as" commands. */
    if(cmdvec_init) install_element (CONFIG_NODE, &neighbor_transparent_as_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &no_neighbor_transparent_as_cmd);

    /* "transparent-nexthop" commands. */
    if(cmdvec_init) install_element (CONFIG_NODE, &neighbor_transparent_nexthop_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &no_neighbor_transparent_nexthop_cmd);

   /* MRAI commands. */
    if(cmdvec_init) install_element (CONFIG_NODE, &neighbor_advertise_interval_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &no_neighbor_advertise_interval_cmd);

    /* "show ip bgp summary" command. */
    if(cmdvec_init) install_element (CONFIG_NODE, &show_ip_bgp_summary_cmd);

    /* "show ip bgp neighbors" commands. */
    if(cmdvec_init) install_element (CONFIG_NODE, &show_ip_bgp_neighbors_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &show_ip_bgp_neighbors_peer_cmd);

    /* "show ip bgp paths" commands. */
    if(cmdvec_init) install_element (CONFIG_NODE, &show_ip_bgp_paths_cmd);

    /* "show ip bgp community" commands. */
    if(cmdvec_init) install_element (CONFIG_NODE, &show_ip_bgp_community_info_cmd);

    /* "show ip bgp attribute-info" commands. */
    if(cmdvec_init) install_element (CONFIG_NODE, &show_ip_bgp_attr_info_cmd);

    /* "clear ip bgp commands" */
    if(cmdvec_init) install_element (CONFIG_NODE, &clear_ip_bgp_all_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &clear_ip_bgp_as_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &clear_ip_bgp_peer_cmd);

    /* "clear ip bgp neighbor soft in" */
    if(cmdvec_init) install_element (CONFIG_NODE, &clear_ip_bgp_peer_soft_in_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &clear_ip_bgp_peer_in_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &clear_ip_bgp_as_soft_in_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &clear_ip_bgp_as_in_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &clear_ip_bgp_all_soft_in_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &clear_ip_bgp_all_in_cmd);


    /* "clear ip bgp neighbor soft out" */
    if(cmdvec_init) install_element (CONFIG_NODE, &clear_ip_bgp_peer_soft_out_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &clear_ip_bgp_peer_out_cmd);

    if(cmdvec_init) install_element (CONFIG_NODE, &clear_ip_bgp_as_soft_out_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &clear_ip_bgp_as_out_cmd);

    if(cmdvec_init) install_element (CONFIG_NODE, &clear_ip_bgp_all_soft_out_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &clear_ip_bgp_all_out_cmd);

    /* "clear ip bgp neighbor soft" */
    if(cmdvec_init) install_element (CONFIG_NODE, &clear_ip_bgp_peer_soft_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &clear_ip_bgp_as_soft_cmd);
    if(cmdvec_init) install_element (CONFIG_NODE, &clear_ip_bgp_all_soft_cmd);

    /* Make lists.  */
    bgp_list = list_new ();
    peer_list = list_new ();
    peer_list->cmp = (int (Bgp::*)(void *, void *)) &Bgp::peer_list_cmp;

    dummy_peer_list = list_new ();
    dummy_peer_list->cmp = (int (Bgp::*)(void *, void *)) &Bgp::peer_list_cmp;

    /* BGP inits. */
    if(bgp_attr_initialize)bgp_attr_init ();
    Bgp::bgp_attr_initialize = 0;
    if(cmdvec_init)bgp_debug_init ();
    bgp_dump_init ();
    bgp_route_init ();

    if(cmdvec_init) bgp_route_map_init ();
    route_map_add_hook (&Bgp::bgp_route_map_update);
    route_map_delete_hook (&Bgp::bgp_route_map_update);


    /* Access list initialize. */
    if(cmdvec_init)access_list_init ();
    access_list_add_hook (&Bgp::bgp_distribute_update);
    access_list_delete_hook (&Bgp::bgp_distribute_update);

    /* Filter list initialize. */
    if(cmdvec_init)bgp_filter_init ();
    as_list_add_hook (&Bgp::bgp_aslist_update);
    as_list_delete_hook (&Bgp::bgp_aslist_update);

    /* Prefix list initialize.*/
    if(cmdvec_init) prefix_list_init ();
    prefix_list_add_hook (&Bgp::bgp_prefix_list_update);
    prefix_list_delete_hook (&Bgp::bgp_prefix_list_update);

    /* Community list initialize. */
    if(cmdvec_init) community_list_init ();

#ifndef HAVE_ZEBRA_93b
    bgp_damp_disable (NULL);
#endif
}



////////////////////////////////////////////////
////////////////////////////////////////////////
/////////////////buffer.c///////////////////////
////////////////////////////////////////////////

/* Make buffer data. */
struct buffer_data *
Bgp::buffer_data_new (size_t size)
{
  struct buffer_data *d;

  d = ( struct buffer_data * ) XMALLOC (MTYPE_BUFFER_DATA, sizeof (struct buffer_data));
  memset (d, 0, sizeof (struct buffer_data));
  d->data = ( unsigned char * ) XMALLOC (MTYPE_BUFFER_DATA, size);
  
  return d;
}

void
Bgp::buffer_data_free (struct buffer_data *d)
{
    if (d->data)
        XFREE (MTYPE_BUFFER_DATA, d->data);
    XFREE (MTYPE_BUFFER_DATA, d);
}

/* Make New buffer. */
struct buffer *
Bgp::buffer_new (size_t size)
{
    struct buffer *b;

    b = ( struct buffer * ) XMALLOC (MTYPE_BUFFER, sizeof (struct buffer));
    memset (b, 0, sizeof (struct buffer));

    b->size = size;

    return b;
}

/* Free buffer. */
void
Bgp::buffer_free (struct buffer *b)
{
    struct buffer_data *d;
    struct buffer_data *next;

    d = b->head;
    while (d)
    {
        next = d->next;
        buffer_data_free (d);
        d = next;
    }

    d = b->unused_head;
    while (d)
    {
        next = d->next;
        buffer_data_free (d);
        d = next;
    }

    XFREE (MTYPE_BUFFER, b);
}

/* Make string clone. */
char *
Bgp::buffer_getstr (struct buffer *b)
{
    return strdup ((char *)b->head->data);
}

/* Return 1 if buffer is empty. */
int
Bgp::buffer_empty (struct buffer *b)
{
    if (b->tail == NULL || b->tail->cp == b->tail->sp)
        return 1;
    else
        return 0;
}

/* Clear and free all allocated data. */
void
Bgp::buffer_reset (struct buffer *b)
{
    struct buffer_data *data;
    struct buffer_data *next;

    for (data = b->head; data; data = next)
    {
        next = data->next;
        buffer_data_free (data);
    }
    b->head = b->tail = NULL;
    b->alloc = 0;
    b->length = 0;
}

/* Add buffer_data to the end of buffer. */
void
Bgp::buffer_add (struct buffer *b)
{
    struct buffer_data *d;

    d = buffer_data_new (b->size);

    if (b->tail == NULL)
    {
        d->prev = NULL;
        d->next = NULL;
        b->head = d;
        b->tail = d;
    } else
    {
        d->prev = b->tail;
        d->next = NULL;

        b->tail->next = d;
        b->tail = d;
    }

    b->alloc++;
}

/* Write data to buffer. */
int
Bgp::buffer_write (struct buffer *b, u_char *ptr, size_t size)
{
    struct buffer_data *data;

    data = b->tail;
    b->length += size;

    /* We use even last one byte of data buffer. */
    while (size)
    {
        /* If there is no data buffer add it. */
        if (data == NULL || data->cp == b->size)
        {
            buffer_add (b);
            data = b->tail;
        }

        /* Last data. */
        if (size <= (b->size - data->cp))
        {
            memcpy ((data->data + data->cp), ptr, size);

            data->cp += size;
            size = 0;
        } else
        {
            memcpy ((data->data + data->cp), ptr, (b->size - data->cp));

            size -= (b->size - data->cp);
            ptr += (b->size - data->cp);

            data->cp = b->size;
        }
    }
    return 1;
}

/* Insert character into the buffer. */
int
Bgp::buffer_putc (struct buffer *b, u_char c)
{
    buffer_write (b, &c, 1);
    return 1;
}

/* Insert word (2 octets) into ther buffer. */
int
Bgp::buffer_putw (struct buffer *b, u_short c)
{
    buffer_write (b, (u_char *)&c, 2);
    return 1;
}

/* Put string to the buffer. */
int
Bgp::buffer_putstr (struct buffer *b, u_char *c)
{
    size_t size;

    size = strlen ((char *)c);
    buffer_write (b, c, size);
    return 1;
}

/* Flush specified size to the fd. */
void
Bgp::buffer_flush (struct buffer *b, int fd, size_t size)
{
    int iov_index;
    struct iovec *iovec;
    struct buffer_data *data;
    struct buffer_data *out;
    struct buffer_data *next;

    iovec = ( struct iovec * ) malloc (sizeof (struct iovec) * b->alloc);
    iov_index = 0;

    for (data = b->head; data; data = data->next)
    {
        iovec[iov_index].iov_base = (char *)(data->data + data->sp);

        if (size <= (data->cp - data->sp))
        {
            iovec[iov_index++].iov_len = size;
            data->sp += size;
            if (data->sp == data->cp)
                data = data->next;
            break;
        } else
        {
            iovec[iov_index++].iov_len = data->cp - data->sp;
            size -= data->cp - data->sp;
            data->sp = data->cp;
        }
    }

    /* Write buffer to the fd. */
    writev (fd, iovec, iov_index);

    /* Free printed buffer data. */
    for (out = b->head; out && out != data; out = next)
    {
        next = out->next;
        if (next)
            next->prev = NULL;
        else
            b->tail = next;
        b->head = next;

        buffer_data_free (out);
        b->alloc--;
    }

    free (iovec);
}

/* Flush all buffer to the fd. */
int
Bgp::buffer_flush_all (struct buffer *b, int fd)
{
    int ret;
    struct buffer_data *d;
    int iov_index;
    struct iovec *iovec;

    if (buffer_empty(b))
        return 0;

    iovec =( struct iovec * )  malloc (sizeof (struct iovec) * b->alloc);
    iov_index = 0;

    for (d = b->head; d; d = d->next)
    {
        iovec[iov_index].iov_base = (char *)(d->data + d->sp);
        iovec[iov_index].iov_len = d->cp - d->sp;
        iov_index++;
    }
    ret = writev (fd, iovec, iov_index);

    free (iovec);

    buffer_reset (b);

    return ret;
}

////////////////////////////////////////////////
////////////////////////////////////////////////
////command.c///////////////////////////////////
////////////////////////////////////////////////

/* Install top node of command vector. */
void
Bgp::install_node (struct cmd_node *node, 
                   int (Bgp::*func) (struct vty *))
{

    vector_set_index (cmdvec, node->node, node);

    node->func = func;

    node->cmd_vector = vector_init (VECTOR_MIN_SIZE);

}

/* Compare two command's string.  Used in sort_node (). */
int
Bgp::cmp_node (const void *p, const void *q)
{
    struct cmd_element *a = *(struct cmd_element **)p;
    struct cmd_element *b = *(struct cmd_element **)q;

    return strcmp (a->string, b->string);
}

int
Bgp::cmp_desc (const void *p, const void *q)
{
    struct desc *a = *(struct desc **)p;
    struct desc *b = *(struct desc **)q;

    return strcmp (a->cmd, b->cmd);
}

/* Sort each node's command element according to command string. */
void
Bgp::sort_node ()
{
    int i, j;
    struct cmd_node *cnode;
    struct _vector* descvec;
    struct cmd_element *cmd_element;

    for (i = 0; i < vector_max (cmdvec); i++)
        if ((cnode = ( struct cmd_node * )  vector_slot (cmdvec, i)) != NULL)
        {
            struct _vector* cmd_vector = cnode->cmd_vector;
            qsort (cmd_vector->index, cmd_vector->max, sizeof (void *),Bgp::cmp_node);

            for (j = 0; j < vector_max (cmd_vector); j++)
                if ((cmd_element = ( struct cmd_element * ) vector_slot (cmd_vector, j)) != NULL)
                {
                    descvec = ( struct _vector * )  vector_slot (cmd_element->strvec,
                                                                 vector_max (cmd_element->strvec) - 1);
                    qsort (descvec->index, descvec->max, sizeof (void *), Bgp::cmp_desc);
                }
        }

}

/* Breaking up string into each command piece. I assume given
   character is separated by a space character. Return value is a
   vector which includes char ** data element. */
struct _vector*
Bgp::cmd_make_strvec (char *string)
{
    char *cp, *start, *token;
    int strlen;
    struct _vector* strvec;

    if (string == NULL)
        return NULL;

    cp = string;

    /* Skip white spaces. */
    while (isspace ((int) *cp) && *cp != '\0')
        cp++;

    /* Return if there is only white spaces */
    if (*cp == '\0')
        return NULL;

    if (*cp == '!' || *cp == '#')
        return NULL;

    /* Prepare return vector. */
    strvec = vector_init (VECTOR_MIN_SIZE);

    /* Copy each command piece and set into vector. */
    while (1)
    {
        start = cp;
        while (!(isspace ((int) *cp) || *cp == '\r' || *cp == '\n') &&
               *cp != '\0')
            cp++;
        strlen = cp - start;
        token = ( char * ) XMALLOC (MTYPE_STRVEC, strlen + 1);
        bcopy (start, token, strlen);
        *(token + strlen) = '\0';
        vector_set (strvec, token);

        while ((isspace ((int) *cp) || *cp == '\n' || *cp == '\r') &&
               *cp != '\0')
            cp++;

        if (*cp == '\0' || *cp == '!' || *cp == '#')
            return strvec;
    }
}

/* Free allocated string vector. */
void
Bgp::cmd_free_strvec (struct _vector* v)
{
    int i;
    char *cp;

    if (!v)
        return;

    for (i = 0; i < vector_max (v); i++)
        if ((cp = ( char * ) vector_slot (v, i)) != NULL)
            XFREE (MTYPE_STRVEC, cp);

    vector_free (v);
}

/* Fetch next description.  Used in cmd_make_descvec(). */
char *
Bgp::cmd_desc_str (char **string)
{
    char *cp, *start, *token;
    int strlen;

    cp = *string;

    if (cp == NULL)
        return NULL;

    /* Skip white spaces. */
    while (isspace ((int) *cp) && *cp != '\0')
        cp++;

    /* Return if there is only white spaces */
    if (*cp == '\0')
        return NULL;

    start = cp;

    while (!(*cp == '\r' || *cp == '\n') && *cp != '\0')
        cp++;

    strlen = cp - start;
    token = ( char * ) XMALLOC (MTYPE_STRVEC, strlen + 1);
    bcopy (start, token, strlen);
    *(token + strlen) = '\0';

    *string = cp;

    return token;
}

/* New string vector. */
struct _vector*
Bgp::cmd_make_descvec (char *string, char *descstr)
{
    int multiple = 0;
    char *sp;
    char *token;
    int len;
    char *cp;
    char *dp;
    struct _vector* allvec;
    struct _vector* strvec = NULL;
    struct desc *desc;

    cp = string;
    dp = descstr;

    if (cp == NULL)
        return NULL;

    allvec = vector_init (VECTOR_MIN_SIZE);

    while (1)
    {
        while (isspace ((int) *cp) && *cp != '\0')
            cp++;

        if (*cp == '(')
        {
            multiple = 1;
            cp++;
        }
        if (*cp == ')')
        {
            multiple = 0;
            cp++;
        }
        if (*cp == '|')
        {
            if (! multiple)
            {
                fprintf (stderr, "Command parse error!: %s\n", string);
                exit (1);
            }
            cp++;
        }

        while (isspace ((int) *cp) && *cp != '\0')
            cp++;

        if (*cp == '(')
        {
            multiple = 1;
            cp++;
        }

        if (*cp == '\0')
            return allvec;

        sp = cp;

        while (! (isspace ((int) *cp) || *cp == '\r' || *cp == '\n' || *cp == ')' || *cp == '|') && *cp != '\0')
            cp++;

        len = cp - sp;

        token = ( char * ) XMALLOC (MTYPE_STRVEC, len + 1);
        memcpy (token, sp, len);
        *(token + len) = '\0';

        desc = ( struct desc * ) XMALLOC (MTYPE_DESC, sizeof (struct desc));
        desc->cmd = token;
        desc->str = cmd_desc_str (&dp);

        if (multiple)
        {
            if (multiple == 1)
            {
                strvec = vector_init (VECTOR_MIN_SIZE);
                vector_set (allvec, strvec);
            }
            multiple++;
        } else
        {
            strvec = vector_init (VECTOR_MIN_SIZE);
            vector_set (allvec, strvec);
        }
        vector_set (strvec, desc);
    }
}

/* Count mandantory string vector size.  This is to determine inputed
   command has enough command length. */
int
Bgp::cmd_cmdsize (struct _vector* strvec)
{
    int i;
    char *str;
    int size = 0;
    struct _vector* descvec;

    for (i = 0; i < vector_max (strvec); i++)
    {
        descvec = ( struct _vector * ) vector_slot (strvec, i);

        if (vector_max (descvec) == 1)
        {
            struct desc *desc = ( struct desc * ) vector_slot (descvec, 0);

            str = desc->cmd;

            if (str == NULL || CMD_OPTION (str))
                return size;
            else
                size++;
        } else
            size++;
    }
    return size;
}

/* Return prompt character of specified node. */
char *
Bgp::cmd_prompt (enum node_type node)
{
    struct cmd_node *cnode;

    cnode = ( struct cmd_node * ) vector_slot (cmdvec, node);
    return cnode->prompt;
}

/* Install a command into a node. */
void
Bgp::install_element (enum node_type ntype, struct cmd_element *cmd)
{
    struct cmd_node *cnode;

    cnode = ( struct cmd_node * ) vector_slot (cmdvec, ntype);


    if (cnode == NULL)
    {
        fprintf (stderr, "Command node %d doesnt exist, please check it\n",
                 ntype);
        exit (1);
    }


    vector_set (cnode->cmd_vector, cmd);


    cmd->strvec = cmd_make_descvec (cmd->string, cmd->doc);


    cmd->cmdsize = cmd_cmdsize (cmd->strvec);



}

static unsigned char itoa64[] = 
"./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";

void
Bgp::to64(char *s, long v, int n)
{
    while (--n >= 0)
    {
        *s++ = itoa64[v&0x3f];
        v >>= 6;
    }
}

/* This function write configuration of this host. */
int
Bgp::config_write_host (struct vty *vty)
{
    if (host.name)
       vty_out (zlog_default,LOG_DEBUG, "hostname %s%s", host.name, VTY_NEWLINE);

    if (host.encrypt)
    {
        if (host.password_encrypt)
           vty_out (zlog_default,LOG_DEBUG, "password 8 %s%s", host.password_encrypt, VTY_NEWLINE);
        if (host.enable_encrypt)
           vty_out (zlog_default,LOG_DEBUG, "enable password 8 %s%s", host.enable_encrypt, VTY_NEWLINE);
    } else
    {
        if (host.password)
           vty_out (zlog_default,LOG_DEBUG, "password %s%s", host.password, VTY_NEWLINE);
        if (host.enable)
           vty_out (zlog_default,LOG_DEBUG, "enable password %s%s", host.enable, VTY_NEWLINE);
    }

    if (host.logfile)
       vty_out (zlog_default,LOG_DEBUG, "log file %s%s", host.logfile, VTY_NEWLINE);

    if (host.log_stdout)
       vty_out (zlog_default,LOG_DEBUG, "log stdout%s", VTY_NEWLINE);

    if (host.log_syslog)
       vty_out (zlog_default,LOG_DEBUG, "log syslog%s", VTY_NEWLINE);

    if (zlog_default->maskpri != LOG_DEBUG)
       vty_out (zlog_default,LOG_DEBUG, "log trap %s%s", zlog_priority[zlog_default->maskpri], VTY_NEWLINE);

    if (zlog_default->record_priority == 1)
       vty_out (zlog_default,LOG_DEBUG, "log record-priority%s", VTY_NEWLINE);

    if (host.encrypt)
       vty_out (zlog_default,LOG_DEBUG, "service password-encryption%s", VTY_NEWLINE);

    if (host.lines >= 0)
       vty_out (zlog_default,LOG_DEBUG, "service terminal-length %d%s", host.lines,
                 VTY_NEWLINE);

    return 1;
}

/* Utility function for getting command vector. */
struct _vector*
Bgp::cmd_node_vector (struct _vector* v, enum node_type ntype)
{
    struct cmd_node *cnode = ( cmd_node * ) vector_slot (v, ntype);
    return cnode->cmd_vector;
}

/* Filter command vector by symbol */
int
Bgp::cmd_filter_by_symbol (char *command, char *symbol)
{
    int i, lim;

    if (strcmp (symbol, "IPV4_ADDRESS") == 0)
    {
        i = 0;
        lim = strlen (command);
        while (i < lim)
        {
            if (! (isdigit ((int) command[i]) || command[i] == '.' || command[i] == '/'))
                return 1;
            i++;
        }
        return 0;
    }
    if (strcmp (symbol, "STRING") == 0)
    {
        i = 0;
        lim = strlen (command);
        while (i < lim)
        {
            if (! (isalpha ((int) command[i]) || command[i] == '_' || command[i] == '-'))
                return 1;
            i++;
        }
        return 0;
    }
    if (strcmp (symbol, "IFNAME") == 0)
    {
        i = 0;
        lim = strlen (command);
        while (i < lim)
        {
            if (! isalnum ((int) command[i]))
                return 1;
            i++;
        }
        return 0;
    }
    return 0;
}



enum match_type
Bgp::cmd_ipv4_match (char *str)
{
    char *sp;
    int dots = 0, nums = 0;
    char buf[4];

    if (str == NULL)
        return partly_match;

    for (;;)
    {
        bzero (buf, sizeof (buf));
        sp = str;
        while (*str != '\0')
        {
            if (*str == '.')
            {
                if (dots >= 3)
                    return no_match;

                if (*(str + 1) == '.')
                    return no_match;

                if (*(str + 1) == '\0')
                    return partly_match;

                dots++;
                break;
            }
            if (!isdigit ((int) *str))
                return no_match;

            str++;
        }

        if (str - sp > 3)
            return no_match;

        strncpy (buf, sp, str - sp);
        if (atoi (buf) > 255)
            return no_match;

        nums++;

        if (*str == '\0')
            break;

        str++;
    }

    if (nums < 4)
        return partly_match;

    return exact_match;
}

enum match_type
Bgp::cmd_ipv4_prefix_match (char *str)
{
    char *sp;
    int dots = 0;
    char buf[4];

    if (str == NULL)
        return partly_match;

    for (;;)
    {
        bzero (buf, sizeof (buf));
        sp = str;
        while (*str != '\0' && *str != '/')
        {
            if (*str == '.')
            {
                if (dots == 3)
                    return no_match;

                if (*(str + 1) == '.' || *(str + 1) == '/')
                    return no_match;

                if (*(str + 1) == '\0')
                    return partly_match;

                dots++;
                break;
            }

            if (!isdigit ((int) *str))
                return no_match;

            str++;
        }

        if (str - sp > 3)
            return no_match;

        strncpy (buf, sp, str - sp);
        if (atoi (buf) > 255)
            return no_match;

        if (dots == 3)
        {
            if (*str    ==    '/')
            {
                if (*(str + 1) == '\0')
                    return partly_match;

                str++;
                break;
            } else if (*str == '\0')
                return partly_match;
        }

        if (*str == '\0')
            return partly_match;

        str++;
    }

    sp = str;
    while (*str != '\0')
    {
        if (!isdigit ((int) *str))
            return no_match;

        str++;
    }

    if (atoi (sp) > 32)
        return no_match;

    return exact_match;
}

enum match_type
Bgp::cmd_ipv6_match (char *str)
{
    int state = STATE_START;
    int colons = 0, nums = 0, double_colon = 0;
    char *sp = NULL;

    if (str == NULL)
        return partly_match;

    if (strspn (str, IPV6_ADDR_STR) != strlen (str))
        return no_match;

    while (*str != '\0')
    {
        switch (state)
        {
        case STATE_START:
            if (*str == ':')
            {
                if (*(str + 1) != ':' && *(str + 1) != '\0')
                    return no_match;
                colons--;
                state = STATE_COLON;
            } else
            {
                sp = str;
                state = STATE_ADDR;
            }

            continue;
        case STATE_COLON:
            colons++;
            if (*(str + 1) == ':')
                state = STATE_DOUBLE;
            else
            {
                sp = str + 1;
                state = STATE_ADDR;
            }
            break;
        case STATE_DOUBLE:
            if (double_colon)
                return no_match;

            if (*(str + 1) == ':')
                return no_match;
            else
            {
                if (*(str + 1) != '\0')
                    colons++;
                sp = str + 1;
                state = STATE_ADDR;
            }

            double_colon++;
            nums++;
            break;
        case STATE_ADDR:
            if (*(str + 1) == ':' || *(str + 1) == '\0')
            {
                if (str - sp > 3)
                    return no_match;

                nums++;
                state = STATE_COLON;
            }
            if (*(str + 1) == '.')
                state = STATE_DOT;
            break;
        case STATE_DOT:
            state = STATE_ADDR;
            break;
        default:
            break;
        }

        if (nums > 8)
            return no_match;

        if (colons > 7)
            return no_match;

        str++;
    }

#if 0
    if (nums < 11)
        return partly_match;
#endif /* 0 */

    return exact_match;
}

enum match_type
Bgp::cmd_ipv6_prefix_match (char *str)
{
    int state = STATE_START;
    int colons = 0, nums = 0, double_colon = 0;
    int mask;
    char *sp = NULL;
    char *endptr = NULL;

    if (str == NULL)
        return partly_match;

    if (strspn (str, IPV6_PREFIX_STR) != strlen (str))
        return no_match;

    while (*str != '\0' && state != STATE_MASK)
    {
        switch (state)
        {
        case STATE_START:
            if (*str == ':')
            {
                if (*(str + 1) != ':' && *(str + 1) != '\0')
                    return no_match;
                colons--;
                state = STATE_COLON;
            } else
            {
                sp = str;
                state = STATE_ADDR;
            }

            continue;
        case STATE_COLON:
            colons++;
            if (*(str + 1) == '/')
                return no_match;
            else if (*(str + 1) == ':')
                state = STATE_DOUBLE;
            else
            {
                sp = str + 1;
                state = STATE_ADDR;
            }
            break;
        case STATE_DOUBLE:
            if (double_colon)
                return no_match;

            if (*(str + 1) == ':')
                return no_match;
            else
            {
                if (*(str + 1) != '\0' && *(str + 1) != '/')
                    colons++;
                sp = str + 1;

                if (*(str + 1) == '/')
                    state = STATE_SLASH;
                else
                    state = STATE_ADDR;
            }

            double_colon++;
            nums += 1;
            break;
        case STATE_ADDR:
            if (*(str + 1) == ':' || *(str + 1) == '.'
                || *(str + 1) == '\0' || *(str + 1) == '/')
            {
                if (str - sp > 3)
                    return no_match;

                for (; sp <= str; sp++)
                    if (*sp == '/')
                        return no_match;

                nums++;

                if (*(str + 1) == ':')
                    state = STATE_COLON;
                else if (*(str + 1) == '.')
                    state = STATE_DOT;
                else if (*(str + 1) == '/')
                    state = STATE_SLASH;
            }
            break;
        case STATE_DOT:
            state = STATE_ADDR;
            break;
        case STATE_SLASH:
            if (*(str + 1) == '\0')
                return partly_match;

            state = STATE_MASK;
            break;
        default:
            break;
        }

        if (nums > 11)
            return no_match;

        if (colons > 7)
            return no_match;

        str++;
    }

    if (state < STATE_MASK)
        return partly_match;

    mask = strtol (str, &endptr, 10);
    if (*endptr != '\0')
        return no_match;

    if (mask < 0 || mask > 128)
        return no_match;

/* I don't know why mask < 13 makes command match partly.
   Forgive me to make this comments. I Want to set static default route
   because of lack of function to originate default in ospf6d; sorry
       yasu
  if (mask < 13)
    return partly_match;
*/

    return exact_match;
}


int
Bgp::cmd_range_match (char *range, char *str)
{
    char *p;
    char buf[DECIMAL_STRLEN_MAX + 1];
    char *endptr = NULL;
    unsigned long min, max, val;

    if (str == NULL)
        return 1;

    val = strtoul (str, &endptr, 10);
    if (*endptr != '\0')
        return 0;

    range++;
    p = strchr (range, '-');
    if (p == NULL)
        return 0;
    if (p - range > DECIMAL_STRLEN_MAX)
        return 0;
    strncpy (buf, range, p - range);
    buf[p - range] = '\0';
    min = strtoul (buf, &endptr, 10);
    if (*endptr != '\0')
        return 0;

    range = p + 1;
    p = strchr (range, '>');
    if (p == NULL)
        return 0;
    if (p - range > DECIMAL_STRLEN_MAX)
        return 0;
    strncpy (buf, range, p - range);
    buf[p - range] = '\0';
    max = strtoul (buf, &endptr, 10);
    if (*endptr != '\0')
        return 0;

    if (val < min || val > max)
        return 0;

    return 1;
}

/* Make completion match and return match type flag. */
enum match_type
Bgp::cmd_filter_by_completion (char *command, struct _vector* v, int index)
{
    int i;
    char *str;
    struct cmd_element *cmd_element;
    enum match_type match_type;
    struct _vector* descvec;
    struct desc *desc;

    match_type = no_match;

    /* If command and cmd_element string does not match set NULL to vector */
    for (i = 0; i < vector_max (v); i++)
        if ((cmd_element = ( struct cmd_element * ) vector_slot (v, i)) != NULL)
        {
            if (index >= vector_max (cmd_element->strvec))
                vector_slot (v, i) = NULL;
            else
            {
                int j;
                int matched = 0;

                descvec = ( struct _vector * ) vector_slot (cmd_element->strvec, index);

                for (j = 0; j < vector_max (descvec); j++)
                {
                    desc = ( struct desc* ) vector_slot (descvec, j);
                    str = desc->cmd;

                    if (CMD_VARARG (str))
                    {
                        if (match_type < vararg_match)
                            match_type = vararg_match;
                        matched++;
                    } else if (CMD_RANGE (str))
                    {
                        if (cmd_range_match (str, command))
                        {
                            if (match_type < range_match)
                                match_type = range_match;

                            matched++;
                        }
                    } else if (CMD_IPV6 (str))
                    {
                        if (cmd_ipv6_match (command))
                        {
                            if (match_type < ipv6_match)
                                match_type = ipv6_match;

                            matched++;
                        }
                    } else if (CMD_IPV6_PREFIX (str))
                    {
                        if (cmd_ipv6_prefix_match (command))
                        {
                            if (match_type < ipv6_prefix_match)
                                match_type = ipv6_prefix_match;

                            matched++;
                        }
                    } else if (CMD_IPV4 (str))
                    {
                        if (cmd_ipv4_match (command))
                        {
                            if (match_type < ipv4_match)
                                match_type = ipv4_match;

                            matched++;
                        }
                    } else if (CMD_IPV4_PREFIX (str))
                    {
                        if (cmd_ipv4_prefix_match (command))
                        {
                            if (match_type < ipv4_prefix_match)
                                match_type = ipv4_prefix_match;
                            matched++;
                        }
                    } else
                        /* Check is this point's argument optional ? */
                        if (CMD_OPTION (str) || CMD_VARIABLE (str))
                    {
                        if (match_type < extend_match)
                            match_type = extend_match;
                        matched++;
                    } else if (strncmp (command, str, strlen (command)) == 0)
                    {
                        if (strcmp (command, str) == 0)
                            match_type = exact_match;
                        else
                        {
                            if (match_type < partly_match)
                                match_type = partly_match;
                        }
                        matched++;
                    }
                }
                if (! matched)
                    vector_slot (v, i) = NULL;
            }
        }
    return match_type;
}

/* Filter vector by command character with index. */
enum match_type
Bgp::cmd_filter_by_string (char *command, struct _vector* v, int index)
{
    int i;
    char *str;
    struct cmd_element *cmd_element;
    enum match_type match_type;
    struct _vector* descvec;
    struct desc *desc;

    match_type = no_match;

    /* If command and cmd_element string does not match set NULL to vector */
    for (i = 0; i < vector_max (v); i++)
        if ((cmd_element = ( struct cmd_element * )vector_slot (v, i)) != NULL)
        {
            /* If given index is bigger than max string vector of command,
                   set NULL*/
            if (index >= vector_max (cmd_element->strvec))
                vector_slot (v, i) = NULL;
            else
            {
                int j;
                int matched = 0;

                descvec = ( struct _vector * ) vector_slot (cmd_element->strvec, index);

                for (j = 0; j < vector_max (descvec); j++)
                {
                    desc = ( struct desc * ) vector_slot (descvec, j);
                    str = desc->cmd;

                    if (CMD_VARARG (str))
                    {
                        if (match_type < vararg_match)
                            match_type = vararg_match;
                        matched++;
                    } else if (CMD_RANGE (str))
                    {
                        if (cmd_range_match (str, command))
                        {
                            if (match_type < range_match)
                                match_type = range_match;
                            matched++;
                        }
                    } else if (CMD_IPV6 (str))
                    {
                        if (cmd_ipv6_match (command) == exact_match)
                        {
                            if (match_type < ipv6_match)
                                match_type = ipv6_match;
                            matched++;
                        }
                    } else if (CMD_IPV6_PREFIX (str))
                    {
                        if (cmd_ipv6_prefix_match (command) == exact_match)
                        {
                            if (match_type < ipv6_prefix_match)
                                match_type = ipv6_prefix_match;
                            matched++;
                        }
                    } else if (CMD_IPV4 (str))
                    {
                        if (cmd_ipv4_match (command) == exact_match)
                        {
                            if (match_type < ipv4_match)
                                match_type = ipv4_match;
                            matched++;
                        }
                    } else if (CMD_IPV4_PREFIX (str))
                    {
                        if (cmd_ipv4_prefix_match (command) == exact_match)
                        {
                            if (match_type < ipv4_prefix_match)
                                match_type = ipv4_prefix_match;
                            matched++;
                        }
                    } else if (CMD_OPTION (str) || CMD_VARIABLE (str))
                    {
                        if (match_type < extend_match)
                            match_type = extend_match;
                        matched++;
                    } else
                    {
                        if (strcmp (command, str) == 0)
                        {
                            match_type = exact_match;
                            matched++;
                        }
                    }
                }
                if (! matched)
                    vector_slot (v, i) = NULL;
            }
        }
    return match_type;
}

/* Check ambiguous match */
int
Bgp::is_cmd_ambiguous (char *command, struct _vector* v, int index, enum match_type type)
{
    int i;
    int j;
    char *str = NULL;
    struct cmd_element *cmd_element;
    char *matched = NULL;
    struct _vector* descvec;
    struct desc *desc;

    for (i = 0; i < vector_max (v); i++)
        if ((cmd_element =( struct cmd_element * ) vector_slot (v, i)) != NULL)
        {
            int match = 0;

            descvec = ( struct _vector * ) vector_slot (cmd_element->strvec, index);

            for (j = 0; j < vector_max (descvec); j++)
            {
                enum match_type ret;

                desc = ( struct desc * ) vector_slot (descvec, j);
                str = desc->cmd;

                switch (type)
                {
                case exact_match:
                    if (! (CMD_OPTION (str) || CMD_VARIABLE (str))
                        && strcmp (command, str) == 0)
                        match++;
                    break;
                case partly_match:
                    if (! (CMD_OPTION (str) || CMD_VARIABLE (str))
                        && strncmp (command, str, strlen (command)) == 0)
                    {
                        if (matched && strcmp (matched, str) != 0)
                            return 1; /* There is ambiguous match. */
                        else
                            matched = str;
                        match++;
                    }
                    break;
                case range_match:
                    if (cmd_range_match (str, command))
                    {
                        if (matched && strcmp (matched, str) != 0)
                            return 1;
                        else
                            matched = str;
                        match++;
                    }
                    break;
                case ipv6_match:
                    if (CMD_IPV6 (str))
                        match++;
                    break;
                case ipv6_prefix_match:
                    if ((ret = cmd_ipv6_prefix_match (command)) != no_match)
                    {
                        if (ret == partly_match)
                            return 2; /* There is incomplete match. */

                        match++;
                    }
                    break;
                case ipv4_match:
                    if (CMD_IPV4 (str))
                        match++;
                    break;
                case ipv4_prefix_match:
                    if ((ret = cmd_ipv4_prefix_match (command)) != no_match)
                    {
                        if (ret == partly_match)
                            return 2; /* There is incomplete match. */

                        match++;
                    }
                    break;
                case extend_match:
                    if (CMD_OPTION (str) || CMD_VARIABLE (str))
                        match++;
                    break;
                case no_match:
                default:
                    break;
                }
            }
            if (! match)
                vector_slot (v, i) = NULL;
        }
    return 0;
}

/* If src matches dst return dst string, otherwise return NULL */
char *
Bgp::cmd_entry_function (char *src, char *dst)
{
    /* Skip variable arguments. */
    if (CMD_OPTION (dst) || CMD_VARIABLE (dst) || CMD_VARARG (dst) ||
        CMD_IPV4 (dst) || CMD_IPV4_PREFIX (dst) || CMD_RANGE (dst))
        return NULL;

    /* In case of 'command \t', given src is NULL string. */
    if (src == NULL)
        return dst;

    /* Matched with input string. */
    if (strncmp (src, dst, strlen (src)) == 0)
        return dst;

    return NULL;
}

/* If src matches dst return dst string, otherwise return NULL */
/* This version will return the dst string always if it is
   CMD_VARIABLE for '?' key processing */
char *
Bgp::cmd_entry_function_desc (char *src, char *dst)
{
    if (CMD_VARARG (dst))
        return dst;

    if (CMD_RANGE (dst))
    {
        if (cmd_range_match (dst, src))
            return dst;
        else
            return NULL;
    }

    if (CMD_IPV6 (dst))
    {
        if (cmd_ipv6_match (src))
            return dst;
        else
            return NULL;
    }

    if (CMD_IPV6_PREFIX (dst))
    {
        if (cmd_ipv6_prefix_match (src))
            return dst;
        else
            return NULL;
    }

    if (CMD_IPV4 (dst))
    {
        if (cmd_ipv4_match (src))
            return dst;
        else
            return NULL;
    }

    if (CMD_IPV4_PREFIX (dst))
    {
        if (cmd_ipv4_prefix_match (src))
            return dst;
        else
            return NULL;
    }

    /* Optional or variable commands always match on '?' */
    if (CMD_OPTION (dst) || CMD_VARIABLE (dst))
        return dst;

    /* In case of 'command \t', given src is NULL string. */
    if (src == NULL)
        return dst;

    if (strncmp (src, dst, strlen (src)) == 0)
        return dst;
    else
        return NULL;
}

/* Check same string element existence.  If it isnt there return
    1. */
int
Bgp::cmd_unique_string (struct _vector* v, char *str)
{
    int i;
    char *match;

    for (i = 0; i < vector_max (v); i++)
        if ((match = ( char * ) vector_slot (v, i)) != NULL)
            if (strcmp (match, str) == 0)
                return 0;
    return 1;
}

/* Compare string to description vector.  If there is same string
   return 1 else return 0. */
int
Bgp::desc_unique_string (struct _vector* v, char *str)
{
    int i;
    struct desc *desc;

    for (i = 0; i < vector_max (v); i++)
        if ((desc = ( struct desc * ) vector_slot (v, i)) != NULL)
            if (strcmp (desc->cmd, str) == 0)
                return 1;
    return 0;
}

/* '?' describe command support. */
struct _vector*
Bgp::cmd_describe_command (struct _vector* vline, struct vty *vty, int *status)
{
    int i;
    struct _vector* cmd_vector;
#define INIT_MATCHVEC_SIZE 10
    struct _vector* matchvec;
    struct cmd_element *cmd_element;
    int index;
    static struct desc desc_cr = { "<cr>", ""};

    /* Set index. */
    index = vector_max (vline) - 1;

    /* Make copy vector of current node's command vector. */
    cmd_vector = vector_copy (cmd_node_vector (cmdvec, (enum node_type) vty->node));

    /* Prepare match vector */
    matchvec = vector_init (INIT_MATCHVEC_SIZE);

    /* Filter commands. */
    for (i = 0; i < index; i++)
    {
        enum match_type match;
        char *command;
        int ret;

        command = ( char * ) vector_slot (vline, i);

        match = cmd_filter_by_completion (command, cmd_vector, i);

        if (match == vararg_match)
        {
            struct cmd_element *cmd_element;
            struct _vector* descvec;
            int j, k;

            for (j = 0; j < vector_max (cmd_vector); j++)
                if ((cmd_element = ( struct cmd_element * ) vector_slot (cmd_vector, j)) != NULL)
                {
                    descvec = ( struct _vector * ) vector_slot (cmd_element->strvec,
                                                                vector_max (cmd_element->strvec) - 1);
                    for (k = 0; k < vector_max (descvec); k++)
                    {
                        struct desc *desc = ( struct desc * )  vector_slot (descvec, k);
                        vector_set (matchvec, desc);
                    }
                }

            vector_set (matchvec, &desc_cr);

            vector_free (cmd_vector);

            return matchvec;
        }

        if ((ret = is_cmd_ambiguous (command, cmd_vector, i, match)) == 1)
        {
            vector_free (cmd_vector);
            *status = CMD_ERR_AMBIGUOUS;
            return NULL;
        } else if (ret == 2)
        {
            vector_free (cmd_vector);
            *status = CMD_ERR_NO_MATCH;
            return NULL;
        }
    }

    /* Prepare match vector */
    /*  matchvec = vector_init (INIT_MATCHVEC_SIZE); */

    /* Make description vector. */
    for (i = 0; i < vector_max (cmd_vector); i++)
        if ((cmd_element = ( struct cmd_element * )vector_slot (cmd_vector, i)) != NULL)
        {
            char *string = NULL;
            struct _vector* strvec = cmd_element->strvec;

            if (index > vector_max (strvec))
                vector_slot (cmd_vector, i) = NULL;
            else
            {
                /* Check is command is completed. */
                if (index == vector_max (strvec))
                {
                    string = "<cr>";
                    if (! desc_unique_string (matchvec, string))
                        vector_set (matchvec, &desc_cr);
                } else
                {
                    int j;
                    struct _vector* descvec = ( struct _vector * ) vector_slot (strvec, index);
                    struct desc *desc;

                    for (j = 0; j < vector_max (descvec); j++)
                    {
                        desc = ( struct desc * ) vector_slot (descvec, j);
                        string = cmd_entry_function_desc (( char * ) vector_slot (vline, index), desc->cmd);
                        if (string)
                        {
                            /* Uniqueness check */
                            if (! desc_unique_string (matchvec, string))
                                vector_set (matchvec, desc);
                        }
                    }
                }
            }
        }
    vector_free (cmd_vector);

    if (vector_slot (matchvec, 0) == NULL)
    {
        vector_free (matchvec);
        *status= CMD_ERR_NO_MATCH;
    }

    return matchvec;
}

/* Check LCD of matched command. */
int
Bgp::cmd_lcd (char **matched)
{
    int i;
    int j;
    int lcd = -1;
    char *s1, *s2;
    char c1, c2;

    if (matched[0] == NULL || matched[1] == NULL)
        return 0;

    for (i = 1; matched[i] != NULL; i++)
    {
        s1 = matched[i - 1];
        s2 = matched[i];

        for (j = 0; (c1 = s1[j]) && (c2 = s2[j]); j++)
            if (c1 != c2)
                break;

        if (lcd < 0)
            lcd = j;
        else
        {
            if (lcd > j)
                lcd = j;
        }
    }
    return lcd;
}

/* Command line completion support. */
char **
Bgp::cmd_complete_command (struct _vector* vline, struct vty *vty, int *status)
{
    int i;
    struct _vector* cmd_vector = vector_copy (cmd_node_vector (cmdvec,(enum node_type)vty->node));
#define INIT_MATCHVEC_SIZE 10
    struct _vector* matchvec;
    struct cmd_element *cmd_element;
    int index = vector_max (vline) - 1;
    char **match_str;
    struct desc *desc;
    struct _vector* descvec;
    char *command;
    int lcd;

    /* First, filter by preceeding command string */
    for (i = 0; i < index; i++)
    {
        enum match_type match;
        int ret;

        command = ( char * ) vector_slot (vline, i);

        /* First try completion match, if there is exactly match return 1 */
        match = cmd_filter_by_completion (command, cmd_vector, i);

        /* If there is exact match then filter ambiguous match else check
       ambiguousness. */
        if ((ret = is_cmd_ambiguous (command, cmd_vector, i, match)) == 1)
        {
            vector_free (cmd_vector);
            *status = CMD_ERR_AMBIGUOUS;
            return NULL;
        }
        /*
      else if (ret == 2)
      {
        vector_free (cmd_vector);
        *status = CMD_ERR_NO_MATCH;
        return NULL;
      }
        */
    }

    /* Prepare match vector. */
    matchvec = vector_init (INIT_MATCHVEC_SIZE);

    /* Now we got into completion */
    for (i = 0; i < vector_max (cmd_vector); i++)
        if ((cmd_element = ( struct cmd_element * ) vector_slot (cmd_vector, i)) != NULL)
        {
            char *string;
            struct _vector* strvec = cmd_element->strvec;

            /* Check field length */
            if (index >= vector_max (strvec))
                vector_slot (cmd_vector, i) = NULL;
            else
            {
                int j;

                descvec = ( struct _vector * ) vector_slot (strvec, index);
                for (j = 0; j < vector_max (descvec); j++)
                {
                    desc = ( struct desc * ) vector_slot (descvec, j);

                    if ((string = cmd_entry_function ((char * ) vector_slot (vline, index),
                                                      desc->cmd)))
                        if (cmd_unique_string (matchvec, string))
                            vector_set (matchvec, XSTRDUP (MTYPE_TMP, string));
                }
            }
        }

        /* We don't need cmd_vector any more. */
    vector_free (cmd_vector);

    /* No matched command */
    if (vector_slot (matchvec, 0) == NULL)
    {
        vector_free (matchvec);

        /* In case of 'command \t' pattern.  Do you need '?' command at
           the end of the line. */
        if (vector_slot (vline, index) == '\0')
            *status = CMD_ERR_NOTHING_TODO;
        else
            *status = CMD_ERR_NO_MATCH;
        return NULL;
    }

    /* Only one matched */
    if (vector_slot (matchvec, 1) == NULL)
    {
        match_str = (char **) matchvec->index;
        vector_only_wrapper_free (matchvec);
        *status = CMD_COMPLETE_FULL_MATCH;
        return match_str;
    }
    /* Make it sure last element is NULL. */
    vector_set (matchvec, NULL);

    /* Check LCD of matched strings. */
    if (vector_slot (vline, index) != NULL)
    {
        lcd = cmd_lcd ((char **) matchvec->index);

        if (lcd)
        {
            int len = strlen (( char * ) vector_slot (vline, index));

            if (len < lcd)
            {
                char *lcdstr;

                lcdstr = (char * )XMALLOC (MTYPE_TMP, lcd + 1);
                memcpy (lcdstr, matchvec->index[0], lcd);
                lcdstr[lcd] = '\0';

                /* match_str = (char **) &lcdstr; */

                /* Free matchvec. */
                for (i = 0; i < vector_max (matchvec); i++)
                {
                    if (vector_slot (matchvec, i))
                        XFREE (MTYPE_TMP, vector_slot (matchvec, i));
                }
                vector_free (matchvec);

                /* Make New matchvec. */
                matchvec = vector_init (INIT_MATCHVEC_SIZE);
                vector_set (matchvec, lcdstr);
                match_str = (char **) matchvec->index;
                vector_only_wrapper_free (matchvec);

                *status = CMD_COMPLETE_MATCH;
                return match_str;
            }
        }
    }

    match_str = (char **) matchvec->index;
    vector_only_wrapper_free (matchvec);
    *status = CMD_COMPLETE_LIST_MATCH;
    return match_str;
}

/* Execute command by argument vline vector. */
int
Bgp::cmd_execute_command (struct _vector* vline, struct vty *vty, struct cmd_element **cmd)
{
    int i;
    int index;
    struct _vector* cmd_vector;
    struct cmd_element *cmd_element;
    struct cmd_element *matched_element;
    unsigned int matched_count, incomplete_count;
    int argc;
    char *argv[CMD_ARGC_MAX];
    enum match_type match =( enum match_type )  0;
    int varflag;
    char *command;

    /* Make copy of command elements. */
    cmd_vector = vector_copy (cmd_node_vector (cmdvec,(enum node_type) vty->node));

    for (index = 0; index < vector_max (vline); index++)
    {
        int ret;

        command = ( char * ) vector_slot (vline, index);

        match = cmd_filter_by_completion (command, cmd_vector, index);

        if (match == vararg_match)
            break;

        ret = is_cmd_ambiguous (command, cmd_vector, index, match);

        if (ret == 1)
        {
            vector_free (cmd_vector);
            return CMD_ERR_AMBIGUOUS;
        } else if (ret == 2)
        {
            vector_free (cmd_vector);
            return CMD_ERR_NO_MATCH;
        }
    }

    /* Check matched count. */
    matched_element = NULL;
    matched_count = 0;
    incomplete_count = 0;

    for (i = 0; i < vector_max (cmd_vector); i++)
        if (vector_slot (cmd_vector,i) != NULL)
        {
            cmd_element = (struct cmd_element*) vector_slot (cmd_vector,i);

            if (match == vararg_match || index >= cmd_element->cmdsize)
            {
                matched_element = cmd_element;
#if 0
                printf ("DEBUG: %s\n", cmd_element->string);
#endif
                matched_count++;
            } else
            {
                incomplete_count++;
            }
        }

        /* Finish of using cmd_vector. */
    vector_free (cmd_vector);

    /* To execute command, matched_count must be 1.*/
    if (matched_count == 0)
    {
        if (incomplete_count)
            return CMD_ERR_INCOMPLETE;
        else
            return CMD_ERR_NO_MATCH;
    }

    if (matched_count > 1)
        return CMD_ERR_AMBIGUOUS;

    /* Argument treatment */
    varflag = 0;
    argc = 0;

    for (i = 0; i < vector_max (vline); i++)
    {
        if (varflag)
            argv[argc++] = ( char * ) vector_slot (vline, i);
        else
        {
            struct _vector* descvec = ( struct _vector * ) vector_slot (matched_element->strvec, i);

            if (vector_max (descvec) == 1)
            {
                struct desc *desc = ( struct desc * ) vector_slot (descvec, 0);
                char *str = desc->cmd;

                if (CMD_VARARG (str))
                    varflag = 1;

                if (varflag || CMD_VARIABLE (str) || CMD_OPTION (str))
                    argv[argc++] = ( char * )  vector_slot (vline, i);
            } else
                argv[argc++] = ( char * ) vector_slot (vline, i);
        }

        if (argc >= CMD_ARGC_MAX)
            return CMD_ERR_EXEED_ARGC_MAX;
    }

    /* For vtysh execution. */
    if (cmd)
        *cmd = matched_element;

    if (matched_element->daemon)
        return CMD_SUCCESS_DAEMON;

    /* Execute matched command. */

    return(this->*matched_element->func) (matched_element, vty, argc, argv);
}

/* Execute command by argument readline. */
int
Bgp::cmd_execute_command_strict (struct _vector* vline, struct vty *vty, 
                                 struct cmd_element **cmd)
{
    int i;
    int index;
    struct _vector* cmd_vector;
    struct cmd_element *cmd_element;
    struct cmd_element *matched_element;
    unsigned int matched_count, incomplete_count;
    int argc;
    char *argv[CMD_ARGC_MAX];
    int varflag;
    enum match_type match =(enum match_type)  0;
    char *command;

    /* Make copy of command element */
    cmd_vector = vector_copy (cmd_node_vector (cmdvec,(enum node_type) vty->node));

    for (index = 0; index < vector_max (vline); index++)
    {
        int ret;

        command = ( char* ) vector_slot (vline, index);

        match = cmd_filter_by_string ((char * ) vector_slot (vline, index), 
                                      cmd_vector, index);

        /* If command meets '.VARARG' then finish matching. */
        if (match == vararg_match)
            break;

        ret = is_cmd_ambiguous (command, cmd_vector, index, match);
        if (ret == 1)
        {
            vector_free (cmd_vector);
            return CMD_ERR_AMBIGUOUS;
        }
        if (ret == 2)
        {
            vector_free (cmd_vector);
            return CMD_ERR_NO_MATCH;
        }
    }

    /* Check matched count. */
    matched_element = NULL;
    matched_count = 0;
    incomplete_count = 0;
    for (i = 0; i < vector_max (cmd_vector); i++)
        if (vector_slot (cmd_vector,i) != NULL)
        {
            cmd_element = ( struct cmd_element * ) vector_slot (cmd_vector,i);

            if (match == vararg_match || index >= cmd_element->cmdsize)
            {
                matched_element = cmd_element;
                matched_count++;
            } else
                incomplete_count++;
        }

        /* Finish of using cmd_vector. */
    vector_free (cmd_vector);

    /* To execute command, matched_count must be 1.*/
    if (matched_count == 0)
    {
        if (incomplete_count)
            return CMD_ERR_INCOMPLETE;
        else
            return CMD_ERR_NO_MATCH;
    }

    if (matched_count > 1)
        return CMD_ERR_AMBIGUOUS;

    /* Argument treatment */
    varflag = 0;
    argc = 0;

    for (i = 0; i < vector_max (vline); i++)
    {
        if (varflag)
            argv[argc++] = (char *) vector_slot (vline, i);
        else
        {
            struct _vector* descvec = (struct _vector *) vector_slot (matched_element->strvec, i);

            if (vector_max (descvec) == 1)
            {
                struct desc *desc = (struct desc *) vector_slot (descvec, 0);
                char *str = desc->cmd;

                if (CMD_VARARG (str))
                    varflag = 1;

                if (varflag || CMD_VARIABLE (str) || CMD_OPTION (str))
                    argv[argc++] = (char*) vector_slot (vline, i);
            } else
                argv[argc++] = (char*) vector_slot (vline, i);
        }

        if (argc >= CMD_ARGC_MAX)
            return CMD_ERR_EXEED_ARGC_MAX;
    }

    /* For vtysh execution. */
    if (cmd)
        *cmd = matched_element;

    if (matched_element->daemon)
        return CMD_SUCCESS_DAEMON;

    /* Now execute matched command */

    return(this->*matched_element->func) (matched_element, vty, argc, argv);
}

/* Configration make from file. */
int
Bgp::config_from_file (struct vty *vty, FILE *fp)
{
    int ret;
    struct _vector* vline;

    while (fgets (vty->buf, VTY_BUFSIZ, fp))
    {

        vline = cmd_make_strvec (vty->buf);

        /* In case of comment line */
        if (vline == NULL)
            continue;

        /* Echo the command */
        vty_out (zlog_default,LOG_DEBUG, ">%s%s", strtok(vty->buf,"\n"),VTY_NEWLINE);

        /* Execute configuration command : this is strict match */

        ret = cmd_execute_command_strict (vline, vty, NULL);

        /* Try again with setting node to CONFIG_NODE */
        if (ret != CMD_SUCCESS && ret != CMD_WARNING)
        {
	  vty->node = CONFIG_NODE;
	  ret = cmd_execute_command_strict (vline, vty, NULL);

        }

        cmd_free_strvec (vline);

        if (ret != CMD_SUCCESS && ret != CMD_WARNING)
            return ret;
    }
    return CMD_SUCCESS;
}

/* Write startup configuration into the terminal. */
DEFUN (show_startup_config,
       show_startup_config_cmd,
       "show startup-config",
       SHOW_STR
       "Contentes of startup configuration\n")
{
    char buf[BUFSIZ];
    FILE *confp;

    confp = fopen (host.config, "r");
    if (confp == NULL)
    {
       vty_out (zlog_default,LOG_DEBUG, "Cant open configuration file [%s]%s",
                 host.config, VTY_NEWLINE);
        return CMD_WARNING;
    }

    while (fgets (buf, BUFSIZ, confp))
    {
        char *cp = buf;

        while (*cp != '\r' && *cp != '\n' && *cp != '\0')
            cp++;
        *cp = '\0';

       vty_out (zlog_default,LOG_DEBUG, "%s%s", buf, VTY_NEWLINE);
    }

    fclose (confp);

    return CMD_SUCCESS;
}

DEFUN (config_log_file,
       config_log_file_cmd,
       "log file FILENAME",
       "Logging control\n"
       "Logging to file\n"
       "Logging filename\n")
{
    int ret;
    char *cwd;
    char *fullpath;

    /* Path detection. */
    if (! IS_DIRECTORY_SEP (*argv[0]))
    {
        cwd = getcwd (NULL, MAXPATHLEN);
        fullpath = (char *) XMALLOC (MTYPE_TMP,
                                     strlen (cwd) + strlen (argv[0]) + 2);
        sprintf (fullpath, "%s/%s", cwd, argv[0]);
    } else
        fullpath = argv[0];

    ret = zlog_set_file (NULL, ZLOG_FILE, fullpath);

    if (!ret)
    {
        vty_out (zlog_default,LOG_DEBUG, "can't open logfile %s%s", argv[0],VTY_NEWLINE);
        return CMD_WARNING;
    }

    if (host.logfile)
        XFREE (MTYPE_TMP, host.logfile);

    host.logfile = strdup (argv[0]);

    return CMD_SUCCESS;
}

DEFUN (no_config_log_file,
       no_config_log_file_cmd,
       "no log file [FILENAME]",
       NO_STR
       "Logging control\n"
       "Cancel logging to file\n"
       "Logging file name\n")
{
    zlog_reset_file (NULL);

    if (host.logfile)
        XFREE (MTYPE_TMP, host.logfile);

    host.logfile = NULL;

    return CMD_SUCCESS;
}


/* Set config filename.  Called from vty.c */
void
Bgp::host_config_set (char *filename)
{
    host.config = strdup (filename);
}

/* Initialize command interface. Install basic nodes and commands. */
void
Bgp::cmd_init (int terminal)
{
    /* Allocate initial top vector of commands. */
    if(cmdvec_init)cmdvec = vector_init (VECTOR_MIN_SIZE);
    /* Default host value settings. */
    host.name = NULL;
    host.password = NULL;
    host.enable = NULL;
    host.logfile = NULL;
    host.config = NULL;
    host.lines = -1;


    /* Install top nodes. */
    if(cmdvec_init) install_node (&config_node, &Bgp::config_write_host);

    /* Each node's basic commands. */
    if(cmdvec_init) install_element (CONFIG_NODE, &show_startup_config_cmd);

    if (terminal)
    {
        if(cmdvec_init) install_element (CONFIG_NODE, &config_log_file_cmd);
        if(cmdvec_init) install_element (CONFIG_NODE, &no_config_log_file_cmd);
    }
}


////////////////////////////////////////////////
////////////destribute.c////////////////////////
////////////////////////////////////////////////
struct distribute *
Bgp::distribute_new ()
{
    struct distribute *New;

    New = (struct distribute*) XMALLOC (MTYPE_DISTRIBUTE, sizeof (struct distribute));
    bzero (New, sizeof (struct distribute));

    return New;
}

/* Free distribute object. */
void
Bgp::distribute_free (struct distribute *dist)
{
    if (dist->ifname)
        free (dist->ifname);

    if (dist->list[DISTRIBUTE_IN])
        free (dist->list[DISTRIBUTE_IN]);
    if (dist->list[DISTRIBUTE_OUT])
        free (dist->list[DISTRIBUTE_OUT]);

    if (dist->prefix[DISTRIBUTE_IN])
        free (dist->prefix[DISTRIBUTE_IN]);
    if (dist->prefix[DISTRIBUTE_OUT])
        free (dist->prefix[DISTRIBUTE_OUT]);

    XFREE (MTYPE_DISTRIBUTE, dist);
}

/* Lookup interface's distribute list. */
struct distribute *
Bgp::distribute_lookup (char *ifname)
{
    struct distribute key;
    struct distribute *dist;

    key.ifname = ifname;

    dist = ( struct distribute*) hash_search (disthash, &key);

    return dist;
}

void
Bgp::distribute_list_add_hook (void (Bgp::*func) (struct distribute *))
{
    distribute_add_hook = func;
}

void
Bgp::distribute_list_delete_hook (void (Bgp::*func) (struct distribute *))
{
    distribute_delete_hook = func;
}

/* Make New distribute list and push into hash. */
struct distribute *
Bgp::distribute_get (char *ifname)
{
    struct distribute *dist;

    dist = distribute_lookup (ifname);
    if (dist == NULL)
    {
        dist = distribute_new ();
        if (ifname)
            dist->ifname = strdup (ifname);
        else
            dist->ifname = NULL;
        hash_push (disthash, dist);
    }
    return dist;
}

unsigned int
Bgp::distribute_hash_make (struct distribute *dist)
{
    unsigned int key;
    int i;

    key = 0;
    if (dist->ifname)
        for (i = 0; i < strlen (dist->ifname); i++)
            key += dist->ifname[i];

    return key %= HASHTABSIZE;
}

/* If two distribute-list have same value then return 1 else return
   0. This function is used by hash package. */
int
Bgp::distribute_cmp (struct distribute *dist1, struct distribute *dist2)
{
    if (dist1->ifname && dist2->ifname)
        if (strcmp (dist1->ifname, dist2->ifname) == 0)
            return 1;
    if (! dist1->ifname && ! dist2->ifname)
        return 1;
    return 0;
}

/* Utility function. */
void
Bgp::distribute_print (struct distribute *dist)
{
    printf ("distribute-list %s in %s out %s\n", dist->ifname, 
            dist->list[DISTRIBUTE_IN], dist->list[DISTRIBUTE_OUT]);
}

/* Set access-list name to the distribute list. */
struct distribute *
Bgp::distribute_list_set (char *ifname, enum distribute_type type, char *alist_name)
{
    struct distribute *dist;

    dist = distribute_get (ifname);

    if (type == DISTRIBUTE_IN)
    {
        if (dist->list[DISTRIBUTE_IN])
            free (dist->list[DISTRIBUTE_IN]);
        dist->list[DISTRIBUTE_IN] = strdup (alist_name);
    }
    if (type == DISTRIBUTE_OUT)
    {
        if (dist->list[DISTRIBUTE_OUT])
            free (dist->list[DISTRIBUTE_OUT]);
        dist->list[DISTRIBUTE_OUT] = strdup (alist_name);
    }

    /* Apply this distribute-list to the interface. */
    (this->*distribute_add_hook) (dist);

    return dist;
}

/* Unset distribute-list.  If matched distribute-list exist then
   return 1. */
int
Bgp::distribute_list_unset (char *ifname, enum distribute_type type, 
                            char *alist_name)
{
    struct distribute *dist;

    dist = distribute_lookup (ifname);
    if (!dist)
        return 0;

    if (type == DISTRIBUTE_IN)
    {
        if (!dist->list[DISTRIBUTE_IN])
            return 0;
        if (strcmp (dist->list[DISTRIBUTE_IN], alist_name) != 0)
            return 0;

        free (dist->list[DISTRIBUTE_IN]);
        dist->list[DISTRIBUTE_IN] = NULL;      
    }

    if (type == DISTRIBUTE_OUT)
    {
        if (!dist->list[DISTRIBUTE_OUT])
            return 0;
        if (strcmp (dist->list[DISTRIBUTE_OUT], alist_name) != 0)
            return 0;

        free (dist->list[DISTRIBUTE_OUT]);
        dist->list[DISTRIBUTE_OUT] = NULL;      
    }

    /* Apply this distribute-list to the interface. */
    (this->*distribute_delete_hook) (dist);

    /* If both out and in is NULL then free distribute list. */
    if (dist->list[DISTRIBUTE_IN] == NULL &&
        dist->list[DISTRIBUTE_OUT] == NULL &&
        dist->prefix[DISTRIBUTE_IN] == NULL &&
        dist->prefix[DISTRIBUTE_OUT] == NULL)
    {
        hash_pull (disthash, dist);
        distribute_free (dist);
    }

    return 1;
}

/* Set access-list name to the distribute list. */
struct distribute *
Bgp::distribute_list_prefix_set (char *ifname, enum distribute_type type,
                                 char *plist_name)
{
    struct distribute *dist;

    dist = distribute_get (ifname);

    if (type == DISTRIBUTE_IN)
    {
        if (dist->prefix[DISTRIBUTE_IN])
            free (dist->prefix[DISTRIBUTE_IN]);
        dist->prefix[DISTRIBUTE_IN] = strdup (plist_name);
    }
    if (type == DISTRIBUTE_OUT)
    {
        if (dist->prefix[DISTRIBUTE_OUT])
            free (dist->prefix[DISTRIBUTE_OUT]);
        dist->prefix[DISTRIBUTE_OUT] = strdup (plist_name);
    }

    /* Apply this distribute-list to the interface. */
    (this->*distribute_add_hook) (dist);

    return dist;
}

/* Unset distribute-list.  If matched distribute-list exist then
   return 1. */
int
Bgp::distribute_list_prefix_unset (char *ifname, enum distribute_type type,
                                   char *plist_name)
{
    struct distribute *dist;

    dist = distribute_lookup (ifname);
    if (!dist)
        return 0;

    if (type == DISTRIBUTE_IN)
    {
        if (!dist->prefix[DISTRIBUTE_IN])
            return 0;
        if (strcmp (dist->prefix[DISTRIBUTE_IN], plist_name) != 0)
            return 0;

        free (dist->prefix[DISTRIBUTE_IN]);
        dist->prefix[DISTRIBUTE_IN] = NULL;      
    }

    if (type == DISTRIBUTE_OUT)
    {
        if (!dist->prefix[DISTRIBUTE_OUT])
            return 0;
        if (strcmp (dist->prefix[DISTRIBUTE_OUT], plist_name) != 0)
            return 0;

        free (dist->prefix[DISTRIBUTE_OUT]);
        dist->prefix[DISTRIBUTE_OUT] = NULL;      
    }

    /* Apply this distribute-list to the interface. */
    (this->*distribute_delete_hook) (dist);

    /* If both out and in is NULL then free distribute list. */
    if (dist->list[DISTRIBUTE_IN] == NULL &&
        dist->list[DISTRIBUTE_OUT] == NULL &&
        dist->prefix[DISTRIBUTE_IN] == NULL &&
        dist->prefix[DISTRIBUTE_OUT] == NULL)
    {
        hash_pull (disthash, dist);
        distribute_free (dist);
    }

    return 1;
}

int
Bgp::config_show_distribute (struct vty *vty)
{
    int i;
    HashBacket *mp;
    struct distribute *dist;

    /* Output filter configuration. */
    dist = distribute_lookup (NULL);
    if (dist && (dist->list[DISTRIBUTE_OUT] || dist->prefix[DISTRIBUTE_OUT]))
    {
       vty_out (zlog_default,LOG_DEBUG, "  Outgoing update filter list for all interface is");
        if (dist->list[DISTRIBUTE_OUT])
           vty_out (zlog_default,LOG_DEBUG, " %s", dist->list[DISTRIBUTE_OUT]);
        if (dist->prefix[DISTRIBUTE_OUT])
           vty_out (zlog_default,LOG_DEBUG, "%s (prefix-list) %s",
                     dist->list[DISTRIBUTE_OUT] ? "," : "",
                     dist->prefix[DISTRIBUTE_OUT]);
       vty_out (zlog_default,LOG_DEBUG, "%s", VTY_NEWLINE);
    } else
       vty_out (zlog_default,LOG_DEBUG, "  Outgoing update filter list for all interface is not set%s", VTY_NEWLINE);

    for (i = 0; i < HASHTABSIZE; i++)
        for (mp = hash_head (disthash, i); mp; mp = mp->next)
        {
            dist = (struct distribute*) mp->data;
            if (dist->ifname)
                if (dist->list[DISTRIBUTE_OUT] || dist->prefix[DISTRIBUTE_OUT])
                {
                   vty_out (zlog_default,LOG_DEBUG, "    %s filtered by", dist->ifname);
                    if (dist->list[DISTRIBUTE_OUT])
                       vty_out (zlog_default,LOG_DEBUG, " %s", dist->list[DISTRIBUTE_OUT]);
                    if (dist->prefix[DISTRIBUTE_OUT])
                       vty_out (zlog_default,LOG_DEBUG, "%s (prefix-list) %s",
                                 dist->list[DISTRIBUTE_OUT] ? "," : "",
                                 dist->prefix[DISTRIBUTE_OUT]);
                   vty_out (zlog_default,LOG_DEBUG, "%s", VTY_NEWLINE);
                }
        }


    /* Input filter configuration. */
    dist = distribute_lookup (NULL);
    if (dist && (dist->list[DISTRIBUTE_IN] || dist->prefix[DISTRIBUTE_IN]))
    {
       vty_out (zlog_default,LOG_DEBUG, "  Incoming update filter list for all interface is");
        if (dist->list[DISTRIBUTE_IN])
           vty_out (zlog_default,LOG_DEBUG, " %s", dist->list[DISTRIBUTE_IN]);
        if (dist->prefix[DISTRIBUTE_IN])
           vty_out (zlog_default,LOG_DEBUG, "%s (prefix-list) %s",
                     dist->list[DISTRIBUTE_IN] ? "," : "",
                     dist->prefix[DISTRIBUTE_IN]);
       vty_out (zlog_default,LOG_DEBUG, "%s", VTY_NEWLINE);
    } else
       vty_out (zlog_default,LOG_DEBUG, "  Incoming update filter list for all interface is not set%s", VTY_NEWLINE);

    for (i = 0; i < HASHTABSIZE; i++)
        for (mp = hash_head (disthash, i); mp; mp = mp->next)
        {
            dist = (struct distribute*) mp->data;
            if (dist->ifname)
                if (dist->list[DISTRIBUTE_IN] || dist->prefix[DISTRIBUTE_IN])
                {
                   vty_out (zlog_default,LOG_DEBUG, "    %s filtered by", dist->ifname);
                    if (dist->list[DISTRIBUTE_IN])
                       vty_out (zlog_default,LOG_DEBUG, " %s", dist->list[DISTRIBUTE_IN]);
                    if (dist->prefix[DISTRIBUTE_IN])
                       vty_out (zlog_default,LOG_DEBUG, "%s (prefix-list) %s",
                                 dist->list[DISTRIBUTE_IN] ? "," : "",
                                 dist->prefix[DISTRIBUTE_IN]);
                   vty_out (zlog_default,LOG_DEBUG, "%s", VTY_NEWLINE);
                }
        }
    return 0;
}

/* Configuration write function. */
int
Bgp::config_write_distribute (struct vty *vty)
{
    int i;
    HashBacket *mp;
    int write = 0;

    for (i = 0; i < HASHTABSIZE; i++)
        for (mp = hash_head (disthash, i); mp; mp = mp->next)
        {
            struct distribute *dist;

            dist =  (struct distribute*) mp->data;

            if (dist->list[DISTRIBUTE_IN])
            {
               vty_out (zlog_default,LOG_DEBUG, " distribute-list %s in %s%s", 
                         dist->list[DISTRIBUTE_IN],
                         dist->ifname ? dist->ifname : "",
                         VTY_NEWLINE);
                write++;
            }

            if (dist->list[DISTRIBUTE_OUT])
            {
               vty_out (zlog_default,LOG_DEBUG, " distribute-list %s out %s%s", 

                         dist->list[DISTRIBUTE_OUT],
                         dist->ifname ? dist->ifname : "",
                         VTY_NEWLINE);
                write++;
            }

            if (dist->prefix[DISTRIBUTE_IN])
            {
               vty_out (zlog_default,LOG_DEBUG, " distribute-list prefix %s in %s%s",
                         dist->prefix[DISTRIBUTE_IN],
                         dist->ifname ? dist->ifname : "",
                         VTY_NEWLINE);
                write++;
            }

            if (dist->prefix[DISTRIBUTE_OUT])
            {
               vty_out (zlog_default,LOG_DEBUG, " distribute-list prefix %s out %s%s",
                         dist->prefix[DISTRIBUTE_OUT],
                         dist->ifname ? dist->ifname : "",
                         VTY_NEWLINE);
                write++;
            }
        }
    return write;
}

/* Clear all distribute list. */
void
Bgp::distribute_list_reset ()
{
    hash_clean (disthash, (void (Bgp::*) (void *)) &Bgp::distribute_free);
}

/* Initialize distribute list related hash. */
void
Bgp::distribute_list_init (int node)
{
    disthash = hash_new (HASHTABSIZE);
    disthash->hash_key = (unsigned int (*)(void*)) &Bgp::distribute_hash_make;
    disthash->hash_cmp = (int (*)(void*,void*)) &Bgp::distribute_cmp;
}



////////////////////////////////////////////////
////////////////////////////////////////////////
////////////////filter.c////////////////////////
////////////////////////////////////////////////


struct access_master *
Bgp::access_master_get (afi_t afi)
{
    if (afi == AFI_IP)
        return &access_master_ipv4;

    return NULL;
}

/* Allocate New filter structure. */
struct filter *
Bgp::filter_new ()
{
    struct filter *New;

    New = (struct filter *) XMALLOC (MTYPE_ACCESS_FILTER, sizeof (struct filter));
    bzero (New, sizeof (struct filter));
    return New;
}

void
Bgp::filter_free (struct filter *filter)
{
    XFREE (MTYPE_ACCESS_FILTER, filter);
}

/* Return string of filter_type. */
char *
Bgp::filter_type_str (struct filter *filter)
{
    switch (filter->type)
    {
    case FILTER_PERMIT:
        return "permit";
        break;
    case FILTER_DENY:
        return "deny";
        break;
    case FILTER_DYNAMIC:
        return "dynamic";
        break;
    default:
        return "";
        break;
    }
}

/* Allocate and make New filter. */
struct filter *
Bgp::filter_make (struct prefix *prefix, enum filter_type type)
{
    struct filter *filter;

    filter = filter_new ();

    /* If prefix is NULL then this is "any" match directive. */
    if (prefix == NULL)
        filter->any = 1;
    else
        prefix_copy (&filter->prefix, prefix);

    filter->type = type;

    return filter;
}

struct filter *
Bgp::filter_lookup (struct access_list *access, struct prefix *prefix,
                    enum filter_type type, int exact)
{
    struct filter *filter;

    for (filter = access->head; filter; filter = filter->next)
    {
        if (prefix == NULL)
        {
            if (filter->any == 1 && filter->type == type)
                return filter;
        } else
        {
            if (prefix_same (&filter->prefix, prefix) &&
                filter->type == type && filter->exact == exact)
                return filter;
        }
    }
    return NULL;
}

/* If filter match to the prefix then return 1. */
int
Bgp::filter_match (struct filter *filter, struct prefix *p)
{
    if (filter->prefix.family == p->family)
    {
        if (filter->exact)
        {
            if (filter->prefix.prefixlen == p->prefixlen)
                return prefix_match (&filter->prefix, p);
            else
                return 0;
        } else
            return prefix_match (&filter->prefix, p);
    } else
        return 0;
}

/* Allocate New access list structure. */
struct access_list *
Bgp::access_list_new ()
{
    struct access_list *New;

    New = (struct access_list * ) XMALLOC (MTYPE_ACCESS_LIST, sizeof (struct access_list));
    bzero (New, sizeof (struct access_list));
    return New;
}

/* Free allocated access_list. */
void
Bgp::access_list_free (struct access_list *access)
{
    XFREE (MTYPE_ACCESS_LIST, access);
}

/* Delete access_list from access_master and free it. */
void
Bgp::access_list_delete (struct access_list *access)
{
    struct filter *filter;
    struct filter *next;
    struct access_list_list *list;
    struct access_master *master;

    for (filter = access->head; filter; filter = next)
    {
        next = filter->next;
        filter_free (filter);
    }

    master = access->master;

    if (access->type == ACCESS_TYPE_NUMBER)
        list = &master->num;
    else
        list = &master->str;

    if (access->next)
        access->next->prev = access->prev;
    else
        list->tail = access->prev;

    if (access->prev)
        access->prev->next = access->next;
    else
        list->head = access->next;

    if (access->name)
        XFREE (MTYPE_ACCESS_LIST_STR, access->name);

    if (access->remark)
        XFREE (MTYPE_TMP, access->remark);

    access_list_free (access);
}

/* Insert New access list to list of access_list.  Each acceess_list
   is sorted by the name. */
struct access_list *
Bgp::access_list_insert (afi_t afi, char *name)
{
    int i;
    long number;
    struct access_list *access;
    struct access_list *point;
    struct access_list_list *alist;
    struct access_master *master;

    master = access_master_get (afi);
    if (master == NULL)
        return NULL;

    /* Allocate New access_list and copy given name. */
    access = access_list_new ();
    access->name = XSTRDUP (MTYPE_ACCESS_LIST_STR, name);
    access->master = master;

    /* If name is made by all digit character.  We treat it as
       number. */
    for (number = 0, i = 0; i < strlen (name); i++)
    {
        if (isdigit ((int) name[i]))
            number = (number * 10) + (name[i] - '0');
        else
            break;
    }

    /* In case of name is all digit character */
    if (i == strlen (name))
    {
        access->type = ACCESS_TYPE_NUMBER;

        /* Set access_list to number list. */
        alist = &master->num;

        for (point = alist->head; point; point = point->next)
            if (atol (point->name) >= number)
                break;
    } else
    {
        access->type = ACCESS_TYPE_STRING;

        /* Set access_list to string list. */
        alist = &master->str;

        /* Set point to insertion point. */
        for (point = alist->head; point; point = point->next)
            if (strcmp (point->name, name) >= 0)
                break;
    }

    /* In case of this is the first element of master. */
    if (alist->head == NULL)
    {
        alist->head = alist->tail = access;
        return access;
    }

    /* In case of insertion is made at the tail of access_list. */
    if (point == NULL)
    {
        access->prev = alist->tail;
        alist->tail->next = access;
        alist->tail = access;
        return access;
    }

    /* In case of insertion is made at the head of access_list. */
    if (point == alist->head)
    {
        access->next = alist->head;
        alist->head->prev = access;
        alist->head = access;
        return access;
    }

    /* Insertion is made at middle of the access_list. */
    access->next = point;
    access->prev = point->prev;

    if (point->prev)
        point->prev->next = access;
    point->prev = access;

    return access;
}

/* Lookup access_list from list of access_list by name. */
struct access_list *
Bgp::access_list_lookup (afi_t afi, char *name)
{
    struct access_list *access;
    struct access_master *master;

    if (name == NULL)
        return NULL;

    master = access_master_get (afi);
    if (master == NULL)
        return NULL;

    for (access = master->num.head; access; access = access->next)
        if (strcmp (access->name, name) == 0)
            return access;

    for (access = master->str.head; access; access = access->next)
        if (strcmp (access->name, name) == 0)
            return access;

    return NULL;
}

/* Get access list from list of access_list.  If there isnt matched
   access_list create New one and return it. */
struct access_list *
Bgp::access_list_get (afi_t afi, char *name)
{
    struct access_list *access;

    access = access_list_lookup (afi, name);
    if (access == NULL)
        access = access_list_insert (afi, name);
    return access;
}

/* Print out contents of access list to the terminal. */
void
Bgp::access_list_print (struct access_list *access)
{
    struct filter *filter;

    printf ("access name %s\n", access->name);

    for (filter = access->head; filter; filter = filter->next)
    {
        if (filter->any)
            printf ("any %s\n", filter_type_str (filter));
        else
        {
            struct prefix *p;
            char buf[BUFSIZ];

            p = &filter->prefix;

            printf ("%s/%d %s\n", 
                    Bgp::inet_ntop (p->family, &p->u.prefix, buf, BUFSIZ), 
                    p->prefixlen, filter_type_str (filter));
        }
    }
}

/* Apply access list to object (which should be struct prefix *). */
enum filter_type
Bgp::access_list_apply (struct access_list *access, void *object)
{
    struct filter *filter;
    struct prefix *p;

    p = (struct prefix *) object;

    if (access == NULL)
        return FILTER_DENY;

    for (filter = access->head; filter; filter = filter->next)
        if (filter->any || filter_match (filter, p))
            return filter->type;

    return FILTER_DENY;
}

/* Add hook function. */
void
Bgp::access_list_add_hook (void (Bgp::*func) (struct access_list *access))
{
    access_master_ipv4.add_hook = func;

}

/* Delete hook function. */
void
Bgp::access_list_delete_hook (void (Bgp::*func) (struct access_list *access))
{
    access_master_ipv4.delete_hook = func;

}

/* Add New filter to the end of specified access_list. */
void
Bgp::access_list_filter_add (struct access_list *access, struct filter *filter)
{
    filter->next = NULL;
    filter->prev = access->tail;

    if (access->tail)
        access->tail->next = filter;
    else
        access->head = filter;
    access->tail = filter;

    /* Run hook function. */
    if (access->master->add_hook)
        (this->*access->master->add_hook) (access);
}

/* If access_list has no filter then return 1. */
int
Bgp::access_list_empty (struct access_list *access)
{
    if (access->head == NULL && access->tail == NULL)
        return 1;
    else
        return 0;
}

/* Delete filter from specified access_list.  If there is hook
   function execute it. */
void
Bgp::access_list_filter_delete (struct access_list *access, struct filter *filter)
{
    struct access_master *master;

    master = access->master;

    if (filter->next)
        filter->next->prev = filter->prev;
    else
        access->tail = filter->prev;

    if (filter->prev)
        filter->prev->next = filter->next;
    else
        access->head = filter->next;

    filter_free (filter);

    /* If access_list becomes empty delete it from access_master. */
    if (access_list_empty (access))
        access_list_delete (access);

    /* Run hook function. */
    if (master->delete_hook)
        (this->*master->delete_hook) (access);
}

/*
  deny    Specify packets to reject
  permit  Specify packets to forward
  dynamic ?
*/

/*
  Hostname or A.B.C.D  Address to match
  any                  Any source host
  host                 A single host address
*/

int
Bgp::access_list_dup_check (struct access_list *access, struct filter *New)
{
    struct filter *filter;

    for (filter = access->head; filter; filter = filter->next)
    {
        if (filter->any == New->any
            && filter->exact == New->exact
            && filter->type == New->type
            && prefix_same (&filter->prefix, &New->prefix))
            return 1;
    }
    return 0;
}

int
Bgp::vty_access_list_remark_unset (struct vty *vty, afi_t afi, char *name)
{
    struct access_list *access;

    access = access_list_lookup (afi, name);
    if (! access)
    {
       vty_out (zlog_default,LOG_DEBUG, "%% access-list %s doesnt exist%s", name,
                 VTY_NEWLINE);
        return CMD_WARNING;
    }

    if (access->remark)
    {
        XFREE (MTYPE_TMP, access->remark);
        access->remark = NULL;
    }

    if (access->head == NULL && access->tail == NULL && access->remark == NULL)
        access_list_delete (access);

    return CMD_SUCCESS;
}

DEFUN (access_list, 
       access_list_cmd,
       "access-list WORD (deny|permit) (A.B.C.D/M|any)",
       "Add an access list entry\n"
       "Access-list name\n"
       "Specify packets to reject\n"
       "Specify packets to forward\n"
       "Prefix to match. e.g. 10.0.0.0/8\n"
       "Any prefix to match\n")
{
    int ret;
    enum filter_type type;
    struct filter *filter;
    struct access_list *access;
    struct prefix p;

    /* Check of filter type. */
    if (strncmp (argv[1], "p", 1) == 0)
        type = FILTER_PERMIT;
    else if (strncmp (argv[1], "d", 1) == 0)
        type = FILTER_DENY;
    else
    {
       vty_out (zlog_default,LOG_DEBUG, "filter type must be permit or deny%s", VTY_NEWLINE);
        return CMD_WARNING;
    }

    /* "any" is special token of matching IP addresses.  */
    if (strncmp (argv[2], "a", 1) == 0)
        filter = filter_make (NULL, type);
    else
    {
        /* Check string format of prefix and prefixlen. */
        ret = str2prefix_ipv4 (argv[2], (struct prefix_ipv4 *)&p);
        if (ret <= 0)
        {
           vty_out (zlog_default,LOG_DEBUG, "IP address prefix/prefixlen is malformed%s",
                     VTY_NEWLINE);
            return CMD_WARNING;
        }
        filter = filter_make (&p, type);
    }

    /* "exact-match" */
    if (argc == 4)
        filter->exact = 1;

    /* Install New filter to the access_list. */
    access = access_list_get (AFI_IP, argv[0]);

    /* Duplicate insertion check. */
    if (access_list_dup_check (access, filter))
        filter_free (filter);
    else
        access_list_filter_add (access, filter);

    return CMD_SUCCESS;
}


DEFUN (no_access_list,
       no_access_list_cmd,
       "no access-list WORD (deny|permit) (A.B.C.D/M|any)",
       NO_STR 
       "Add an access list entry\n"
       "Access-list name\n"
       "Specify packets to reject\n"
       "Specify packets to forward\n"
       "Prefix to match. e.g. 10.0.0.0/8\n"
       "Any prefix to match\n")
{
    int ret;
    enum filter_type type;
    struct filter *filter;
    struct access_list *access;
    struct prefix p;
    int exact = 0;

    /* Check of filter type. */
    if (strncmp (argv[1], "p", 1) == 0)
        type = FILTER_PERMIT;
    else if (strncmp (argv[1], "d", 1) == 0)
        type = FILTER_DENY;
    else
    {
       vty_out (zlog_default,LOG_DEBUG, "filter type must be [permit|deny]%s", VTY_NEWLINE);
        return CMD_WARNING;
    }

    /* Looking up access_list. */
    access = access_list_lookup (AFI_IP, argv[0]);
    if (access == NULL)
    {
       vty_out (zlog_default,LOG_DEBUG, "%% access-list %s doesnt exist%s", argv[0],
                 VTY_NEWLINE);
        return CMD_WARNING;
    }

    if (argc == 4)
        exact = 1;

    /* Check string format of prefix and prefixlen. */
    if (strncmp (argv[2], "a", 1) == 0)
        filter = filter_lookup (access, NULL, type, exact);
    else
    {
        ret = str2prefix_ipv4 (argv[2], (struct prefix_ipv4 *) &p);
        if (ret <= 0)
        {
           vty_out (zlog_default,LOG_DEBUG, "IP address prefix/prefixlen is malformed%s", VTY_NEWLINE);
            return CMD_WARNING;
        }
        filter = filter_lookup (access, &p, type, exact);
    }

    /* Looking up filter from access_list. */
    if (filter == NULL)
    {
       vty_out (zlog_default,LOG_DEBUG, "%% access-list %s %s %s doesnt exist%s", 
                 argv[0],
                 strncmp (argv[1], "p", 1) == 0 ? "permit" : "deny",
                 strncmp (argv[2], "a", 1) == 0 ? "any" : argv[2],
                 VTY_NEWLINE);
        return CMD_WARNING;
    }

    /* Delete filter from access_list. */
    access_list_filter_delete (access, filter);

    return CMD_SUCCESS;
}

DEFUN (no_access_list_all,
       no_access_list_all_cmd,
       "no access-list WORD",
       NO_STR
       "Add an access list entry\n"
       "Access-list name\n")
{
    struct access_list *access;

    /* Looking up access_list. */
    access = access_list_lookup (AFI_IP, argv[0]);
    if (access == NULL)
    {
       vty_out (zlog_default,LOG_DEBUG, "%% access-list %s doesnt exist%s", argv[0],
                 VTY_NEWLINE);
        return CMD_WARNING;
    }

    /* Delete all filter from access-list. */
    access_list_delete (access);

    return CMD_SUCCESS;
}

DEFUN (access_list_remark,
       access_list_remark_cmd,
       "access-list WORD remark .LINE",
       "Add an access list entry\n"
       "Access-list name\n"
       "Access list entry comment\n"
       "Comment up to 100 characters\n")
{
    struct access_list *access;
    struct buffer *b;
    int i;

    access = access_list_get (AFI_IP, argv[0]);

    if (access->remark)
    {
        XFREE (MTYPE_TMP, access->remark);
        access->remark = NULL;
    }

    /* Below is remark get codes. */
    b = buffer_new (1024);
    for (i = 1; i < argc; i++)
    {
        buffer_putstr (b, (u_char *)argv[i]);
        buffer_putc (b, ' ');
    }
    buffer_putc (b, '\0');

    access->remark = buffer_getstr (b);

    buffer_free (b);

    return CMD_SUCCESS;
}

DEFUN (no_access_list_remark,
       no_access_list_remark_cmd,
       "no access-list WORD remark",
       NO_STR
       "Add an access list entry\n"
       "Access-list name\n"
       "Access list entry comment\n")
{
    return vty_access_list_remark_unset (vty, AFI_IP, argv[0]);
}


/* Configuration write function. */
int
Bgp::config_write_access_afi (afi_t afi, struct vty *vty)
{
    struct access_list *access;
    struct access_master *master;
    struct filter *filter;
    char buf[BUFSIZ];
    struct prefix *p;
    int write = 0;

    master = access_master_get (afi);
    if (master == NULL)
        return 0;

    for (access = master->num.head; access; access = access->next)
    {
        if (access->remark)
        {
           vty_out (zlog_default,LOG_DEBUG, "%saccess-list %s remark %s%s",
                     afi == AFI_IP ? "" : "ipv6 ",
                     access->name, access->remark,
                     VTY_NEWLINE);
            write++;
        }

        for (filter = access->head; filter; filter = filter->next)
        {
            p = &filter->prefix;

            if (filter->any)
               vty_out (zlog_default,LOG_DEBUG,
                         "%saccess-list %s %s any%s", 
                         afi == AFI_IP ? "" : "ipv6 ",
                         access->name,
                         filter_type_str (filter),
                         VTY_NEWLINE);
            else
               vty_out (zlog_default,LOG_DEBUG,
                         "%saccess-list %s %s %s/%d%s%s", 
                         afi == AFI_IP ? "" : "ipv6 ",
                         access->name,
                         filter_type_str (filter),
                         Bgp::inet_ntop (p->family, &p->u.prefix, buf, BUFSIZ),
                         p->prefixlen,
                         filter->exact ? " exact-match" : "",
                         VTY_NEWLINE);
            write++;
        }
    }

    for (access = master->str.head; access; access = access->next)
    {
        if (access->remark)
        {
           vty_out (zlog_default,LOG_DEBUG, "%saccess-list %s remark %s%s",
                     afi == AFI_IP ? "" : "ipv6 ",
                     access->name, access->remark,
                     VTY_NEWLINE);
            write++;
        }

        for (filter = access->head; filter; filter = filter->next)
        {
            p = &filter->prefix;

            if (filter->any)
               vty_out (zlog_default,LOG_DEBUG,
                         "%saccess-list %s %s any%s", 
                         afi == AFI_IP ? "" : "ipv6 ",
                         access->name,
                         filter_type_str (filter),
                         VTY_NEWLINE);
            else
               vty_out (zlog_default,LOG_DEBUG, 
                         "%saccess-list %s %s %s/%d%s%s", 
                         afi == AFI_IP ? "" : "ipv6 ",
                         access->name,
                         filter_type_str (filter),
                         Bgp::inet_ntop (p->family, &p->u.prefix, buf, BUFSIZ),
                         p->prefixlen,
                         filter->exact ? " exact-match" : "",
                         VTY_NEWLINE);
            write++;
        }
    }
    return write;
}

void
Bgp::access_list_reset_ipv4 ()
{
    struct access_list *access;
    struct access_list *next;
    struct access_master *master;

    master = access_master_get (AFI_IP);
    if (master == NULL)
        return;

    for (access = master->num.head; access; access = next)
    {
        next = access->next;
        access_list_delete (access);
    }
    for (access = master->str.head; access; access = next)
    {
        next = access->next;
        access_list_delete (access);
    }

    assert (master->num.head == NULL);
    assert (master->num.tail == NULL);

    assert (master->str.head == NULL);
    assert (master->str.tail == NULL);
}

/* Install vty related command. */
void
Bgp::access_list_init_ipv4 ()
{
    install_element (CONFIG_NODE, &access_list_exact_cmd);
    install_element (CONFIG_NODE, &access_list_cmd);
    install_element (CONFIG_NODE, &access_list_remark_cmd);
    install_element (CONFIG_NODE, &no_access_list_exact_cmd);
    install_element (CONFIG_NODE, &no_access_list_cmd);
    install_element (CONFIG_NODE, &no_access_list_all_cmd);
    install_element (CONFIG_NODE, &no_access_list_remark_cmd);
    install_element (CONFIG_NODE, &no_access_list_remark_arg_cmd);
}


void
Bgp::access_list_init ()
{
    access_list_init_ipv4 ();

}

void
Bgp::access_list_reset ()
{
    access_list_reset_ipv4 ();

}



////////////////////////////////////////////////
////////////////////////////////////////////////
////////////////////////hash.c//////////////////
////////////////////////////////////////////////



/* Allocate New hash. */
struct Hash *
Bgp::hash_new (int size)
{
    struct Hash *New;

    New = (struct Hash*) XMALLOC (MTYPE_HASH, sizeof (struct Hash));
    bzero (New, sizeof (struct Hash));

    New->index = (struct HashBacket**) XMALLOC (MTYPE_HASH, sizeof (HashBacket *) * size);
    bzero (New->index, sizeof (HashBacket *) * size);

    New->size = size;

    return New;
}

/* allocate New hash backet */
HashBacket *
Bgp::hash_backet_new (void *data)
{
    HashBacket *New;

    New =  (struct HashBacket *) XMALLOC (MTYPE_HASH_BACKET, sizeof (struct HashBacket));
    New->data = data;
    New->next = NULL;

    return New;
}

HashBacket *
Bgp::hash_head (struct Hash *hash, int index)
{
    return hash->index[index];
}

/* Hash search */
void *
Bgp::hash_search (struct Hash *hash, void *data)
{

    if (Bgp::dont_reuse) return NULL;

    unsigned int key;
    HashBacket *backet;

    key = (hash->hash_key) (data);

    if (hash->index[key] == NULL)
        return NULL;

    for (backet = hash->index[key]; backet != NULL; backet = backet->next)
        if ((hash->hash_cmp) (backet->data, data) == 1)
            return backet->data;

    return NULL;
}

/* Push data into hash. */
HashBacket *
Bgp::hash_push (struct Hash *hash, void *data)
{
    unsigned int key;
    HashBacket  *backet, *mp;

    key = (hash->hash_key) (data);
    backet = hash_backet_new (data);

    hash->count++;

    if (hash->index[key] == NULL)
        hash->index[key] = backet;
    else
    {
        for (mp = hash->index[key]; mp->next != NULL; mp = mp->next)
            if ((hash->hash_cmp) (data, mp->data) == 1)
            {
                zlog_info ("hash data [%p] was duplicated!\n", data);
                XFREE (MTYPE_HASH_BACKET, backet);
                return NULL;
            }

        if ((hash->hash_cmp) (data, mp->data) == 1)
        {
            zlog_info ("hash account name [%p] was duplicated!\n", data);
            XFREE (MTYPE_HASH_BACKET, backet);
            return NULL;
        }
        mp->next = backet;
    }
    return backet;
}

/* When deletion is finished successfully return data of delete
   backet. */
void *
Bgp::hash_pull (struct Hash *hash, void *data)
{
    void *ret;
    unsigned int key;
    HashBacket *mp;
    HashBacket *mpp;

    key = (hash->hash_key) (data);

    if (hash->index[key] == NULL)
        return NULL;

    mp = mpp = hash->index[key];
    while (mp)
    {
        if ((hash->hash_cmp) (mp->data, data) == 1)
        {
            if (mp == mpp)
                hash->index[key] = mp->next;
            else
                mpp->next = mp->next;

            ret = mp->data;
            XFREE (MTYPE_HASH_BACKET, mp);
            hash->count--;
            return ret;
        }
        mpp = mp;
        mp = mp->next;
    }
    return NULL;
}

void
Bgp::hash_clean (struct Hash *hash, void (Bgp::* func) (void *))
{
    int i;
    HashBacket *mp;
    HashBacket *next;

    for (i = 0; i < HASHTABSIZE; i++)
    {
        for (mp = hash_head (hash, i); mp; mp = next)
        {
            next = mp->next;

            if (func)
                (this->*func) (mp->data);
            XFREE (MTYPE_HASH_BACKET, mp);
        }
        hash->index[i] = NULL;
    }
}

void
Bgp::Hash_free (struct Hash *hash)
{
    hash_clean (hash, NULL);
    XFREE(MTYPE_HASH, hash->index);
    XFREE(MTYPE_HASH, hash);
}


////////////////////////////////////////////////
////////////////////////////////////////////////
/////////linklist.c/////////////////////////////
////////////////////////////////////////////////

/* Allocate New list. */
struct llist *
Bgp::list_new ()
{
    struct llist *New;

    New =  ( struct llist * ) XMALLOC (MTYPE_LINK_LIST, sizeof (struct llist));
    memset (New, 0, sizeof (struct llist));
    return New;
}

/* Free list. */
void
Bgp::list_free (struct llist *l)
{
    XFREE (MTYPE_LINK_LIST, l);
}

/* Allocate New listnode.  Internal use only. */
struct listnode *
Bgp::listnode_new ()
{
    struct listnode *node;

    node = (struct listnode * ) XMALLOC (MTYPE_LINK_NODE, sizeof (struct listnode));
    memset (node, 0, sizeof (struct listnode));
    return node;
}

/* Free listnode. */
void
Bgp::listnode_free (struct listnode *node)
{
    XFREE (MTYPE_LINK_NODE, node);
}

/* Add New data to the list. */
void
Bgp::listnode_add (struct llist *list, void *val)
{
    struct listnode *node;

    node = listnode_new ();

    node->prev = list->tail;
    node->data = val;

    if (list->head == NULL)
        list->head = node;
    else
        list->tail->next = node;
    list->tail = node;

    list->count++;
}

/* Add New node with sort function. */
void
Bgp::listnode_add_sort (struct llist *list, void *val)
{
    struct listnode *n;
    struct listnode *New;

    New = listnode_new ();
    New->data = val;

    if (list->cmp)
    {
        for (n = list->head; n; n = n->next)
        {
            if ((this->*list->cmp) (val, n->data) < 0)
            {
                New->next = n;
                New->prev = n->prev;

                if (n->prev)
                    n->prev->next = New;
                else
                    list->head = New;
                n->prev = New;
                list->count++;
                return;
            }
        }
    }

    New->prev = list->tail;

    if (list->tail)
        list->tail->next = New;
    else
        list->head = New;

    list->tail = New;
    list->count++;
}

void
Bgp::listnode_add_after (struct llist *list, struct listnode *pp, void *val)
{
    struct listnode *nn;

    nn = listnode_new ();
    nn->data = val;

    if (pp == NULL)
    {
        if (list->head)
            list->head->prev = nn;
        else
            list->tail = nn;

        nn->next = list->head;
        nn->prev = pp;

        list->head = nn;
    } else
    {
        if (pp->next)
            pp->next->prev = nn;
        else
            list->tail = nn;

        nn->next = pp->next;
        nn->prev = pp;

        pp->next = nn;
    }
}


/* Delete specific date pointer from the list. */
void
Bgp::listnode_delete (struct llist *list, void *val)
{
    struct listnode *node;

    for (node = list->head; node; node = node->next)
    {
        if (node->data == val)
        {
            if (node->prev)
                node->prev->next = node->next;
            else
                list->head = node->next;

            if (node->next)
                node->next->prev = node->prev;
            else
                list->tail = node->prev;

            list->count--;
            listnode_free (node);
            return;
        }
    }
}

/* Delete all listnode from the list. */
void
Bgp::list_delete_all_node (struct llist *list)
{
    struct listnode *node;
    struct listnode *next;

    for (node = list->head; node; node = next)
    {
        next = node->next;
        if (list->del)
            (this->*list->del) (node->data);
        listnode_free (node);
    }
    list->head = list->tail = NULL;
    list->count = 0;
}

/* Delete all listnode then free list itself. */
void
Bgp::list_delete (struct llist *list)
{
    struct listnode *node;
    struct listnode *next;

    for (node = list->head; node; node = next)
    {
        next = node->next;
        if (list->del)
            (this->*list->del) (node->data);
        listnode_free (node);
    }
    list_free (list);
}

/* Lookup the node which has given data. */
struct listnode *
Bgp::listnode_lookup (struct llist *list, void *data)
{
    listnode_p node;

    for (node = list->head; node; nextnode (node))
        if (data == getdata (node))
            return node;
    return NULL;
}

/* Delete the node from list.  For ospfd and ospf6d. */
void
Bgp::list_delete_node (list_p list, listnode_p node)
{
    if (node->prev)
        node->prev->next = node->next;
    else
        list->head = node->next;
    if (node->next)
        node->next->prev = node->prev;
    else
        list->tail = node->prev;
    list->count--;
    listnode_free (node);
}

/* ospf_spf.c */
void
Bgp::list_add_node_prev (list_p list, listnode_p current, void *val)
{
    struct listnode *node;

    node = listnode_new ();
    node->next = current;
    node->data = val;

    if (current->prev == NULL)
        list->head = node;
    else
        current->prev->next = node;

    node->prev = current->prev;
    current->prev = node;

    list->count++;
}

/* ospf_spf.c */
void
Bgp::list_add_node_next (list_p list, listnode_p current, void *val)
{
    struct listnode *node;

    node = listnode_new ();
    node->prev = current;
    node->data = val;

    if (current->next == NULL)
        list->tail = node;
    else
        current->next->prev = node;

    node->next = current->next;
    current->next = node;

    list->count++;
}

/* ospf_spf.c */
void
Bgp::list_add_list (struct llist *l, struct llist *m)
{
    struct listnode *n;

    for (n = listhead (m); n; nextnode (n))
        listnode_add (l, n->data);
}



////////////////////////////////////////////////
////////////////////////////////////////////////
///////////log.c////////////////////////////////
////////////////////////////////////////////////


/* Utility routine for current time printing. */ 
void
Bgp::time_print (FILE *fp)
{
    int ret;
    char buf [TIME_BUF];
    time_t clock ; 
    double simulation_time;

    simulation_time = Scheduler::instance().clock();
    clock = start_time + (int) simulation_time;

    ret = strftime (buf, TIME_BUF, "%Y/%m/%d %H:%M:%S",localtime(&clock));
    if (ret == 0)
    {
        zlog_warn ("strftime error\n");
    }

    fprintf (fp, "%s ", buf);
    fprintf (fp," %lf ",simulation_time);
}

/* va_list version of zlog. */
void
Bgp::vzlog (struct zlog *zl, int priority, const char *format, va_list *args)
{
  struct bgp *bgp;    
    char str[INET_ADDRSTRLEN];

    /* If zlog is not specified, use default one. */
    if (zl == NULL)
      zl = zlog_default;    
    
    /* When zlog_default is also NULL, use stderr for logging. */
    if (zl == NULL)
    {
        if(Bgp::use_log_fp_) { 
	  bgp = ( struct bgp * ) bgp_get_default();    
	  fprintf (stderr, "#%s#",Bgp::inet_ntop(AF_INET,&bgp->id,str,sizeof(str)));
        }
        time_print (stderr);
        fprintf (stderr, "%s: ", "unknown");
        vfprintf (stderr, format, args[ZLOG_NOLOG_INDEX]);
        fflush (stderr);

        /* In this case we return at here. */
        return;
    }

    /* only log this information if it has not been masked out */
    if (priority > zl->maskpri)
        return ;

    /* Syslog output */
    /*Removed */

    /* File output. */
    if (zl->flags & ZLOG_FILE)
    {
        if(Bgp::use_log_fp_) { 
	  bgp = ( struct bgp * ) bgp_get_default();    
	  fprintf (zl->fp, "#%s#",Bgp::inet_ntop(AF_INET,&bgp->id,str,sizeof(str)));
        }
        time_print (zl->fp);
        if (zl->record_priority) fprintf (zl->fp, "%s: ", zlog_priority[priority]);
        fprintf (zl->fp, "%s: ", zlog_proto_names[zl->protocol]);
        vfprintf (zl->fp, format, args[ZLOG_FILE_INDEX]);
        fflush (zl->fp);
    }

    /* stdout output. */
    if (zl->flags & ZLOG_STDOUT)
    {
        if(Bgp::use_log_fp_) { 
	  bgp = ( struct bgp * ) bgp_get_default();    	  
	  fprintf (stdout, "#%s#",Bgp::inet_ntop(AF_INET,&bgp->id,str,sizeof(str)));
        }
        time_print (stdout);
        if (zl->record_priority) fprintf (stdout, "%s: ", zlog_priority[priority]);
        fprintf (stdout, "%s: ", zlog_proto_names[zl->protocol]);
        vfprintf (stdout, format, args[ZLOG_STDOUT_INDEX]);
        fflush (stdout);
    }

    /* stderr output. */
    if (zl->flags & ZLOG_STDERR)
    {
        if(Bgp::use_log_fp_) { 
	  bgp = ( struct bgp * ) bgp_get_default();    	  
	  fprintf (stderr, "#%s#",Bgp::inet_ntop(AF_INET,&bgp->id,str,sizeof(str)));
        }
        time_print (stderr);
        if (zl->record_priority) fprintf (stderr, "%s: ", zlog_priority[priority]);
        fprintf (stderr, "%s: ", zlog_proto_names[zl->protocol]);
        vfprintf (stderr, format, args[ZLOG_STDERR_INDEX]);
        fflush (stderr);
    }
}

void
Bgp::zlog (struct zlog *zl, int priority, const char *format, ...)
{
    va_list args[ZLOG_MAX_INDEX];
    int index;

    for (index = 0; index < ZLOG_MAX_INDEX; index++)
        va_start(args[index], format);

    vzlog (zl, priority, format, args);

    for (index = 0; index < ZLOG_MAX_INDEX; index++)
        va_end (args[index]);
}

void
Bgp::zlog_err (const char *format, ...)
{
    va_list args[ZLOG_MAX_INDEX];
    int index;

    for (index = 0; index < ZLOG_MAX_INDEX; index++)
        va_start(args[index], format);

    vzlog (NULL, LOG_ERR, format, args);

    for (index = 0; index < ZLOG_MAX_INDEX; index++)
        va_end (args[index]);
}

void
Bgp::zlog_warn (const char *format, ...)
{
    va_list args[ZLOG_MAX_INDEX];
    int index;

    for (index = 0; index < ZLOG_MAX_INDEX; index++)
        va_start(args[index], format);

    vzlog (NULL, LOG_WARNING, format, args);

    for (index = 0; index < ZLOG_MAX_INDEX; index++)
        va_end (args[index]);
}

void
Bgp::zlog_info (const char *format, ...)
{
    va_list args[ZLOG_MAX_INDEX];
    int index;

    for (index = 0; index < ZLOG_MAX_INDEX; index++)
        va_start(args[index], format);

    vzlog (NULL, LOG_INFO, format, args);

    for (index = 0; index < ZLOG_MAX_INDEX; index++)
        va_end (args[index]);
}

void
Bgp::zlog_notice (const char *format, ...)
{
    va_list args[ZLOG_MAX_INDEX];
    int index;

    for (index = 0; index < ZLOG_MAX_INDEX; index++)
        va_start(args[index], format);

    vzlog (NULL, LOG_NOTICE, format, args);

    for (index = 0; index < ZLOG_MAX_INDEX; index++)
        va_end (args[index]);
}

void
Bgp::zlog_debug (const char *format, ...)
{
    va_list args[ZLOG_MAX_INDEX];
    int index;

    for (index = 0; index < ZLOG_MAX_INDEX; index++)
        va_start(args[index], format);

    vzlog (NULL, LOG_DEBUG, format, args);

    for (index = 0; index < ZLOG_MAX_INDEX; index++)
        va_end (args[index]);
}

void
Bgp::plog_err (struct zlog *zl, const char *format, ...)
{
    va_list args[ZLOG_MAX_INDEX];
    int index;

    for (index = 0; index < ZLOG_MAX_INDEX; index++)
        va_start(args[index], format);

    vzlog (zl, LOG_ERR, format, args);

    for (index = 0; index < ZLOG_MAX_INDEX; index++)
        va_end (args[index]);
}

void
Bgp::plog_warn (struct zlog *zl, const char *format, ...)
{
    va_list args[ZLOG_MAX_INDEX];
    int index;

    for (index = 0; index < ZLOG_MAX_INDEX; index++)
        va_start(args[index], format);

    vzlog (zl, LOG_WARNING, format, args);

    for (index = 0; index < ZLOG_MAX_INDEX; index++)
        va_end (args[index]);
}

void
Bgp::plog_info (struct zlog *zl, const char *format, ...)
{
    va_list args[ZLOG_MAX_INDEX];
    int index;

    for (index = 0; index < ZLOG_MAX_INDEX; index++)
        va_start(args[index], format);

    vzlog (zl, LOG_INFO, format, args);

    for (index = 0; index < ZLOG_MAX_INDEX; index++)
        va_end (args[index]);
}

void
Bgp::plog_notice (struct zlog *zl, const char *format, ...)
{
    va_list args[ZLOG_MAX_INDEX];
    int index;

    for (index = 0; index < ZLOG_MAX_INDEX; index++)
        va_start(args[index], format);

    vzlog (zl, LOG_NOTICE, format, args);

    for (index = 0; index < ZLOG_MAX_INDEX; index++)
        va_end (args[index]);
}

void
Bgp::plog_debug (struct zlog *zl, const char *format, ...)
{
    va_list args[ZLOG_MAX_INDEX];
    int index;

    for (index = 0; index < ZLOG_MAX_INDEX; index++)
        va_start(args[index], format);

    vzlog (zl, LOG_DEBUG, format, args);

    for (index = 0; index < ZLOG_MAX_INDEX; index++)
        va_end (args[index]);
}


/* Open log stream */
struct zlog *
Bgp::openzlog (const char *progname, int flags, zlog_proto_t protocol,
               int syslog_flags, int syslog_facility)
{
    struct zlog *zl;

    zl = ( struct zlog * ) XMALLOC(MTYPE_ZLOG, sizeof (struct zlog));   
    memset (zl, 0, sizeof (struct zlog));

    zl->ident = progname;
    zl->flags = flags;
    zl->protocol = protocol;
    zl->facility = syslog_facility;
    zl->maskpri = LOG_DEBUG;
    zl->record_priority = 0;

    return zl;
}

void
Bgp::closezlog (struct zlog *zl)
{
    fclose (zl->fp);

    XFREE (MTYPE_ZLOG, zl);
}

/* Called from command.c. */
void
Bgp::zlog_set_flag (struct zlog *zl, int flags)
{
    if (zl == NULL)
        zl = zlog_default;

    zl->flags |= flags;
}

void
Bgp::zlog_reset_flag (struct zlog *zl, int flags)
{
    if (zl == NULL)
        zl = zlog_default;

    zl->flags &= ~flags;
}

int
Bgp::zlog_set_file (struct zlog *zl, int flags, char *filename)
{
    FILE *fp;

    /* There is opend file.  */
    zlog_reset_file (zl);

    /* Set default zl. */
    if (zl == NULL)
        zl = zlog_default;

    /* Open file. */
    if(Bgp::use_log_fp_) {
      filename = Bgp::use_log_file_;    
      fp = Bgp::use_log_fp_;
    } else {
      fp = fopen (filename, "w");
    }
    
    if (fp == NULL)
        return 0;

    /* Set flags. */
    zl->filename = strdup (filename);
    zl->flags |= ZLOG_FILE;
    zl->fp = fp;

    return 1;
}

/* Reset opend file. */
int
Bgp::zlog_reset_file (struct zlog *zl)
{
    if (zl == NULL)
        zl = zlog_default;

    zl->flags &= ~ZLOG_FILE;

    if (zl->fp)
        fclose (zl->fp);
    zl->fp = NULL;

    if (zl->filename)
        free (zl->filename);
    zl->filename = NULL;

    return 1;
}

/* Reopen log file. */
int
Bgp::zlog_rotate (struct zlog *zl)
{
    FILE *fp;

    if (zl == NULL)
        zl = zlog_default;

    if (zl->fp)
        fclose (zl->fp);
    zl->fp = NULL;

    if (zl->filename)
    {
        fp = fopen (zl->filename, "a");
        if (fp == NULL)
            return -1;
        zl->fp = fp;
    }

    return 1;
}


/* Message lookup function. */
char *
Bgp::lookup (struct message *mes, int key)
{
    struct message *pnt;

    for (pnt = mes; pnt->key != 0; pnt++)
        if (pnt->key == key)
            return pnt->str;

    return "";
}

/* Very old hacky version of message lookup function.  Still partly
   used in bgpd and ospfd. */
char *
Bgp::mes_lookup (struct message *meslist, int max, int index)
{
    if (index < 0 || index >= max)
    {
        zlog_err ("message index out of bound: %d\n", max);
        return NULL;
    }
    return meslist[index].str;
}


////////////////////////////////////////////////
////////////////////////////////////////////////
//////////memory.c//////////////////////////////
////////////////////////////////////////////////

/* Fatal memory allocation error occured. */
void
Bgp::zerror (const char *fname, int type, size_t size)
{
    fprintf (stderr, "%s : can't allocate memory for `%s' size %d\n", 
             fname, lookup (mstr, type), (int) size);
    exit (1);
}


/* Memory allocation. */
void *
Bgp::zmalloc (int type, size_t size)
{
    void *memory;

    memory = malloc (size);

    if (memory == NULL)
        zerror ("malloc", type, size);

    alloc_inc (type);

    return memory;
}

/* Memory allocation with num * size with cleared. */
void *
Bgp::zcalloc (int type, size_t size)
{
    void *memory;

    memory = calloc (1, size);

    if (memory == NULL)
        zerror ("calloc", type, size);

    alloc_inc (type);

    return memory;
}

/* Memory reallocation. */
void *
Bgp::zrealloc (int type, void *ptr, size_t size)
{
    void *memory;

    memory = realloc (ptr, size);
    if (memory == NULL)
        zerror ("realloc", type, size);
    return memory;
}

/* Memory free. */
void
Bgp::zfree (int type, void *ptr)
{
    alloc_dec (type);
    free (ptr);
}

/* String duplication. */
char *
Bgp::zstrdup (int type, char *str)
{
    void *dup;

    dup = strdup (str);
    if (dup == NULL)
        zerror ("strdup", type, strlen (str));
    alloc_inc (type);
    return(char*) dup;
}

#ifdef MEMORY_LOG

void
Bgp::mtype_log (char *func, void *memory, const char *file, int line, int type)
{
  zlog_info ("%s: %s %p %s %d", func, lookup (mstr, type), memory, file, line);
}

void *
Bgp::mtype_zmalloc (const char *file, int line, int type, size_t size)
{
    void *memory;

    mstat[type].c_malloc++;
    mstat[type].t_malloc++;

    memory = zmalloc (type, size);
    mtype_log ("zmalloc", memory, file, line, type);

    return memory;
}

void *
Bgp::mtype_zcalloc (const char *file, int line, int type, size_t size)
{
    void *memory;

    mstat[type].c_calloc++;
    mstat[type].t_calloc++;

    memory = zcalloc (type, size);
    mtype_log ("xcalloc", memory, file, line, type);

    return memory;
}

void *
Bgp::mtype_zrealloc (const char *file, int line, int type, void *ptr, size_t size)
{
    void *memory;

    /* Realloc need before allocated pointer. */
    mstat[type].t_realloc++;

    memory = zrealloc (type, ptr, size);

    mtype_log ("xrealloc", memory, file, line, type);

    return memory;
}

/* Important function. */
void 
Bgp::mtype_zfree (const char *file, int line, int type, void *ptr)
{
    mstat[type].t_free++;

    mtype_log ("xfree", ptr, file, line, type);

    zfree (type, ptr);
}

char *
Bgp::mtype_zstrdup (const char *file, int line, int type, char *str)
{
    char *memory;

    mstat[type].c_strdup++;

    memory = zstrdup (type, str);

    mtype_log ("xstrdup", memory, file, line, type);

    return memory;
}
#endif  /* MEMORY_LOG */

/* Increment allocation counter. */
void
Bgp::alloc_inc (int type)
{
    mstat[type].alloc++;
}

/* Decrement allocation counter. */
void
Bgp::alloc_dec (int type)
{
    mstat[type].alloc--;
}

void
Bgp::show_memory_zlog (struct memory_list *list)
{
    struct memory_list *m;

    for (m = list; m->index >= 0; m++) {
      if (m->index == 0)
	zlog (NULL,LOG_INFO, m->format);
      else  { 
	if (m->size) 
	  zlog (NULL,LOG_INFO, m->format, mstat[m->index].alloc,mstat[m->index].alloc*m->size);
	else
	  zlog (NULL,LOG_INFO, m->format, mstat[m->index].alloc);
      }
    }
}

DEFUN (show_memory_all,
       show_memory_all_cmd,
       "show memory all",
       "Show running system information\n"
       "Memory statistics\n"
       "All memory statistics\n")
{
    show_memory_zlog (memory_list_lib);
    show_memory_zlog (memory_list_separator);
    show_memory_zlog (memory_list_bgp);

    return CMD_SUCCESS;
}

DEFUN (show_memory_lib,
       show_memory_lib_cmd,
       "show memory lib",
       SHOW_STR
       "Memory statistics\n"
       "Library memory\n")
{
    show_memory_zlog (memory_list_lib);
    return CMD_SUCCESS;
}

DEFUN (show_memory_bgp,
       show_memory_bgp_cmd,
       "show memory bgp",
       SHOW_STR
       "Memory statistics\n"
       "BGP memory\n")
{
    show_memory_zlog (memory_list_bgp);
    return CMD_SUCCESS;
}

void
Bgp::memory_init ()
{
    install_element (CONFIG_NODE, &show_memory_cmd);
    install_element (CONFIG_NODE, &show_memory_all_cmd);
    install_element (CONFIG_NODE, &show_memory_lib_cmd);
    install_element (CONFIG_NODE, &show_memory_bgp_cmd);
}



////////////////////////////////////////////////
////////////////////////////////////////////////
//////////network.c/////////////////////////////
////////////////////////////////////////////////


/* Read nbytes from fd and store into ptr. */
int
Bgp::readn (int fd, char *ptr, int nbytes)
{
    int nleft;
    int nread;

    nleft = nbytes;

    while (nleft > 0)
    {
        nread = ReceivedMsg.Get(nleft,ptr);
        if (nread < 0)
            return(nread);
        else
            if (nread == 0)
            break;

        nleft -= nread;
        ptr += nread;
    }

    return nbytes - nleft;
}  

int
Bgp::peer_writen(struct peer* peer, char *ptr, int nbytes)
{
    if (0) printf("%s: sending %d bytes",name(),nbytes);
    RouteMsg msg(nbytes,ptr);
    return sendMessage(msg,peer);
}


////////////////////////////////////////////////
////////////////////////////////////////////////
/////plist.c////////////////////////////////////
////////////////////////////////////////////////

struct prefix_master *
Bgp::prefix_master_get (afi_t afi)
{
    if (afi == AFI_IP)
        return &prefix_master_ipv4;
    return NULL;
}

/* Lookup prefix_list from list of prefix_list by name. */
struct prefix_list *
Bgp::prefix_list_lookup (afi_t afi, char *name)
{
    struct prefix_list *plist;
    struct prefix_master *master;

    if (name == NULL)
        return NULL;

    master = prefix_master_get (afi);
    if (master == NULL)
        return NULL;

    for (plist = master->num.head; plist; plist = plist->next)
        if (strcmp (plist->name, name) == 0)
            return plist;

    for (plist = master->str.head; plist; plist = plist->next)
        if (strcmp (plist->name, name) == 0)
            return plist;

    return NULL;
}

struct prefix_list *
Bgp::prefix_list_new ()
{
    struct prefix_list *New;

    New = ( struct prefix_list * ) XMALLOC (MTYPE_PREFIX_LIST, sizeof (struct prefix_list));
    bzero (New, sizeof (struct prefix_list));
    return New;
}

void
Bgp::prefix_list_free (struct prefix_list *plist)
{
    XFREE (MTYPE_PREFIX_LIST, plist);
}

struct prefix_list_entry *
Bgp::prefix_list_entry_new ()
{
    struct prefix_list_entry *New;

    New = ( struct prefix_list_entry * ) XMALLOC (MTYPE_PREFIX_LIST_ENTRY, sizeof (struct prefix_list_entry));
    bzero (New, sizeof (struct prefix_list_entry));
    return New;
}

void
Bgp::prefix_list_entry_free (struct prefix_list_entry *pentry)
{
    XFREE (MTYPE_PREFIX_LIST_ENTRY, pentry);
}

/* Insert New prefix list to list of prefix_list.  Each prefix_list
   is sorted by the name. */
struct prefix_list *
Bgp::prefix_list_insert (afi_t afi, char *name)
{
    int i;
    long number;
    struct prefix_list *plist;
    struct prefix_list *point;
    struct prefix_list_list *list;
    struct prefix_master *master;

    master = prefix_master_get (afi);
    if (master == NULL)
        return NULL;

    /* Allocate New prefix_list and copy given name. */
    plist = prefix_list_new ();
    plist->name = XSTRDUP (MTYPE_PREFIX_LIST_STR, name);
    plist->master = master;

    /* If name is made by all digit character.  We treat it as
       number. */
    for (number = 0, i = 0; i < strlen (name); i++)
    {
        if (isdigit ((int) name[i]))
            number = (number * 10) + (name[i] - '0');
        else
            break;
    }

    /* In case of name is all digit character */
    if (i == strlen (name))
    {
        plist->type = PREFIX_TYPE_NUMBER;

        /* Set prefix_list to number list. */
        list = &master->num;

        for (point = list->head; point; point = point->next)
            if (atol (point->name) >= number)
                break;
    } else
    {
        plist->type = PREFIX_TYPE_STRING;

        /* Set prefix_list to string list. */
        list = &master->str;

        /* Set point to insertion point. */
        for (point = list->head; point; point = point->next)
            if (strcmp (point->name, name) >= 0)
                break;
    }

    /* In case of this is the first element of master. */
    if (list->head == NULL)
    {
        list->head = list->tail = plist;
        return plist;
    }

    /* In case of insertion is made at the tail of access_list. */
    if (point == NULL)
    {
        plist->prev = list->tail;
        list->tail->next = plist;
        list->tail = plist;
        return plist;
    }

    /* In case of insertion is made at the head of access_list. */
    if (point == list->head)
    {
        plist->next = list->head;
        list->head->prev = plist;
        list->head = plist;
        return plist;
    }

    /* Insertion is made at middle of the access_list. */
    plist->next = point;
    plist->prev = point->prev;

    if (point->prev)
        point->prev->next = plist;
    point->prev = plist;

    return plist;
}

struct prefix_list *
Bgp::prefix_list_get (afi_t afi, char *name)
{
    struct prefix_list *plist;

    plist = prefix_list_lookup (afi, name);

    if (plist == NULL)
        plist = prefix_list_insert (afi, name);
    return plist;
}

/* Delete prefix-list from prefix_list_master and free it. */
void
Bgp::prefix_list_delete (struct prefix_list *plist)
{
    struct prefix_list_list *list;
    struct prefix_master *master;
    struct prefix_list_entry *pentry;
    struct prefix_list_entry *next;

    /* If prefix-list contain prefix_list_entry free all of it. */
    for (pentry = plist->head; pentry; pentry = next)
    {
        next = pentry->next;
        prefix_list_entry_free (pentry);
        plist->count--;
    }

    master = plist->master;

    if (plist->type == PREFIX_TYPE_NUMBER)
        list = &master->num;
    else
        list = &master->str;

    if (plist->next)
        plist->next->prev = plist->prev;
    else
        list->tail = plist->prev;

    if (plist->prev)
        plist->prev->next = plist->next;
    else
        list->head = plist->next;

    if (plist->desc)
        XFREE (MTYPE_TMP, plist->desc);

    /* Make sure master's recent changed prefix-list information is
       cleared. */
    master->recent = NULL;

    if (plist->name)
        XFREE (MTYPE_PREFIX_LIST_STR, plist->name);

    prefix_list_free (plist);

    if (master->delete_hook)
        (this->*master->delete_hook) ();
}

struct prefix_list_entry *
Bgp::prefix_list_entry_make (struct prefix *prefix, enum prefix_list_type type,
                             int seq, int le, int ge)
{
    struct prefix_list_entry *pentry;

    pentry = prefix_list_entry_new ();

    /* If prefix is NULL then this is "any" match directive. */
    if (prefix == NULL)
        pentry->any = 1;
    else
        prefix_copy (&pentry->prefix, prefix);

    pentry->type = type;
    pentry->seq = seq;
    pentry->le = le;
    pentry->ge = ge;

    return pentry;
}

/* Add hook function. */
void
Bgp::prefix_list_add_hook (void (Bgp::*func) ())
{
    prefix_master_ipv4.add_hook = func;

}

/* Delete hook function. */
void
Bgp::prefix_list_delete_hook (void (Bgp::*func) ())
{
    prefix_master_ipv4.delete_hook = func;

}

/* Calculate New sequential number. */
int
Bgp::prefix_new_seq_get (struct prefix_list *plist)
{
    int maxseq;
    int newseq;
    struct prefix_list_entry *pentry;

    maxseq = newseq = 0;

    for (pentry = plist->head; pentry; pentry = pentry->next)
    {
        if (maxseq < pentry->seq)
            maxseq = pentry->seq;
    }

    newseq = ((maxseq / 5) * 5) + 5;

    return newseq;
}

/* Return prefix list entry which has same seq number. */
struct prefix_list_entry *
Bgp::prefix_seq_check (struct prefix_list *plist, int seq)
{
    struct prefix_list_entry *pentry;

    for (pentry = plist->head; pentry; pentry = pentry->next)
        if (pentry->seq == seq)
            return pentry;
    return NULL;
}

struct prefix_list_entry *
Bgp::prefix_list_entry_lookup (struct prefix_list *plist, struct prefix *prefix,
                               enum prefix_list_type type, int seq, int le, int ge)
{
    struct prefix_list_entry *pentry;

    for (pentry = plist->head; pentry; pentry = pentry->next)
    {
        if (prefix == NULL)
        {
            if (pentry->any == 1 && pentry->type == type)
            {
                if (seq >= 0 && pentry->seq != seq)
                    continue;

                if (pentry->le != le)
                    continue;
                if (pentry->ge != ge)
                    continue;

                return pentry;
            }
        } else
        {
            if (prefix_same (&pentry->prefix, prefix) && pentry->type == type)
            {
                if (seq >= 0 && pentry->seq != seq)
                    continue;

                if (pentry->le != le)
                    continue;
                if (pentry->ge != ge)
                    continue;

                return pentry;
            }
        }
    }

    return NULL;
}

void
Bgp::prefix_list_entry_delete (struct prefix_list *plist, 
                               struct prefix_list_entry *pentry)
{
    if (plist == NULL || pentry == NULL)
        return;
    if (pentry->prev)
        pentry->prev->next = pentry->next;
    else
        plist->head = pentry->next;
    if (pentry->next)
        pentry->next->prev = pentry->prev;
    else
        plist->tail = pentry->prev;

    prefix_list_entry_free (pentry);

    plist->count--;

    if (plist->master->delete_hook)
        (this->*plist->master->delete_hook) ();

    if (plist->head == NULL && plist->tail == NULL && plist->desc == NULL)
        prefix_list_delete (plist);
    else
        plist->master->recent = plist;
}

void
Bgp::prefix_list_entry_add (struct prefix_list *plist,
                            struct prefix_list_entry *pentry)
{
    struct prefix_list_entry *replace;
    struct prefix_list_entry *point;

    /* Automatic asignment of seq no. */
    if (pentry->seq == -1)
        pentry->seq = prefix_new_seq_get (plist);

    /* Is there any same seq prefix list entry? */
    replace = prefix_seq_check (plist, pentry->seq);
    if (replace)
        prefix_list_entry_delete (plist, replace);

    /* Check insert point. */
    for (point = plist->head; point; point = point->next)
        if (point->seq >= pentry->seq)
            break;

        /* In case of this is the first element of the list. */
    pentry->next = point;

    if (point)
    {
        if (point->prev)
            point->prev->next = pentry;
        else
            plist->head = pentry;

        pentry->prev = point->prev;
        point->prev = pentry;
    } else
    {
        if (plist->tail)
            plist->tail->next = pentry;
        else
            plist->head = pentry;

        pentry->prev = plist->tail;
        plist->tail = pentry;
    }

    /* Increment count. */
    plist->count++;

    /* Run hook function. */
    if (plist->master->add_hook)
        (this->*plist->master->add_hook) ();

    plist->master->recent = plist;
}

/* Return string of prefix_list_type. */
char *
Bgp::prefix_list_type_str (struct prefix_list_entry *pentry)
{
    switch (pentry->type)
    {
    case PREFIX_PERMIT:
        return "permit";
        break;
    case PREFIX_DENY:
        return "deny";
        break;
    default:
        return "";
        break;
    }
}

int
Bgp::prefix_list_entry_match (struct prefix_list_entry *pentry, struct prefix *p)
{
    int ret;

    /* This is any entry. */
    if (pentry->any)
        return 1;

    ret = prefix_match (&pentry->prefix, p);
    if (! ret)
        return 0;

    /* In case of le nor ge is specified, exact match is performed. */
    if (pentry->le < 0 && pentry->ge < 0)
    {
        if (pentry->prefix.prefixlen != p->prefixlen)
            return 0;
    } else
    {
        if (pentry->le >= 0)
            if (p->prefixlen > pentry->le)
                return 0;

        if (pentry->ge >= 0)
            if (p->prefixlen < pentry->ge)
                return 0;
    }
    return 1;
}

enum prefix_list_type
Bgp::prefix_list_apply (struct prefix_list *plist, void *object)
{
    struct prefix_list_entry *pentry;
    struct prefix *p;

    p = (struct prefix *) object;

    if (plist == NULL)
        return PREFIX_DENY;

    if (plist->count == 0)
        return PREFIX_PERMIT;

    for (pentry = plist->head; pentry; pentry = pentry->next)
    {
        pentry->refcnt++;
        if (prefix_list_entry_match (pentry, p))
        {
            pentry->hitcnt++;
            return pentry->type;
        }
    }

    return PREFIX_DENY;
}

void
Bgp::prefix_list_print (struct prefix_list *plist)
{
    struct prefix_list_entry *pentry;

    if (plist == NULL)
        return;

    printf ("ip prefix-list %s: %d entries\n", plist->name, plist->count);

    for (pentry = plist->head; pentry; pentry = pentry->next)
    {
        if (pentry->any)
            printf ("any %s\n", prefix_list_type_str (pentry));
        else
        {
            struct prefix *p;
            char buf[BUFSIZ];

            p = &pentry->prefix;

            printf ("  seq %d %s %s/%d", 
                    pentry->seq,
                    prefix_list_type_str (pentry),
                    Bgp::inet_ntop (p->family, &p->u.prefix, buf, BUFSIZ),
                    p->prefixlen);
            if (pentry->ge >= 0)
                printf (" ge %d", pentry->ge);
            if (pentry->le >= 0)
                printf (" le %d", pentry->le);
            printf ("\n");
        }
    }
}

/* Retrun 1 when plist already include pentry policy. */
struct prefix_list_entry *
Bgp::prefix_entry_dup_check (struct prefix_list *plist,
                             struct prefix_list_entry *New)
{
    struct prefix_list_entry *pentry;
    int seq = 0;

    if (New->seq == -1)
        seq = prefix_new_seq_get (plist);
    else
        seq = New->seq;

    for (pentry = plist->head; pentry; pentry = pentry->next)
    {
        if ((pentry->any == New->any)
            && prefix_same (&pentry->prefix, &New->prefix)
            && pentry->type == New->type
            && pentry->le == New->le
            && pentry->ge == New->ge
            && pentry->seq != seq)
            return pentry;
    }
    return NULL;
}

int
Bgp::vty_prefix_list_install (struct vty *vty, afi_t afi,
                              char *name, char *seq, char *typestr,
                              char *prefix, char *ge, char *le)
{
    int ret;
    enum prefix_list_type type;
    struct prefix_list *plist;
    struct prefix_list_entry *pentry;
    struct prefix_list_entry *dup;
    struct prefix p;
    int any = 0;
    int seqnum = -1;
    int lenum = -1;
    int genum = -1;

    /* Sequential number. */
    if (seq)
        seqnum = atoi (seq);

    /* Check filter type. */
    if (strncmp ("permit", typestr, 1) == 0)
        type = PREFIX_PERMIT;
    else if (strncmp ("deny", typestr, 1) == 0)
        type = PREFIX_DENY;
    else
    {
       vty_out (zlog_default,LOG_DEBUG, "%% prefix type must be permit or deny%s", VTY_NEWLINE);
        return CMD_WARNING;
    }

    /* "any" is special token for matching any IPv4 addresses.  */
    if (strncmp ("any", prefix, strlen (prefix)) == 0)
        any = 1;
    else
    {
        if (afi == AFI_IP)
        {
            ret = str2prefix_ipv4 (prefix, (struct prefix_ipv4 *) &p);
            if (ret <= 0)
            {
               vty_out (zlog_default,LOG_DEBUG, "%% Malformed IPv4 prefix%s", VTY_NEWLINE);
                return CMD_WARNING;
            }
        }

    }

    /* ge and le check. */
    if (ge)
    {
        genum = atoi (ge);
        if (! any && genum <= p.prefixlen)
        {
           vty_out (zlog_default,LOG_DEBUG, "%% Invalid prefix range for %s, make sure: len < ge-value <= le-value%s",
                     prefix, VTY_NEWLINE);
            return CMD_WARNING;
        }
    }

    if (le)
    {
        lenum = atoi (le);
        if (! any && lenum <= p.prefixlen)
        {
           vty_out (zlog_default,LOG_DEBUG, "%% Invalid prefix range for %s, make sure: len < ge-value <= le-value%s",
                     prefix, VTY_NEWLINE);
            return CMD_WARNING;
        }
    }

    if (ge && le)
    {
        if (genum > lenum)
        {
           vty_out (zlog_default,LOG_DEBUG, "%% Invalid prefix range for %s, make sure: len < ge-value <= le-value%s",
                     prefix, VTY_NEWLINE);
            return CMD_WARNING;
        }
    }

    if (ge && le)
        if (lenum == (afi == AFI_IP ? 32 : 128))
        {
            le = NULL;
            lenum = -1;
        }

        /* Get prefix_list with name. */
    plist = prefix_list_get (afi, name);

    /* Make prefix entry. */
    if (any)
        pentry = prefix_list_entry_make (NULL, type, seqnum, lenum, genum);
    else
        pentry = prefix_list_entry_make (&p, type, seqnum, lenum, genum);

    /* Check same policy. */
    dup = prefix_entry_dup_check (plist, pentry);

    if (dup)
    {
        prefix_list_entry_free (pentry);
       vty_out (zlog_default,LOG_DEBUG, "%% Insertion failed - prefix-list entry exists:%s",
                 VTY_NEWLINE);
       vty_out (zlog_default,LOG_DEBUG, "   seq %d %s %s%s%s%s%s%s",
                 dup->seq, typestr, prefix,
                 ge ? " ge " : "", ge ? ge : "",
                 le ? " le " : "", le ? le : "",
                 VTY_NEWLINE);
        return CMD_WARNING;
    }

    /* Install New filter to the access_list. */
    prefix_list_entry_add (plist, pentry);

    return CMD_SUCCESS;
}

int
Bgp::vty_prefix_list_uninstall (struct vty *vty, afi_t afi,
                                char *name, char *seq, char *typestr,
                                char *prefix, char *ge, char *le)
{
    int ret;
    enum prefix_list_type type;
    struct prefix_list *plist;
    struct prefix_list_entry *pentry;
    struct prefix p;
    int any = 0;
    int seqnum = -1;
    int lenum = -1;
    int genum = -1;

    /* Check prefix list name. */
    plist = prefix_list_lookup (afi, name);
    if (! plist)
    {
       vty_out (zlog_default,LOG_DEBUG, "%% Cant find specified prefix-list%s", VTY_NEWLINE);
        return CMD_WARNING;
    }

    /* Only prefix-list name specified, delete the entire prefix-list. */
    if (seq == NULL && typestr == NULL && prefix == NULL && 
        ge == NULL && le == NULL)
    {
        prefix_list_delete (plist);
        return CMD_SUCCESS;
    }

    /* Check sequence number. */
    if (seq)
        seqnum = atoi (seq);

    /* Check of filter type. */
    if (strncmp ("permit", typestr, 1) == 0)
        type = PREFIX_PERMIT;
    else if (strncmp ("deny", typestr, 1) == 0)
        type = PREFIX_DENY;
    else
    {
       vty_out (zlog_default,LOG_DEBUG, "%% prefix type must be permit or deny%s", VTY_NEWLINE);
        return CMD_WARNING;
    }

    /* "any" is special token of matching IP addresses.  */
    if (strncmp ("any", prefix, strlen (prefix)) == 0)
        any = 1;
    else
    {
        if (afi == AFI_IP)
        {
            ret = str2prefix_ipv4 (prefix, (struct prefix_ipv4 *) &p);
            if (ret <= 0)
            {
               vty_out (zlog_default,LOG_DEBUG, "%% Malformed IPv4 prefix%s", VTY_NEWLINE);
                return CMD_WARNING;
            }
        }

    }
    /* ge and le check. */
    if (ge)
        genum = atoi (ge);

    if (le)
        lenum = atoi (le);

    /* Lookup prefix entry. */
    if (any)
        pentry = prefix_list_entry_lookup(plist, NULL, type, seqnum, lenum, genum);
    else
        pentry = prefix_list_entry_lookup(plist, &p, type, seqnum, lenum, genum);

    if (pentry == NULL)
    {
       vty_out (zlog_default,LOG_DEBUG, "%% Cant find specified prefix-list%s", VTY_NEWLINE);
        return CMD_WARNING;
    }

    /* Install New filter to the access_list. */
    prefix_list_entry_delete (plist, pentry);

    return CMD_SUCCESS;
}

int
Bgp::vty_prefix_list_desc_unset (struct vty *vty, afi_t afi, char *name)
{
    struct prefix_list *plist;

    plist = prefix_list_lookup (afi, name);
    if (! plist)
    {
       vty_out (zlog_default,LOG_DEBUG, "%% Cant find specified prefix-list%s", VTY_NEWLINE);
        return CMD_WARNING;
    }

    if (plist->desc)
    {
        XFREE (MTYPE_TMP, plist->desc);
        plist->desc = NULL;
    }

    if (plist->head == NULL && plist->tail == NULL && plist->desc == NULL)
        prefix_list_delete (plist);

    return CMD_SUCCESS;
}









void
Bgp::vty_show_prefix_entry (struct vty *vty, afi_t afi, struct prefix_list *plist,
                            struct prefix_master *master, enum display_type dtype,
                            int seqnum)
{
    struct prefix_list_entry *pentry;

    if (dtype == normal_display)
    {
       vty_out (zlog_default,LOG_DEBUG, "ip%s prefix-list %s: %d entries%s",
                 afi == AFI_IP ? "" : "v6",
                 plist->name, plist->count, VTY_NEWLINE);
        if (plist->desc)
           vty_out (zlog_default,LOG_DEBUG, "   Description: %s%s", plist->desc, VTY_NEWLINE);
    } else if (dtype == summary_display || dtype == detail_display)
    {
       vty_out (zlog_default,LOG_DEBUG, "ip%s prefix-list %s:%s",
                 afi == AFI_IP ? "" : "v6", plist->name, VTY_NEWLINE);

        if (plist->desc)
           vty_out (zlog_default,LOG_DEBUG, "   Description: %s%s", plist->desc, VTY_NEWLINE);

       vty_out (zlog_default,LOG_DEBUG, "   count: %d, range entries: %d, sequences: %d - %d%s",
                 plist->count, plist->rangecount, 
                 plist->head ? plist->head->seq : 0, 
                 plist->tail ? plist->tail->seq : 0,
                 VTY_NEWLINE);
    }

    if (dtype != summary_display)
    {
        for (pentry = plist->head; pentry; pentry = pentry->next)
        {
            if (dtype == sequential_display && pentry->seq != seqnum)
                continue;

           vty_out (zlog_default,LOG_DEBUG, "   ");

            if (master->seqnum)
               vty_out (zlog_default,LOG_DEBUG, "seq %d ", pentry->seq);

           vty_out (zlog_default,LOG_DEBUG, "%s ", prefix_list_type_str (pentry));

            if (pentry->any)
               vty_out (zlog_default,LOG_DEBUG, "any");
            else
            {
                struct prefix *p = &pentry->prefix;
                char buf[BUFSIZ];

               vty_out (zlog_default,LOG_DEBUG, "%s/%d",
                         Bgp::inet_ntop (p->family, &p->u.prefix, buf, BUFSIZ),
                         p->prefixlen);
            }

            if (pentry->ge >= 0)
               vty_out (zlog_default,LOG_DEBUG, " ge %d", pentry->ge);
            if (pentry->le >= 0)
               vty_out (zlog_default,LOG_DEBUG, " le %d", pentry->le);

            if (dtype == detail_display || dtype == sequential_display)
               vty_out (zlog_default,LOG_DEBUG, " (hit count: %ld, refcount: %ld)", 
                         pentry->hitcnt, pentry->refcnt);

           vty_out (zlog_default,LOG_DEBUG, "%s", VTY_NEWLINE);
        }
    }
}

int
Bgp::vty_show_prefix_list (struct vty *vty, afi_t afi, char *name,
                           char *seq, enum display_type dtype)
{
    struct prefix_list *plist;
    struct prefix_master *master;
    int seqnum = 0;

    master = prefix_master_get (afi);
    if (master == NULL)
        return CMD_WARNING;

    if (seq)
        seqnum = atoi (seq);

    if (name)
    {
        plist = prefix_list_lookup (afi, name);
        if (! plist)
        {
           vty_out (zlog_default,LOG_DEBUG, "%% Cant find specified prefix-list%s", VTY_NEWLINE);
            return CMD_WARNING;
        }
        vty_show_prefix_entry (vty, afi, plist, master, dtype, seqnum);
    } else
    {
        if (dtype == detail_display || dtype == summary_display)
        {
            if (master->recent)
               vty_out (zlog_default,LOG_DEBUG, "Prefix-list with the last deletion/insertion: %s%s",
                         master->recent->name, VTY_NEWLINE);
        }

        for (plist = master->num.head; plist; plist = plist->next)
            vty_show_prefix_entry (vty, afi, plist, master, dtype, seqnum);

        for (plist = master->str.head; plist; plist = plist->next)
            vty_show_prefix_entry (vty, afi, plist, master, dtype, seqnum);
    }

    return CMD_SUCCESS;
}

int
Bgp::vty_show_prefix_list_prefix (struct vty *vty, afi_t afi, char *name, 
                                  char *prefix, enum display_type type)
{
    struct prefix_list *plist;
    struct prefix_list_entry *pentry;
    struct prefix p;
    int ret;
    int match;

    plist = prefix_list_lookup (afi, name);
    if (! plist)
    {
       vty_out (zlog_default,LOG_DEBUG, "%% Cant find specified prefix-list%s", VTY_NEWLINE);
        return CMD_WARNING;
    }

    ret = str2prefix (prefix, &p);
    if (ret <= 0)
    {
       vty_out (zlog_default,LOG_DEBUG, "%% prefix is malformed%s", VTY_NEWLINE);
        return CMD_WARNING;
    }

    for (pentry = plist->head; pentry; pentry = pentry->next)
    {
        match = 0;

        if (type == normal_display || type == first_match_display)
            if (prefix_same (&p, &pentry->prefix))
                match = 1;

        if (type == longer_display)
            if (prefix_match (&p, &pentry->prefix))
                match = 1;

        if (match)
        {
           vty_out (zlog_default,LOG_DEBUG, "   seq %d %s ", 
                     pentry->seq,
                     prefix_list_type_str (pentry));

            if (pentry->any)
               vty_out (zlog_default,LOG_DEBUG, "any");
            else
            {
                struct prefix *p = &pentry->prefix;
                char buf[BUFSIZ];

               vty_out (zlog_default,LOG_DEBUG, "%s/%d",
                         Bgp::inet_ntop (p->family, &p->u.prefix, buf, BUFSIZ),
                         p->prefixlen);
            }

            if (pentry->ge >= 0)
               vty_out (zlog_default,LOG_DEBUG, " ge %d", pentry->ge);
            if (pentry->le >= 0)
               vty_out (zlog_default,LOG_DEBUG, " le %d", pentry->le);

            if (type == normal_display || type == first_match_display)
               vty_out (zlog_default,LOG_DEBUG, " (hit count: %ld, refcount: %ld)", 
                         pentry->hitcnt, pentry->refcnt);

           vty_out (zlog_default,LOG_DEBUG, "%s", VTY_NEWLINE);

            if (type == first_match_display)
                return CMD_SUCCESS;
        }
    }
    return CMD_SUCCESS;
}

int
Bgp::vty_clear_prefix_list (struct vty *vty, afi_t afi, char *name, char *prefix)
{
    struct prefix_master *master;
    struct prefix_list *plist;
    struct prefix_list_entry *pentry;
    int ret;
    struct prefix p;

    master = prefix_master_get (afi);
    if (master == NULL)
        return CMD_WARNING;

    if (name == NULL && prefix == NULL)
    {
        for (plist = master->num.head; plist; plist = plist->next)
            for (pentry = plist->head; pentry; pentry = pentry->next)
                pentry->hitcnt = 0;

        for (plist = master->str.head; plist; plist = plist->next)
            for (pentry = plist->head; pentry; pentry = pentry->next)
                pentry->hitcnt = 0;
    } else
    {
        plist = prefix_list_lookup (afi, name);
        if (! plist)
        {
           vty_out (zlog_default,LOG_DEBUG, "%% Cant find specified prefix-list%s", VTY_NEWLINE);
            return CMD_WARNING;
        }

        if (prefix)
        {
            ret = str2prefix (prefix, &p);
            if (ret <= 0)
            {
               vty_out (zlog_default,LOG_DEBUG, "%% prefix is malformed%s", VTY_NEWLINE);
                return CMD_WARNING;
            }
        }

        for (pentry = plist->head; pentry; pentry = pentry->next)
        {
            if (prefix)
            {
                if (prefix_match (&pentry->prefix, &p))
                    pentry->hitcnt = 0;
            } else
                pentry->hitcnt = 0;
        }
    }
    return CMD_SUCCESS;
}

DEFUN (ip_prefix_list,
       ip_prefix_list_cmd,
       "ip prefix-list WORD (deny|permit) (A.B.C.D/M|any)",
       IP_STR
       PREFIX_LIST_STR
       "Name of a prefix list\n"
       "Specify packets to reject\n"
       "Specify packets to forward\n"
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
       "Any prefix match. Same as \"0.0.0.0/0 le 32\"\n")
{
    return vty_prefix_list_install (vty, AFI_IP, argv[0], NULL, 
                                    argv[1], argv[2], NULL, NULL);
}

DEFUN (ip_prefix_list_ge,
       ip_prefix_list_ge_cmd,
       "ip prefix-list WORD (deny|permit) A.B.C.D/M ge <0-32>",
       IP_STR
       PREFIX_LIST_STR
       "Name of a prefix list\n"
       "Specify packets to reject\n"
       "Specify packets to forward\n"
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
       "Minimum prefix length to be matched\n"
       "Minimum prefix length\n")
{
    return vty_prefix_list_install (vty, AFI_IP, argv[0], NULL, argv[1], 
                                    argv[2], argv[3], NULL);
}

DEFUN (ip_prefix_list_ge_le,
       ip_prefix_list_ge_le_cmd,
       "ip prefix-list WORD (deny|permit) A.B.C.D/M ge <0-32> le <0-32>",
       IP_STR
       PREFIX_LIST_STR
       "Name of a prefix list\n"
       "Specify packets to reject\n"
       "Specify packets to forward\n"
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
       "Minimum prefix length to be matched\n"
       "Minimum prefix length\n"
       "Maximum prefix length to be matched\n"
       "Maximum prefix length\n")
{
    return vty_prefix_list_install (vty, AFI_IP, argv[0], NULL, argv[1], 
                                    argv[2], argv[3], argv[4]);
}

DEFUN (ip_prefix_list_le,
       ip_prefix_list_le_cmd,
       "ip prefix-list WORD (deny|permit) A.B.C.D/M le <0-32>",
       IP_STR
       PREFIX_LIST_STR
       "Name of a prefix list\n"
       "Specify packets to reject\n"
       "Specify packets to forward\n"
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
       "Maximum prefix length to be matched\n"
       "Maximum prefix length\n")
{
    return vty_prefix_list_install (vty, AFI_IP, argv[0], NULL, argv[1],
                                    argv[2], NULL, argv[3]);
}

DEFUN (ip_prefix_list_le_ge,
       ip_prefix_list_le_ge_cmd,
       "ip prefix-list WORD (deny|permit) A.B.C.D/M le <0-32> ge <0-32>",
       IP_STR
       PREFIX_LIST_STR
       "Name of a prefix list\n"
       "Specify packets to reject\n"
       "Specify packets to forward\n"
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
       "Maximum prefix length to be matched\n"
       "Maximum prefix length\n"
       "Minimum prefix length to be matched\n"
       "Minimum prefix length\n")
{
    return vty_prefix_list_install (vty, AFI_IP, argv[0], NULL, argv[1],
                                    argv[2], argv[4], argv[3]);
}

DEFUN (ip_prefix_list_seq,
       ip_prefix_list_seq_cmd,
       "ip prefix-list WORD seq <1-4294967295> (deny|permit) (A.B.C.D/M|any)",
       IP_STR
       PREFIX_LIST_STR
       "Name of a prefix list\n"
       "sequence number of an entry\n"
       "Sequence number\n"
       "Specify packets to reject\n"
       "Specify packets to forward\n"
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
       "Any prefix match. Same as \"0.0.0.0/0 le 32\"\n")
{
    return vty_prefix_list_install (vty, AFI_IP, argv[0], argv[1], argv[2],
                                    argv[3], NULL, NULL);
}

DEFUN (ip_prefix_list_seq_ge,
       ip_prefix_list_seq_ge_cmd,
       "ip prefix-list WORD seq <1-4294967295> (deny|permit) A.B.C.D/M ge <0-32>",
       IP_STR
       PREFIX_LIST_STR
       "Name of a prefix list\n"
       "sequence number of an entry\n"
       "Sequence number\n"
       "Specify packets to reject\n"
       "Specify packets to forward\n"
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
       "Minimum prefix length to be matched\n"
       "Minimum prefix length\n")
{
    return vty_prefix_list_install (vty, AFI_IP, argv[0], argv[1], argv[2],
                                    argv[3], argv[4], NULL);
}

DEFUN (ip_prefix_list_seq_ge_le,
       ip_prefix_list_seq_ge_le_cmd,
       "ip prefix-list WORD seq <1-4294967295> (deny|permit) A.B.C.D/M ge <0-32> le <0-32>",
       IP_STR
       PREFIX_LIST_STR
       "Name of a prefix list\n"
       "sequence number of an entry\n"
       "Sequence number\n"
       "Specify packets to reject\n"
       "Specify packets to forward\n"
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
       "Minimum prefix length to be matched\n"
       "Minimum prefix length\n"
       "Maximum prefix length to be matched\n"
       "Maximum prefix length\n")
{
    return vty_prefix_list_install (vty, AFI_IP, argv[0], argv[1], argv[2],
                                    argv[3], argv[4], argv[5]);
}

DEFUN (ip_prefix_list_seq_le,
       ip_prefix_list_seq_le_cmd,
       "ip prefix-list WORD seq <1-4294967295> (deny|permit) A.B.C.D/M le <0-32>",
       IP_STR
       PREFIX_LIST_STR
       "Name of a prefix list\n"
       "sequence number of an entry\n"
       "Sequence number\n"
       "Specify packets to reject\n"
       "Specify packets to forward\n"
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
       "Maximum prefix length to be matched\n"
       "Maximum prefix length\n")
{
    return vty_prefix_list_install (vty, AFI_IP, argv[0], argv[1], argv[2],
                                    argv[3], NULL, argv[4]);
}

DEFUN (ip_prefix_list_seq_le_ge,
       ip_prefix_list_seq_le_ge_cmd,
       "ip prefix-list WORD seq <1-4294967295> (deny|permit) A.B.C.D/M le <0-32> ge <0-32>",
       IP_STR
       PREFIX_LIST_STR
       "Name of a prefix list\n"
       "sequence number of an entry\n"
       "Sequence number\n"
       "Specify packets to reject\n"
       "Specify packets to forward\n"
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
       "Maximum prefix length to be matched\n"
       "Maximum prefix length\n"
       "Minimum prefix length to be matched\n"
       "Minimum prefix length\n")
{
    return vty_prefix_list_install (vty, AFI_IP, argv[0], argv[1], argv[2],
                                    argv[3], argv[5], argv[4]);
}

DEFUN (no_ip_prefix_list,
       no_ip_prefix_list_cmd,
       "no ip prefix-list WORD",
       NO_STR
       IP_STR
       PREFIX_LIST_STR
       "Name of a prefix list\n")
{
    return vty_prefix_list_uninstall (vty, AFI_IP, argv[0], NULL, NULL,
                                      NULL, NULL, NULL);
}

DEFUN (no_ip_prefix_list_prefix,
       no_ip_prefix_list_prefix_cmd,
       "no ip prefix-list WORD (deny|permit) (A.B.C.D/M|any)",
       NO_STR
       IP_STR
       PREFIX_LIST_STR
       "Name of a prefix list\n"
       "Specify packets to reject\n"
       "Specify packets to forward\n"
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
       "Any prefix match.  Same as \"0.0.0.0/0 le 32\"\n")
{
    return vty_prefix_list_uninstall (vty, AFI_IP, argv[0], NULL, argv[1],
                                      argv[2], NULL, NULL);
}

DEFUN (no_ip_prefix_list_ge,
       no_ip_prefix_list_ge_cmd,
       "no ip prefix-list WORD (deny|permit) A.B.C.D/M ge <0-32>",
       NO_STR
       IP_STR
       PREFIX_LIST_STR
       "Name of a prefix list\n"
       "Specify packets to reject\n"
       "Specify packets to forward\n"
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
       "Minimum prefix length to be matched\n"
       "Minimum prefix length\n")
{
    return vty_prefix_list_uninstall (vty, AFI_IP, argv[0], NULL, argv[1],
                                      argv[2], argv[3], NULL);
}

DEFUN (no_ip_prefix_list_ge_le,
       no_ip_prefix_list_ge_le_cmd,
       "no ip prefix-list WORD (deny|permit) A.B.C.D/M ge <0-32> le <0-32>",
       NO_STR
       IP_STR
       PREFIX_LIST_STR
       "Name of a prefix list\n"
       "Specify packets to reject\n"
       "Specify packets to forward\n"
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
       "Minimum prefix length to be matched\n"
       "Minimum prefix length\n"
       "Maximum prefix length to be matched\n"
       "Maximum prefix length\n")
{
    return vty_prefix_list_uninstall (vty, AFI_IP, argv[0], NULL, argv[1],
                                      argv[2], argv[3], argv[4]);
}

DEFUN (no_ip_prefix_list_le,
       no_ip_prefix_list_le_cmd,
       "no ip prefix-list WORD (deny|permit) A.B.C.D/M le <0-32>",
       NO_STR
       IP_STR
       PREFIX_LIST_STR
       "Name of a prefix list\n"
       "Specify packets to reject\n"
       "Specify packets to forward\n"
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
       "Maximum prefix length to be matched\n"
       "Maximum prefix length\n")
{
    return vty_prefix_list_uninstall (vty, AFI_IP, argv[0], NULL, argv[1],
                                      argv[2], NULL, argv[3]);
}

DEFUN (no_ip_prefix_list_le_ge,
       no_ip_prefix_list_le_ge_cmd,
       "no ip prefix-list WORD (deny|permit) A.B.C.D/M le <0-32> ge <0-32>",
       NO_STR
       IP_STR
       PREFIX_LIST_STR
       "Name of a prefix list\n"
       "Specify packets to reject\n"
       "Specify packets to forward\n"
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
       "Maximum prefix length to be matched\n"
       "Maximum prefix length\n"
       "Minimum prefix length to be matched\n"
       "Minimum prefix length\n")
{
    return vty_prefix_list_uninstall (vty, AFI_IP, argv[0], NULL, argv[1],
                                      argv[2], argv[4], argv[3]);
}

DEFUN (no_ip_prefix_list_seq,
       no_ip_prefix_list_seq_cmd,
       "no ip prefix-list WORD seq <1-4294967295> (deny|permit) (A.B.C.D/M|any)",
       NO_STR
       IP_STR
       PREFIX_LIST_STR
       "Name of a prefix list\n"
       "sequence number of an entry\n"
       "Sequence number\n"
       "Specify packets to reject\n"
       "Specify packets to forward\n"
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
       "Any prefix match.  Same as \"0.0.0.0/0 le 32\"\n")
{
    return vty_prefix_list_uninstall (vty, AFI_IP, argv[0], argv[1], argv[2],
                                      argv[3], NULL, NULL);
}

DEFUN (no_ip_prefix_list_seq_ge,
       no_ip_prefix_list_seq_ge_cmd,
       "no ip prefix-list WORD seq <1-4294967295> (deny|permit) A.B.C.D/M ge <0-32>",
       NO_STR
       IP_STR
       PREFIX_LIST_STR
       "Name of a prefix list\n"
       "sequence number of an entry\n"
       "Sequence number\n"
       "Specify packets to reject\n"
       "Specify packets to forward\n"
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
       "Minimum prefix length to be matched\n"
       "Minimum prefix length\n")
{
    return vty_prefix_list_uninstall (vty, AFI_IP, argv[0], argv[1], argv[2],
                                      argv[3], argv[4], NULL);
}

DEFUN (no_ip_prefix_list_seq_ge_le,
       no_ip_prefix_list_seq_ge_le_cmd,
       "no ip prefix-list WORD seq <1-4294967295> (deny|permit) A.B.C.D/M ge <0-32> le <0-32>",
       NO_STR
       IP_STR
       PREFIX_LIST_STR
       "Name of a prefix list\n"
       "sequence number of an entry\n"
       "Sequence number\n"
       "Specify packets to reject\n"
       "Specify packets to forward\n"
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
       "Minimum prefix length to be matched\n"
       "Minimum prefix length\n"
       "Maximum prefix length to be matched\n"
       "Maximum prefix length\n")
{
    return vty_prefix_list_uninstall (vty, AFI_IP, argv[0], argv[1], argv[2],
                                      argv[3], argv[4], argv[5]);
}

DEFUN (no_ip_prefix_list_seq_le,
       no_ip_prefix_list_seq_le_cmd,
       "no ip prefix-list WORD seq <1-4294967295> (deny|permit) A.B.C.D/M le <0-32>",
       NO_STR
       IP_STR
       PREFIX_LIST_STR
       "Name of a prefix list\n"
       "sequence number of an entry\n"
       "Sequence number\n"
       "Specify packets to reject\n"
       "Specify packets to forward\n"
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
       "Maximum prefix length to be matched\n"
       "Maximum prefix length\n")
{
    return vty_prefix_list_uninstall (vty, AFI_IP, argv[0], argv[1], argv[2],
                                      argv[3], NULL, argv[4]);
}

DEFUN (no_ip_prefix_list_seq_le_ge,
       no_ip_prefix_list_seq_le_ge_cmd,
       "no ip prefix-list WORD seq <1-4294967295> (deny|permit) A.B.C.D/M le <0-32> ge <0-32>",
       NO_STR
       IP_STR
       PREFIX_LIST_STR
       "Name of a prefix list\n"
       "sequence number of an entry\n"
       "Sequence number\n"
       "Specify packets to reject\n"
       "Specify packets to forward\n"
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
       "Maximum prefix length to be matched\n"
       "Maximum prefix length\n"
       "Minimum prefix length to be matched\n"
       "Minimum prefix length\n")
{
    return vty_prefix_list_uninstall (vty, AFI_IP, argv[0], argv[1], argv[2],
                                      argv[3], argv[5], argv[4]);
}

DEFUN (ip_prefix_list_sequence_number,
       ip_prefix_list_sequence_number_cmd,
       "ip prefix-list sequence-number",
       IP_STR
       PREFIX_LIST_STR
       "Include/exclude sequence numbers in NVGEN\n")
{
    prefix_master_ipv4.seqnum = 1;
    return CMD_SUCCESS;
}

DEFUN (no_ip_prefix_list_sequence_number,
       no_ip_prefix_list_sequence_number_cmd,
       "no ip prefix-list sequence-number",
       NO_STR
       IP_STR
       PREFIX_LIST_STR
       "Include/exclude sequence numbers in NVGEN\n")
{
    prefix_master_ipv4.seqnum = 0;
    return CMD_SUCCESS;
}

DEFUN (ip_prefix_list_description,
       ip_prefix_list_description_cmd,
       "ip prefix-list WORD description .LINE",
       IP_STR
       PREFIX_LIST_STR
       "Name of a prefix list\n"
       "Prefix-list specific description\n"
       "Up to 80 characters describing this prefix-list\n")
{
    struct prefix_list *plist;
    struct buffer *b;
    int i;

    plist = prefix_list_get (AFI_IP, argv[0]);

    if (plist->desc)
    {
        XFREE (MTYPE_TMP, plist->desc);
        plist->desc = NULL;
    }

    /* Below is description get codes. */
    b = buffer_new (1024);
    for (i = 1; i < argc; i++)
    {
        buffer_putstr (b, (u_char *)argv[i]);
        buffer_putc (b, ' ');
    }
    buffer_putc (b, '\0');

    plist->desc = buffer_getstr (b);

    buffer_free (b);

    return CMD_SUCCESS;
}       

DEFUN (no_ip_prefix_list_description,
       no_ip_prefix_list_description_cmd,
       "no ip prefix-list WORD description",
       NO_STR
       IP_STR
       PREFIX_LIST_STR
       "Name of a prefix list\n"
       "Prefix-list specific description\n")
{
    return vty_prefix_list_desc_unset (vty, AFI_IP, argv[0]);
}

DEFUN (show_ip_prefix_list,
       show_ip_prefix_list_cmd,
       "show ip prefix-list",
       SHOW_STR
       IP_STR
       PREFIX_LIST_STR)
{
    return vty_show_prefix_list (vty, AFI_IP, NULL, NULL, normal_display);
}

DEFUN (show_ip_prefix_list_name,
       show_ip_prefix_list_name_cmd,
       "show ip prefix-list WORD",
       SHOW_STR
       IP_STR
       PREFIX_LIST_STR
       "Name of a prefix list\n")
{
    return vty_show_prefix_list (vty, AFI_IP, argv[0], NULL, normal_display);
}

DEFUN (show_ip_prefix_list_name_seq,
       show_ip_prefix_list_name_seq_cmd,
       "show ip prefix-list WORD seq <1-4294967295>",
       SHOW_STR
       IP_STR
       PREFIX_LIST_STR
       "Name of a prefix list\n"
       "sequence number of an entry\n"
       "Sequence number\n")
{
    return vty_show_prefix_list (vty, AFI_IP, argv[0], argv[1], sequential_display);
}

DEFUN (show_ip_prefix_list_prefix,
       show_ip_prefix_list_prefix_cmd,
       "show ip prefix-list WORD A.B.C.D/M",
       SHOW_STR
       IP_STR
       PREFIX_LIST_STR
       "Name of a prefix list\n"
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n")
{
    return vty_show_prefix_list_prefix (vty, AFI_IP, argv[0], argv[1], normal_display);
}

DEFUN (show_ip_prefix_list_prefix_longer,
       show_ip_prefix_list_prefix_longer_cmd,
       "show ip prefix-list WORD A.B.C.D/M longer",
       SHOW_STR
       IP_STR
       PREFIX_LIST_STR
       "Name of a prefix list\n"
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
       "Lookup longer prefix\n")
{
    return vty_show_prefix_list_prefix (vty, AFI_IP, argv[0], argv[1], longer_display);
}

DEFUN (show_ip_prefix_list_prefix_first_match,
       show_ip_prefix_list_prefix_first_match_cmd,
       "show ip prefix-list WORD A.B.C.D/M first-match",
       SHOW_STR
       IP_STR
       PREFIX_LIST_STR
       "Name of a prefix list\n"
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n"
       "First matched prefix\n")
{
    return vty_show_prefix_list_prefix (vty, AFI_IP, argv[0], argv[1], first_match_display);
}

DEFUN (show_ip_prefix_list_summary,
       show_ip_prefix_list_summary_cmd,
       "show ip prefix-list summary",
       SHOW_STR
       IP_STR
       PREFIX_LIST_STR
       "Summary of prefix lists\n")
{
    return vty_show_prefix_list (vty, AFI_IP, NULL, NULL, summary_display);
}

DEFUN (show_ip_prefix_list_summary_name,
       show_ip_prefix_list_summary_name_cmd,
       "show ip prefix-list summary WORD",
       SHOW_STR
       IP_STR
       PREFIX_LIST_STR
       "Summary of prefix lists\n"
       "Name of a prefix list\n")
{
    return vty_show_prefix_list (vty, AFI_IP, argv[0], NULL, summary_display);
}


DEFUN (show_ip_prefix_list_detail,
       show_ip_prefix_list_detail_cmd,
       "show ip prefix-list detail",
       SHOW_STR
       IP_STR
       PREFIX_LIST_STR
       "Detail of prefix lists\n")
{
    return vty_show_prefix_list (vty, AFI_IP, NULL, NULL, detail_display);
}

DEFUN (show_ip_prefix_list_detail_name,
       show_ip_prefix_list_detail_name_cmd,
       "show ip prefix-list detail WORD",
       SHOW_STR
       IP_STR
       PREFIX_LIST_STR
       "Detail of prefix lists\n"
       "Name of a prefix list\n")
{
    return vty_show_prefix_list (vty, AFI_IP, argv[0], NULL, detail_display);
}

DEFUN (clear_ip_prefix_list,
       clear_ip_prefix_list_cmd,
       "clear ip prefix-list",
       CLEAR_STR
       IP_STR
       PREFIX_LIST_STR)
{
    return vty_clear_prefix_list (vty, AFI_IP, NULL, NULL);
}

DEFUN (clear_ip_prefix_list_name,
       clear_ip_prefix_list_name_cmd,
       "clear ip prefix-list WORD",
       CLEAR_STR
       IP_STR
       PREFIX_LIST_STR
       "Name of a prefix list\n")
{
    return vty_clear_prefix_list (vty, AFI_IP, argv[0], NULL);
}

DEFUN (clear_ip_prefix_list_name_prefix,
       clear_ip_prefix_list_name_prefix_cmd,
       "clear ip prefix-list WORD A.B.C.D/M",
       CLEAR_STR
       IP_STR
       PREFIX_LIST_STR
       "Name of a prefix list\n"
       "IP prefix <network>/<length>, e.g., 35.0.0.0/8\n")
{
    return vty_clear_prefix_list (vty, AFI_IP, argv[0], argv[1]);
}


/* Configuration write function. */
int
Bgp::config_write_prefix_afi (afi_t afi, struct vty *vty)
{
    struct prefix_list *plist;
    struct prefix_list_entry *pentry;
    struct prefix_master *master;
    int write = 0;

    master = prefix_master_get (afi);
    if (master == NULL)
        return 0;

    if (! master->seqnum)
    {
       vty_out (zlog_default,LOG_DEBUG, "no ip%s prefix-list sequence-number%s", 
                 afi == AFI_IP ? "" : "v6", VTY_NEWLINE);
       vty_out (zlog_default,LOG_DEBUG, "!%s", VTY_NEWLINE);
    }

    for (plist = master->num.head; plist; plist = plist->next)
    {
        if (plist->desc)
        {
           vty_out (zlog_default,LOG_DEBUG, "ip%s prefix-list %s description %s%s",
                     afi == AFI_IP ? "" : "v6",
                     plist->name, plist->desc, VTY_NEWLINE);
            write++;
        }

        for (pentry = plist->head; pentry; pentry = pentry->next)
        {
           vty_out (zlog_default,LOG_DEBUG, "ip%s prefix-list %s ",
                     afi == AFI_IP ? "" : "v6",
                     plist->name);

            if (master->seqnum)
               vty_out (zlog_default,LOG_DEBUG, "seq %d ", pentry->seq);

           vty_out (zlog_default,LOG_DEBUG, "%s ", prefix_list_type_str (pentry));

            if (pentry->any)
               vty_out (zlog_default,LOG_DEBUG, "any");
            else
            {
                struct prefix *p = &pentry->prefix;
                char buf[BUFSIZ];

               vty_out (zlog_default,LOG_DEBUG, "%s/%d",
                         Bgp::inet_ntop (p->family, &p->u.prefix, buf, BUFSIZ),
                         p->prefixlen);
            }

            if (pentry->ge >= 0)
               vty_out (zlog_default,LOG_DEBUG, " ge %d", pentry->ge);
            if (pentry->le >= 0)
               vty_out (zlog_default,LOG_DEBUG, " le %d", pentry->le);
           vty_out (zlog_default,LOG_DEBUG, "%s", VTY_NEWLINE);
            write++;
        }
        /*vty_out (zlog_default,LOG_DEBUG, "!%s", VTY_NEWLINE); */
    }

    for (plist = master->str.head; plist; plist = plist->next)
    {
        if (plist->desc)
        {
           vty_out (zlog_default,LOG_DEBUG, "ip%s prefix-list %s description %s%s",
                     afi == AFI_IP ? "" : "v6",
                     plist->name, plist->desc, VTY_NEWLINE);
            write++;
        }

        for (pentry = plist->head; pentry; pentry = pentry->next)
        {
           vty_out (zlog_default,LOG_DEBUG, "ip%s prefix-list %s ",
                     afi == AFI_IP ? "" : "v6",
                     plist->name);

            if (master->seqnum)
               vty_out (zlog_default,LOG_DEBUG, "seq %d ", pentry->seq);

           vty_out (zlog_default,LOG_DEBUG, "%s", prefix_list_type_str (pentry));

            if (pentry->any)
               vty_out (zlog_default,LOG_DEBUG, " any");
            else
            {
                struct prefix *p = &pentry->prefix;
                char buf[BUFSIZ];

               vty_out (zlog_default,LOG_DEBUG, " %s/%d",
                         Bgp::inet_ntop (p->family, &p->u.prefix, buf, BUFSIZ),
                         p->prefixlen);
            }
            if (pentry->ge >= 0)
               vty_out (zlog_default,LOG_DEBUG, " ge %d", pentry->ge);
            if (pentry->le >= 0)
               vty_out (zlog_default,LOG_DEBUG, " le %d", pentry->le);
           vty_out (zlog_default,LOG_DEBUG, "%s", VTY_NEWLINE);
            write++;
        }
    }

    return write;
}

void
Bgp::prefix_list_reset_ipv4 ()
{
    struct prefix_list *plist;
    struct prefix_list *next;
    struct prefix_master *master;

    master = prefix_master_get (AFI_IP);
    if (master == NULL)
        return;

    for (plist = master->num.head; plist; plist = next)
    {
        next = plist->next;
        prefix_list_delete (plist);
    }
    for (plist = master->str.head; plist; plist = next)
    {
        next = plist->next;
        prefix_list_delete (plist);
    }

    assert (master->num.head == NULL);
    assert (master->num.tail == NULL);

    assert (master->str.head == NULL);
    assert (master->str.tail == NULL);

    master->seqnum = 1;
    master->recent = NULL;
}

void
Bgp::prefix_list_init_ipv4 ()
{
    install_element (CONFIG_NODE, &ip_prefix_list_cmd);
    install_element (CONFIG_NODE, &ip_prefix_list_ge_cmd);
    install_element (CONFIG_NODE, &ip_prefix_list_ge_le_cmd);
    install_element (CONFIG_NODE, &ip_prefix_list_le_cmd);
    install_element (CONFIG_NODE, &ip_prefix_list_le_ge_cmd);
    install_element (CONFIG_NODE, &ip_prefix_list_seq_cmd);
    install_element (CONFIG_NODE, &ip_prefix_list_seq_ge_cmd);
    install_element (CONFIG_NODE, &ip_prefix_list_seq_ge_le_cmd);
    install_element (CONFIG_NODE, &ip_prefix_list_seq_le_cmd);
    install_element (CONFIG_NODE, &ip_prefix_list_seq_le_ge_cmd);
    install_element (CONFIG_NODE, &no_ip_prefix_list_cmd);
    install_element (CONFIG_NODE, &no_ip_prefix_list_prefix_cmd);
    install_element (CONFIG_NODE, &no_ip_prefix_list_ge_cmd);
    install_element (CONFIG_NODE, &no_ip_prefix_list_ge_le_cmd);
    install_element (CONFIG_NODE, &no_ip_prefix_list_le_cmd);
    install_element (CONFIG_NODE, &no_ip_prefix_list_le_ge_cmd);
    install_element (CONFIG_NODE, &no_ip_prefix_list_seq_cmd);
    install_element (CONFIG_NODE, &no_ip_prefix_list_seq_ge_cmd);
    install_element (CONFIG_NODE, &no_ip_prefix_list_seq_ge_le_cmd);
    install_element (CONFIG_NODE, &no_ip_prefix_list_seq_le_cmd);
    install_element (CONFIG_NODE, &no_ip_prefix_list_seq_le_ge_cmd);
    install_element (CONFIG_NODE, &ip_prefix_list_description_cmd);
    install_element (CONFIG_NODE, &no_ip_prefix_list_description_cmd);
    install_element (CONFIG_NODE, &no_ip_prefix_list_description_arg_cmd);
    install_element (CONFIG_NODE, &ip_prefix_list_sequence_number_cmd);
    install_element (CONFIG_NODE, &no_ip_prefix_list_sequence_number_cmd);
    install_element (CONFIG_NODE, &show_ip_prefix_list_cmd);
    install_element (CONFIG_NODE, &show_ip_prefix_list_name_cmd);
    install_element (CONFIG_NODE, &show_ip_prefix_list_name_seq_cmd);
    install_element (CONFIG_NODE, &show_ip_prefix_list_prefix_cmd);
    install_element (CONFIG_NODE, &show_ip_prefix_list_prefix_longer_cmd);
    install_element (CONFIG_NODE, &show_ip_prefix_list_prefix_first_match_cmd);
    install_element (CONFIG_NODE, &show_ip_prefix_list_summary_cmd);
    install_element (CONFIG_NODE, &show_ip_prefix_list_summary_name_cmd);
    install_element (CONFIG_NODE, &show_ip_prefix_list_detail_cmd);
    install_element (CONFIG_NODE, &show_ip_prefix_list_detail_name_cmd);
    install_element (CONFIG_NODE, &clear_ip_prefix_list_cmd);
    install_element (CONFIG_NODE, &clear_ip_prefix_list_name_cmd);
    install_element (CONFIG_NODE, &clear_ip_prefix_list_name_prefix_cmd);
}

void
Bgp::prefix_list_init ()
{
    prefix_list_init_ipv4 ();
}

void
Bgp::prefix_list_reset ()
{
    prefix_list_reset_ipv4 ();

}



////////////////////////////////////////////////
////////////////////////////////////////////////
///////prefix.c/////////////////////////////////
////////////////////////////////////////////////


/* Address Famiy Identifier to Address Family converter. */
int
Bgp::afi2family (int afi)
{
    if (afi == AFI_IP)
        return AF_INET;
    return 0;
}

int
Bgp::family2afi (int family)
{
    if (family == AF_INET)
        return AFI_IP;
    return 0;
}

/* If n includes p prefix then return 1 else return 0. */
int
Bgp::prefix_match (struct prefix *n, struct prefix *p)
{
    int offset;
    int shift;

    /* Set both prefix's head pointer. */
    u_char *np = (u_char *)&n->u.prefix;
    u_char *pp = (u_char *)&p->u.prefix;

    /* If n's prefix is longer than p's one return 0. */
    if (n->prefixlen > p->prefixlen)
        return 0;

    offset = n->prefixlen / PNBBY;
    shift =  n->prefixlen % PNBBY;

    if (shift)
        if (maskbit[shift] & (np[offset] ^ pp[offset]))
            return 0;

    while (offset--)
        if (np[offset] != pp[offset])
            return 0;
    return 1;
}

/* Copy prefix from src to dest. */
void
Bgp::prefix_copy (struct prefix *dest, struct prefix *src)
{
    dest->family = src->family;
    dest->prefixlen = src->prefixlen;

    if (src->family == AF_INET)
        dest->u.prefix4 = src->u.prefix4;
    else if (src->family == AF_UNSPEC)
    {
        dest->u.lp.id = src->u.lp.id;
        dest->u.lp.adv_router = src->u.lp.adv_router;
    } else
    {
        zlog (NULL, LOG_INFO, "prefix_copy(): Unknown address family %d\n",
              src->family);
        assert (0);
    }
}

/* If both prefix structure is same then return 1 else return 0. */
int
Bgp::prefix_same (struct prefix *p1, struct prefix *p2)
{
    if (p1->family == p2->family && p1->prefixlen == p2->prefixlen)
    {
        if (p1->family == AF_INET)
            if (IPV4_ADDR_SAME (&p1->u.prefix, &p2->u.prefix))
                return 1;

    }
    return 0;
}

/* When both prefix structure is not same, but will be same after
   applying mask, return 0. otherwise, return 1 */
int
Bgp::prefix_cmp (struct prefix *p1, struct prefix *p2)
{
    int offset;
    int shift;

    /* Set both prefix's head pointer. */
    u_char *pp1 = (u_char *)&p1->u.prefix;
    u_char *pp2 = (u_char *)&p2->u.prefix;

    if (p1->family != p2->family || p1->prefixlen != p2->prefixlen)
        return 1;

    offset = p1->prefixlen / 8;
    shift = p1->prefixlen % 8;

    if (shift)
        if (maskbit[shift] & (pp1[offset] ^ pp2[offset]))
            return 1;

    while (offset--)
        if (pp1[offset] != pp2[offset])
            return 1;

    return 0;
}

/* Return prefix family type string. */
char *
Bgp::prefix_family_str (struct prefix *p)
{
    if (p->family == AF_INET)
        return "inet";

    return "unspec";
}

/* Allocate New prefix_ipv4 structure. */
struct prefix_ipv4 *
Bgp::prefix_ipv4_new ()
{
    struct prefix_ipv4 *p;

    p = ( struct prefix_ipv4 * )  XMALLOC (MTYPE_PREFIX_IPV4, sizeof *p);
    bzero (p, sizeof (struct prefix_ipv4));
    p->family = AF_INET;
    return p;
}

/* Free prefix_ipv4 structure. */
void
Bgp::prefix_ipv4_free (struct prefix_ipv4 *p)
{
    XFREE (MTYPE_PREFIX_IPV4, p);
}

/* When string format is invalid return 0. */
int
Bgp::str2prefix_ipv4 (char *str, struct prefix_ipv4 *p)
{
    int ret;
    int plen;
    char *pnt;
    char *cp;

    /* Find slash inside string. */
    pnt = strchr (str, '/');

    /* String doesnt contail slash. */
    if (pnt == NULL)
    {
        /* Convert string to prefix. */
        ret = inet_aton (str, &p->prefix);
        if (ret == 0)
            return 0;

        /* If address doesnt contain slash we assume it host address. */
        p->family = AF_INET;
        p->prefixlen = IPV4_MAX_BITLEN;

        return ret;
    } else
    {
        cp = ( char * )  XMALLOC (MTYPE_TMP, (pnt - str) + 1);
        strncpy (cp, str, pnt - str);
        *(cp + (pnt - str)) = '\0';
        ret = inet_aton (cp, &p->prefix);
        XFREE (MTYPE_TMP, cp);

        /* Get prefix length. */
        plen = (u_char) atoi (++pnt);
        if (plen > 32)
            return 0;

        p->family = AF_INET;
        p->prefixlen = plen;
    }

    return ret;
}

/* Convert masklen into IP address's netmask. */
void
Bgp::masklen2ip (int masklen, struct in_addr *netmask)
{
    u_char *pnt;
    int bit;
    int offset;

    bzero (netmask, sizeof (struct in_addr));
    pnt = (unsigned char *) netmask;

    offset = masklen / 8;
    bit = masklen % 8;

    while (offset--)
        *pnt++ = 0xff;

    if (bit)
        *pnt = maskbit[bit];
}

/* Convert IP address's netmask into integer. We assume netmask is
   sequential one. Argument netmask should be network byte order. */
u_char
Bgp::ip_masklen (struct in_addr netmask)
{
    u_char len;
    u_char *pnt;
    u_char *end;
    u_char val;

    len = 0;
    pnt = (u_char *) &netmask;
    end = pnt + 4;

    while ((*pnt == 0xff) && pnt < end)
    {
        len+= 8;
        pnt++;
    } 

    if (pnt < end)
    {
        val = *pnt;
        while (val)
        {
            len++;
            val <<= 1;
        }
    }
    return len;
}

/* Apply mask to IPv4 prefix. */
void
Bgp::apply_mask_ipv4 (struct prefix_ipv4 *p)
{
    u_char *pnt;
    int index;
    int offset;

    index = p->prefixlen / 8;

    if (index < 4)
    {
        pnt = (u_char *) &p->prefix;
        offset = p->prefixlen % 8;

        pnt[index] &= maskbit[offset];
        index++;

        while (index < 4)
            pnt[index++] = 0;
    }
}

/* If prefix is 0.0.0.0/0 then return 1 else return 0. */
int
Bgp::prefix_ipv4_any (struct prefix_ipv4 *p)
{
    return(p->prefix.s_addr == 0 && p->prefixlen == 0);
}


void
Bgp::apply_mask (struct prefix *p)
{
    switch (p->family)
    {
    case AF_INET:
        apply_mask_ipv4 ((struct prefix_ipv4 *)p);
        break;
    default:
        break;
    }
    return;
}

/* Utility function of convert between struct prefix <=> union sockunion */
struct prefix *
Bgp::sockunion2prefix (union sockunion *dest,
                       union sockunion *mask)
{
    if (dest->sa.sa_family == AF_INET)
    {
        struct prefix_ipv4 *p;

        p = prefix_ipv4_new ();
        p->family = AF_INET;
        p->prefix = dest->sin.sin_addr;
        p->prefixlen = ip_masklen (mask->sin.sin_addr);
        return(struct prefix *) p;
    }
    return NULL;
}

/* Utility function of convert between struct prefix <=> union sockunion */
struct prefix *
Bgp::sockunion2hostprefix (union sockunion *su)
{
    if (su->sa.sa_family == AF_INET)
    {
        struct prefix_ipv4 *p;

        p = prefix_ipv4_new ();
        p->family = AF_INET;
        p->prefix = su->sin.sin_addr;
        p->prefixlen = IPV4_MAX_BITLEN;
        return(struct prefix *) p;
    }
    return NULL;
}

int
Bgp::prefix_blen (struct prefix *p)
{
    switch (p->family)
    {
    case AF_INET:
        return IPV4_MAX_BYTELEN;
        break;
    }
    return 0;
}

/* Generic function for conversion string to struct prefix. */
int
Bgp::str2prefix (char *str, struct prefix *p)
{
    int ret;

    /* First we try to convert string to struct prefix_ipv4. */
    ret = str2prefix_ipv4 (str, (struct prefix_ipv4 *) p);
    if (ret)
        return ret;

    return 0;
}

int
Bgp::prefix2str (struct prefix *p, char *str, int size)
{
    char buf[BUFSIZ];

    Bgp::inet_ntop (p->family, &p->u.prefix, buf, BUFSIZ);
    snprintf (str, size, "%s/%d", buf, p->prefixlen);
    return 0;
}

struct prefix *
Bgp::prefix_new ()
{
    struct prefix *p;

    p = ( struct prefix * ) XMALLOC (MTYPE_PREFIX, sizeof *p);
    bzero (p, sizeof (struct prefix));
    return p;
}

/* Free prefix structure. */
void
Bgp::prefix_free (struct prefix *p)
{
    XFREE (MTYPE_PREFIX, p);
}

/* Utility function.  Check the string only contains digit
   character. */
int
Bgp::all_digit (char *str)
{
    for (; *str != '\0'; str++)
        if (!isdigit ((int) *str))
            return 0;
    return 1;
}
/* Utility function to convert ipv4 prefixes to Classful prefixes */
void
Bgp::apply_classful_mask_ipv4 (struct prefix_ipv4 *p)
{

    u_int32_t destination;

    destination = ntohl (p->prefix.s_addr);

    if (p->prefixlen == 32);
    /* do nothing for host routes */
    else if (IN_CLASSC (destination))
    {
        p->prefixlen=24;
        apply_mask_ipv4(p);
    } else if (IN_CLASSB(destination))
    {
        p->prefixlen=16;
        apply_mask_ipv4(p);
    } else
    {
        p->prefixlen=8;
        apply_mask_ipv4(p);
    }
}

/* Utility function to convert ipv4 netmask to prefixes 
   ex.) "1.1.0.0" "255.255.0.0" => "1.1.0.0/16"
   ex.) "1.0.0.0" NULL => "1.0.0.0/8"                   */
int
Bgp::netmask_str2prefix_str (char *net_str, char *mask_str, char *prefix_str)
{
    struct in_addr network;
    struct in_addr mask;
    char masklen_str[3];
    u_int32_t destination;
    int ret;

    ret = inet_aton (net_str, &network);
    if (! ret)
        return 0;

    if (mask_str)
    {
        ret = inet_aton (mask_str, &mask);
        if (! ret)
            return 0;

        sprintf (masklen_str, "%d", ip_masklen (mask));
    } else
    {
        destination = ntohl (network.s_addr);

        if (network.s_addr == 0)
            strcpy (masklen_str, "0");
        else if (IN_CLASSC (destination))
            strcpy (masklen_str, "24");
        else if (IN_CLASSB (destination))
            strcpy (masklen_str, "16");
        else if (IN_CLASSA (destination))
            strcpy (masklen_str, "8");
        else
            return 0;
    }

    strcpy (prefix_str, net_str);
    strcat (prefix_str, "/");
    strcat (prefix_str, masklen_str);

    return 1;
}



////////////////////////////////////////////////
////////////////////////////////////////////////
///routemap.c///////////////////////////////////
////////////////////////////////////////////////






/* New route map allocation. Please note route map's name must be
   specified. */
struct route_map *
Bgp::route_map_new (char *name)
{
    struct route_map *New;

    New = ( struct route_map *)  XMALLOC (MTYPE_ROUTE_MAP, sizeof (struct route_map));
    bzero (New, sizeof (struct route_map));
    New->name = XSTRDUP (MTYPE_ROUTE_MAP_NAME, name);
    return New;
}

/* Add New name to route_map. */
struct route_map *
Bgp::route_map_add (char *name)
{
    struct route_map *map;
    struct route_map_list *list;

    map = route_map_new (name);
    list = &route_map_master;

    map->next = NULL;
    map->prev = list->tail;
    if (list->tail)
        list->tail->next = map;
    else
        list->head = map;
    list->tail = map;

    /* Execute hook. */
    if (route_map_master.add_hook)
      (this->*route_map_master.add_hook) (name);

    return map;
}

/* Route map delete from list. */
void
Bgp::route_map_delete (struct route_map *map)
{
    struct route_map_list *list;
    struct route_map_index *index;
    char *name;

    while ((index = map->head) != NULL)
        route_map_index_delete (index, 0);

    name = map->name;

    list = &route_map_master;

    if (map->next)
        map->next->prev = map->prev;
    else
        list->tail = map->prev;

    if (map->prev)
        map->prev->next = map->next;
    else
        list->head = map->next;

    XFREE (MTYPE_ROUTE_MAP, map);

    /* Execute deletion hook. */
    if (route_map_master.delete_hook)
        (this->*route_map_master.delete_hook) (name);

    if (name)
        XFREE (MTYPE_ROUTE_MAP_NAME, name);

}

/* Lookup route map by route map name string. */
struct route_map *
Bgp::route_map_lookup_by_name (char *name)
{
    struct route_map *map;

    for (map = route_map_master.head; map; map = map->next)
        if (strcmp (map->name, name) == 0)
            return map;
    return NULL;
}

/* Lookup route map.  If there isnt route map create one and return
   it. */
struct route_map *
Bgp::route_map_get (char *name)
{
    struct route_map *map;

    map = route_map_lookup_by_name (name);
    if (map == NULL)
        map = route_map_add (name);
    return map;
}

/* Return route map's type string. */
char *
Bgp::route_map_type_str (enum route_map_type type)
{
    switch (type)
    {
    case RMAP_PERMIT:
        return "permit";
        break;
    case RMAP_DENY:
        return "deny";
        break;
    default:
        return "";
        break;
    }
}

int
Bgp::route_map_empty (struct route_map *map)
{
    if (map->head == NULL && map->tail == NULL)
        return 1;
    else
        return 0;
}

/* For debug. */
void
Bgp::route_map_print ()
{
    struct route_map *map;
    struct route_map_index *index;
    struct route_map_rule *rule;

    for (map = route_map_master.head; map; map = map->next)
        for (index = map->head; index; index = index->next)
        {
            printf ("route-map %s %s %d\n", 
                    map->name,
                    route_map_type_str (index->type),
                    index->pref);
            for (rule = index->match_list.head; rule; rule = rule->next)
                printf (" match %s %s\n", rule->cmd->str, rule->rule_str);
            for (rule = index->set_list.head; rule; rule = rule->next)
                printf (" set %s %s\n", rule->cmd->str, rule->rule_str);
            if (index->exitpolicy == RMAP_GOTO)
                printf (" on-match goto %d\n", index->nextpref);
            if (index->exitpolicy == RMAP_NEXT)
                printf (" on-match next\n");
        }
}

/* New route map allocation. Please note route map's name must be
   specified. */
struct route_map_index *
Bgp::route_map_index_new ()
{
    struct route_map_index *New;

    New = (struct route_map_index * )    XMALLOC (MTYPE_ROUTE_MAP_INDEX, sizeof (struct route_map_index));
    bzero (New, sizeof (struct route_map_index));
    New->exitpolicy = RMAP_EXIT; /* Default to Cisco-style */
    return New;
}

/* Free route map index. */
void
Bgp::route_map_index_delete (struct route_map_index *index, int notify)
{
    struct route_map_rule *rule;

    /* Free route match. */
    while ((rule = index->match_list.head) != NULL)
        route_map_rule_delete (&index->match_list, rule);

    /* Free route set. */
    while ((rule = index->set_list.head) != NULL)
        route_map_rule_delete (&index->set_list, rule);

    /* Remove index from route map list. */
    if (index->next)
        index->next->prev = index->prev;
    else
        index->map->tail = index->prev;

    if (index->prev)
        index->prev->next = index->next;
    else
        index->map->head = index->next;

    /* Execute event hook. */
    if (route_map_master.event_hook && notify)
        (this->*route_map_master.event_hook) (RMAP_EVENT_INDEX_DELETED,
                                              index->map->name);

    XFREE (MTYPE_ROUTE_MAP_INDEX, index);
}

/* Lookup index from route map. */
struct route_map_index *
Bgp::route_map_index_lookup (struct route_map *map, enum route_map_type type,
                             int pref)
{
    struct route_map_index *index;

    for (index = map->head; index; index = index->next)
        if ((index->type == type || type == RMAP_ANY)
            && index->pref == pref)
            return index;
    return NULL;
}

/* Add New index to route map. */
struct route_map_index *
Bgp::route_map_index_add (struct route_map *map, enum route_map_type type,
                          int pref)
{
    struct route_map_index *index;
    struct route_map_index *point;

    /* Allocate New route map inex. */
    index = route_map_index_new ();
    index->map = map;
    index->type = type;
    index->pref = pref;

    /* Compare preference. */
    for (point = map->head; point; point = point->next)
        if (point->pref >= pref)
            break;

    if (map->head == NULL)
    {
        map->head = map->tail = index;
    } else if (point == NULL)
    {
        index->prev = map->tail;
        map->tail->next = index;
        map->tail = index;
    } else if (point == map->head)
    {
        index->next = map->head;
        map->head->prev = index;
        map->head = index;
    } else
    {
        index->next = point;
        index->prev = point->prev;
        if (point->prev)
            point->prev->next = index;
        point->prev = index;
    }

    /* Execute event hook. */
    if (route_map_master.event_hook)
        (this->*route_map_master.event_hook) (RMAP_EVENT_INDEX_ADDED,
                                              map->name);

    return index;
}

/* Get route map index. */
struct route_map_index *
Bgp::route_map_index_get (struct route_map *map, enum route_map_type type, 
                          int pref)
{
    struct route_map_index *index;

    index = route_map_index_lookup (map, RMAP_ANY, pref);
    if (index && index->type != type)
    {
        /* Delete index from route map. */
        route_map_index_delete (index, 1);
        index = NULL;
    }
    if (index == NULL)
        index = route_map_index_add (map, type, pref);
    return index;
}

/* New route map rule */
struct route_map_rule *
Bgp::route_map_rule_new ()
{
    struct route_map_rule *New;

    New = ( struct route_map_rule * ) XMALLOC (MTYPE_ROUTE_MAP_RULE, sizeof (struct route_map_rule));
    bzero (New, sizeof (struct route_map_rule));
    return New;
}

/* Install rule command to the match list. */
void
Bgp::route_map_install_match (struct route_map_rule_cmd *cmd)
{
    vector_set (route_match_vec, cmd);
}

/* Install rule command to the set list. */
void
Bgp::route_map_install_set (struct route_map_rule_cmd *cmd)
{
    vector_set (route_set_vec, cmd);
}

/* Lookup rule command from match list. */
struct route_map_rule_cmd *
Bgp::route_map_lookup_match (char *name)
{
    int i;
    struct route_map_rule_cmd *rule;

    for (i = 0; i < vector_max (route_match_vec); i++)
        if ((rule =( struct route_map_rule_cmd * )  vector_slot (route_match_vec, i)) != NULL)
            if (strcmp (rule->str, name) == 0)
                return rule;
    return NULL;
}

/* Lookup rule command from set list. */
struct route_map_rule_cmd *
Bgp::route_map_lookup_set (char *name)
{
    int i;
    struct route_map_rule_cmd *rule;

    for (i = 0; i < vector_max (route_set_vec); i++)
        if ((rule = ( struct route_map_rule_cmd * ) vector_slot (route_set_vec, i)) != NULL)
            if (strcmp (rule->str, name) == 0)
                return rule;
    return NULL;
}

/* Add match and set rule to rule list. */
void
Bgp::route_map_rule_add (struct route_map_rule_list *list,
                         struct route_map_rule *rule)
{
    rule->next = NULL;
    rule->prev = list->tail;
    if (list->tail)
        list->tail->next = rule;
    else
        list->head = rule;
    list->tail = rule;
}

/* Delete rule from rule list. */
void
Bgp::route_map_rule_delete (struct route_map_rule_list *list,
                            struct route_map_rule *rule)
{
    if (rule->cmd->func_free)
        (this->*rule->cmd->func_free) (rule->value);

    if (rule->rule_str)
        XFREE (MTYPE_ROUTE_MAP_RULE_STR, rule->rule_str);

    if (rule->next)
        rule->next->prev = rule->prev;
    else
        list->tail = rule->prev;
    if (rule->prev)
        rule->prev->next = rule->next;
    else
        list->head = rule->next;

    XFREE (MTYPE_ROUTE_MAP_RULE, rule);
}

/* strcmp wrapper function which don't crush even argument is NULL. */
int
Bgp::rulecmp (char *dst, char *src)
{
    if (dst == NULL)
    {
        if (src ==  NULL)
            return 0;
        else
            return 1;
    } else
    {
        if (src == NULL)
            return 1;
        else
            return strcmp (dst, src);
    }
    return 1;
}

/* Add match statement to route map. */
int
Bgp::route_map_add_match (struct route_map_index *index, char *match_name,
                          char *match_arg)
{
    struct route_map_rule *rule;
    struct route_map_rule *next;
    struct route_map_rule_cmd *cmd;
    void *compile;
    int replaced = 0;

    /* First lookup rule for add match statement. */
    cmd = route_map_lookup_match (match_name);
    if (cmd == NULL)
        return RMAP_RULE_MISSING;

    /* Next call compile function for this match statement. */
    if (cmd->func_compile)
    {
        compile= (this->*cmd->func_compile)(match_arg);
        if (compile == NULL)
            return RMAP_COMPILE_ERROR;
    } else
        compile = NULL;

    /* If argument is completely same ignore it. */
    for (rule = index->match_list.head; rule; rule = next)
    {
        next = rule->next;
        if (rule->cmd == cmd)
        {
            route_map_rule_delete (&index->match_list, rule);
            replaced = 1;
        }
    }

    /* Add New route map match rule. */
    rule = route_map_rule_new ();
    rule->cmd = cmd;
    rule->value = compile;
    if (match_arg)
        rule->rule_str = XSTRDUP (MTYPE_ROUTE_MAP_RULE_STR, match_arg);
    else
        rule->rule_str = NULL;

    /* Add New route match rule to linked list. */
    route_map_rule_add (&index->match_list, rule);

    /* Execute event hook. */
    if (route_map_master.event_hook)
        (this->*route_map_master.event_hook) (replaced ?
                                              RMAP_EVENT_MATCH_REPLACED:
                                              RMAP_EVENT_MATCH_ADDED,
                                              index->map->name);

    return 0;
}

/* Delete specified route match rule. */
int
Bgp::route_map_delete_match (struct route_map_index *index, char *match_name,
                             char *match_arg)
{
    struct route_map_rule *rule;
    struct route_map_rule_cmd *cmd;

    cmd = route_map_lookup_match (match_name);
    if (cmd == NULL)
        return 1;

    for (rule = index->match_list.head; rule; rule = rule->next)
        if (rule->cmd == cmd && 
            (rulecmp (rule->rule_str, match_arg) == 0 || match_arg == NULL))
        {
            route_map_rule_delete (&index->match_list, rule);
            /* Execute event hook. */
            if (route_map_master.event_hook)
                (this->*route_map_master.event_hook) (RMAP_EVENT_MATCH_DELETED,
                                                      index->map->name);
            return 0;
        }
        /* Cant find matched rule. */
    return 1;
}

/* Add route-map set statement to the route map. */
int
Bgp::route_map_add_set (struct route_map_index *index, char *set_name,
                        char *set_arg)
{
    struct route_map_rule *rule;
    struct route_map_rule *next;
    struct route_map_rule_cmd *cmd;
    void *compile;
    int replaced = 0;

    cmd = route_map_lookup_set (set_name);
    if (cmd == NULL)
        return RMAP_RULE_MISSING;

    /* Next call compile function for this match statement. */
    if (cmd->func_compile)
    {
        compile= (this->*cmd->func_compile)(set_arg);
        if (compile == NULL)
            return RMAP_COMPILE_ERROR;
    } else
        compile = NULL;

    /* Add by WJL. if old set command of same kind exist, delete it first
       to ensure only one set command of same kind exist under a
       route_map_index. */
    for (rule = index->set_list.head; rule; rule = next)
    {
        next = rule->next;
        if (rule->cmd == cmd)
        {
            route_map_rule_delete (&index->set_list, rule);
            replaced = 1;
        }
    }

    /* Add New route map match rule. */
    rule = route_map_rule_new ();
    rule->cmd = cmd;
    rule->value = compile;
    if (set_arg)
        rule->rule_str = XSTRDUP (MTYPE_ROUTE_MAP_RULE_STR, set_arg);
    else
        rule->rule_str = NULL;

    /* Add New route match rule to linked list. */
    route_map_rule_add (&index->set_list, rule);

    /* Execute event hook. */
    if (route_map_master.event_hook)
        (this->*route_map_master.event_hook) (replaced ?
                                              RMAP_EVENT_SET_REPLACED:
                                              RMAP_EVENT_SET_ADDED,
                                              index->map->name);
    return 0;
}

/* Delete route map set rule. */
int
Bgp::route_map_delete_set (struct route_map_index *index, char *set_name,
                           char *set_arg)
{
    struct route_map_rule *rule;
    struct route_map_rule_cmd *cmd;

    cmd = route_map_lookup_set (set_name);
    if (cmd == NULL)
        return 1;

    for (rule = index->set_list.head; rule; rule = rule->next)
        if ((rule->cmd == cmd) &&
            (rulecmp (rule->rule_str, set_arg) == 0 || set_arg == NULL))
        {
            route_map_rule_delete (&index->set_list, rule);
            /* Execute event hook. */
            if (route_map_master.event_hook)
                (this->*route_map_master.event_hook) (RMAP_EVENT_SET_DELETED,
                                                      index->map->name);
            return 0;
        }
        /* Cant find matched rule. */
    return 1;
}

/* Apply route map's each index to the object. */
/*
** The matrix for a route-map looks like this:
** (note, this includes the description for the "NEXT"
** and "GOTO" frobs now
**
**            Match   |   No Match
**                    |
**  permit      a     |      c
**                    |
**  ------------------+---------------
**                    |
**  deny        b     |      d
**                    |
**
** a)   Apply Set statements, accept route
**      If NEXT is specified, goto NEXT statement
**      If GOTO is specified, goto the first clause where pref > nextpref
**      If nothing is specified, do as Cisco and finish
** b)   Finish route-map processing, and deny route
** c) & d)   Goto Next index
**
** If we get no matches after we've processed all updates, then the route
** is dropped too.
**
** Some notes on the New "NEXT" and "GOTO"
**   on-match next    - If this clause is matched, then the set statements
**                      are executed and then we drop through to the next clause
**   on-match goto n  - If this clause is matched, then the set statments
**                      are executed and then we goto the nth clause, or the
**                      first clause greater than this. In order to ensure
**                      route-maps *always* exit, you cannot jump backwards.
**                      Sorry ;)
**
** We need to make sure our route-map processing matches the above
*/
route_map_result_t
Bgp::route_map_apply_index (struct route_map_index *index, struct prefix *prefix,
                            route_map_object_t type, void *object)
{
    int ret;
    struct route_map_rule *match;
    struct route_map_rule *set;

    /* Check all match rule and if there is no match rule return 0. */
    for (match = index->match_list.head; match; match = match->next)
    {
        /* Try each match statement in turn. If any return something
         other than RM_MATCH then we don't need to check anymore and can
         return */
        ret = (this->*match->cmd->func_apply)(match->value, prefix, type, object);
        if (ret != RMAP_MATCH)
            return(route_map_result_t) ret;
    }

    /* We get here if all match statements matched From the matrix
     above, if this is PERMIT we go on and apply the SET functions.  If
     we're deny, we return indicating we matched a deny */

    /* Apply set statement to the object. */
    if (index->type == RMAP_PERMIT)
    {
        for (set = index->set_list.head; set; set = set->next)
        {
            ret = (this->*set->cmd->func_apply)(set->value, prefix, type, object);
        }
        return RMAP_MATCH;
    } else
    {
        return RMAP_DENYMATCH;
    }
    /* Should not get here! */
    return RMAP_MATCH;
}

/* Apply route map to the object. */
route_map_result_t
Bgp::route_map_apply (struct route_map *map, struct prefix *prefix, 
                      route_map_object_t type, void *object)
{
    int ret = 0;
    struct route_map_index *index;

    if (map == NULL)
        return RMAP_DENYMATCH;

    for (index = map->head; index; index = index->next)
    {
        /* Apply this index. End here if we get a RM_NOMATCH */
        ret = route_map_apply_index (index, prefix, type, object);

        if (ret != RMAP_NOMATCH)
        {
            /* We now have to handle the NEXT and GOTO clauses */
            if (index->exitpolicy == RMAP_EXIT)
                return(route_map_result_t) ret;
            if (index->exitpolicy == RMAP_GOTO)
            {
                /* Find the next clause to jump to */
                struct route_map_index *next;

                next = index->next;
                while (next && next->pref < index->nextpref)
                {
                    index = next;
                    next = next->next;
                }
                if (next == NULL)
                {
                    /* No clauses match! */
                    return(route_map_result_t) ret;
                }
            }
            /* Otherwise, we fall through as it was a NEXT */
        }
    }
    /* Finally route-map does not match at all. */
    return RMAP_DENYMATCH;
}

void
Bgp::route_map_add_hook (void (Bgp::*func) ( char* ))
{
    route_map_master.add_hook = func;
}

void
Bgp::route_map_delete_hook (void (Bgp::*func) ( char* ))
{
    route_map_master.delete_hook = func;
}

void
Bgp::route_map_event_hook (void (Bgp::*func) (route_map_event_t, char *))
{
    route_map_master.event_hook = func;
}

void
Bgp::route_map_init ()
{
    /* Make vector for match and set. */
    route_match_vec = vector_init (1);
    route_set_vec = vector_init (1);
}

/* VTY related functions. */
DEFUN (route_map,
       route_map_cmd,
       "route-map WORD (deny|permit) <1-65535>",
       "Create route-map or enter route-map command mode\n"
       "Route map tag\n"
       "Route map denies set operations\n"
       "Route map permits set operations\n"
       "Sequence to insert to/delete from existing route-map entry\n")
{
    int permit;
    unsigned long pref;
    struct route_map *map;
    struct route_map_index *index;
    char *endptr = NULL;

    /* Permit check. */
    if (strncmp (argv[1], "permit", strlen (argv[1])) == 0)
        permit = RMAP_PERMIT;
    else if (strncmp (argv[1], "deny", strlen (argv[1])) == 0)
        permit = RMAP_DENY;
    else
    {
       vty_out (zlog_default,LOG_DEBUG, "the third field must be [permit|deny]%s", VTY_NEWLINE);
        return CMD_WARNING;
    }

    /* Preference check. */
    pref = strtoul (argv[2], &endptr, 10);
    if (pref == ULONG_MAX || *endptr != '\0')
    {
       vty_out (zlog_default,LOG_DEBUG, "the fourth field must be positive integer%s",
                 VTY_NEWLINE);
        return CMD_WARNING;
    }
    if (pref == 0 || pref > 65535)
    {
       vty_out (zlog_default,LOG_DEBUG, "the fourth field must be <1-65535>%s", VTY_NEWLINE);
        return CMD_WARNING;
    }

    /* Get route map. */
    map = route_map_get (argv[0]);
    index = route_map_index_get (map, ( enum route_map_type) permit, pref);

    vty->index = index;
    vty->node = RMAP_NODE;
    return CMD_SUCCESS;
}

DEFUN (no_route_map_all,
       no_route_map_all_cmd,
       "no route-map WORD",
       NO_STR
       "Create route-map or enter route-map command mode\n"
       "Route map tag\n")
{
    struct route_map *map;

    map = route_map_lookup_by_name (argv[0]);
    if (map == NULL)
    {
       vty_out (zlog_default,LOG_DEBUG, "%% Could not find route-map %s%s",
                 argv[0], VTY_NEWLINE);
        return CMD_WARNING;
    }

    route_map_delete (map);

    return CMD_SUCCESS;
}

DEFUN (no_route_map,
       no_route_map_cmd,
       "no route-map WORD (deny|permit) <1-65535>",
       NO_STR
       "Create route-map or enter route-map command mode\n"
       "Route map tag\n"
       "Route map denies set operations\n"
       "Route map permits set operations\n"
       "Sequence to insert to/delete from existing route-map entry\n")
{
    int permit;
    unsigned long pref;
    struct route_map *map;
    struct route_map_index *index;
    char *endptr = NULL;

    /* Permit check. */
    if (strncmp (argv[1], "permit", strlen (argv[1])) == 0)
        permit = RMAP_PERMIT;
    else if (strncmp (argv[1], "deny", strlen (argv[1])) == 0)
        permit = RMAP_DENY;
    else
    {
       vty_out (zlog_default,LOG_DEBUG, "the third field must be [permit|deny]%s", VTY_NEWLINE);
        return CMD_WARNING;
    }

    /* Preference. */
    pref = strtoul (argv[2], &endptr, 10);
    if (pref == ULONG_MAX || *endptr != '\0')
    {
       vty_out (zlog_default,LOG_DEBUG, "the fourth field must be positive integer%s",
                 VTY_NEWLINE);
        return CMD_WARNING;
    }
    if (pref == 0 || pref > 65535)
    {
       vty_out (zlog_default,LOG_DEBUG, "the fourth field must be <1-65535>%s", VTY_NEWLINE);
        return CMD_WARNING;
    }

    /* Existence check. */
    map = route_map_lookup_by_name (argv[0]);
    if (map == NULL)
    {
       vty_out (zlog_default,LOG_DEBUG, "%% Could not find route-map %s%s",
                 argv[0], VTY_NEWLINE);
        return CMD_WARNING;
    }

    /* Lookup route map index. */
    index = route_map_index_lookup (map, (enum route_map_type ) permit, pref);
    if (index == NULL)
    {
       vty_out (zlog_default,LOG_DEBUG, "%% Could not find route-map entry %s %s%s", 
                 argv[0], argv[2], VTY_NEWLINE);
        return CMD_WARNING;
    }

    /* Delete index from route map. */
    route_map_index_delete (index, 1);

    /* If this route rule is the last one, delete route map itself. */
    if (route_map_empty (map))
        route_map_delete (map);

    return CMD_SUCCESS;
}

DEFUN (rmap_onmatch_next,
       rmap_onmatch_next_cmd,
       "on-match next",
       "Exit policy on matches\n"
       "Next clause\n")
{
    struct route_map_index *index;

    index = (struct route_map_index *)  vty->index;

    if (index)
        index->exitpolicy = RMAP_NEXT;

    return CMD_SUCCESS;
}

DEFUN (no_rmap_onmatch_next,
       no_rmap_onmatch_next_cmd,
       "no on-match next",
       NO_STR
       "Exit policy on matches\n"
       "Next clause\n")
{
    struct route_map_index *index;

    index = (struct route_map_index *) vty->index;

    if (index)
        index->exitpolicy = RMAP_EXIT;

    return CMD_SUCCESS;
}

DEFUN (rmap_onmatch_goto,
       rmap_onmatch_goto_cmd,
       "on-match goto <1-65535>",
       "Exit policy on matches\n"
       "Goto Clause number\n"
       "Number\n")
{
    struct route_map_index *index;
    int d = 0;

    if (argv[0])
        d = atoi(argv[0]);

    index =(struct route_map_index *) vty->index;
    if (index)
    {
        if (d <= index->pref)
        {
            /* Cant allow you to do that, Dave */
           vty_out (zlog_default,LOG_DEBUG, "can't jump backwards in route-maps%s", 
                     VTY_NEWLINE);
            return CMD_WARNING;
        } else
        {
            index->exitpolicy = RMAP_GOTO;
            index->nextpref = d;
        }
    }
    return CMD_SUCCESS;
}

DEFUN (no_rmap_onmatch_goto,
       no_rmap_onmatch_goto_cmd,
       "no on-match goto",
       NO_STR
       "Exit policy on matches\n"
       "Next clause\n")
{
    struct route_map_index *index;

    index = (struct route_map_index *) vty->index;

    if (index)
        index->exitpolicy = RMAP_EXIT;

    return CMD_SUCCESS;
}

/* Configuration write function. */
int
Bgp::route_map_config_write (struct vty *vty)
{
    struct route_map *map;
    struct route_map_index *index;
    struct route_map_rule *rule;
    int first = 1;
    int write = 0;

    for (map = route_map_master.head; map; map = map->next)
        for (index = map->head; index; index = index->next)
        {
            if (!first)
               vty_out (zlog_default,LOG_DEBUG, "!%s", VTY_NEWLINE);
            else
                first = 0;

           vty_out (zlog_default,LOG_DEBUG, "route-map %s %s %d%s", 
                     map->name,
                     route_map_type_str (index->type),
                     index->pref, VTY_NEWLINE);

            for (rule = index->match_list.head; rule; rule = rule->next)
               vty_out (zlog_default,LOG_DEBUG, " match %s %s%s", rule->cmd->str, 
                         rule->rule_str ? rule->rule_str : "",
                         VTY_NEWLINE);

            for (rule = index->set_list.head; rule; rule = rule->next)
               vty_out (zlog_default,LOG_DEBUG, " set %s %s%s", rule->cmd->str,
                         rule->rule_str ? rule->rule_str : "",
                         VTY_NEWLINE);
            if (index->exitpolicy == RMAP_GOTO)
               vty_out (zlog_default,LOG_DEBUG, " on-match goto %d%s", index->nextpref,
                         VTY_NEWLINE);
            if (index->exitpolicy == RMAP_NEXT)
               vty_out (zlog_default,LOG_DEBUG," on-match next%s", VTY_NEWLINE);

            write++;
        }
    return write;
}

/* Initialization of route map vector. */
void
Bgp::route_map_init_vty ()
{
    /* Install route map top node. */
    install_node (&rmap_node, &Bgp::route_map_config_write);

    /* Install route map commands. */
    install_element (CONFIG_NODE, &route_map_cmd);
    install_element (CONFIG_NODE, &no_route_map_cmd);
    install_element (CONFIG_NODE, &no_route_map_all_cmd);

    /* Install the on-match stuff */
    install_element (CONFIG_NODE, &rmap_onmatch_next_cmd);
    install_element (CONFIG_NODE, &no_rmap_onmatch_next_cmd);
    install_element (CONFIG_NODE, &rmap_onmatch_goto_cmd);
    install_element (CONFIG_NODE, &no_rmap_onmatch_goto_cmd);
}


////////////////////////////////////////////////
////////////////////////////////////////////////
//sockunion.c///////////////////////////////////
////////////////////////////////////////////////

#ifndef HAVE_INET_ATON
 
int
Bgp::inet_aton (const char *cp, struct in_addr *inaddr)
{
  int dots = 0;
  register u_long addr = 0;
  register u_long val = 0, base = 10;
 
  do
    {
      register char c = *cp;
 
      switch (c)
	{
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	  val = (val * base) + (c - '0');
	  break;
	case '.':
	  if (++dots > 3)
	    return 0;
	case '\0':
	  if (val > 255)
	    return 0;
	  addr = addr << 8 | val;
	  val = 0;
	  break;
	default:
	  return 0;
	}
    } while (*cp++) ;
 
  if (dots < 3)
    addr <<= 8 * (3 - dots);
  if (inaddr)
    inaddr->s_addr = htonl (addr);
  return 1;
}
#endif /* ! HAVE_INET_ATON */
 
 
#ifndef HAVE_INET_PTON
int
Bgp::inet_pton (int family, const char *strptr, void *addrptr)
{
  if (family == AF_INET)
    {
      struct in_addr in_val;
 
      if (inet_aton (strptr, &in_val))
        {
	  memcpy (addrptr, &in_val, sizeof (struct in_addr));
	  return 1;
	}
      return 0;
    }
  errno = EAFNOSUPPORT;
  return -1;
}
#endif /* ! HAVE_INET_PTON */
 
#ifndef HAVE_INET_NTOP
const char *
Bgp::inet_ntop (int family, const void *addrptr, char *strptr, size_t len)
{
  unsigned char *p = (unsigned char *) addrptr;
 
  if (family == AF_INET)
    {
      char temp[INET_ADDRSTRLEN];
 
      snprintf(temp, sizeof(temp), "%d.%d.%d.%d", p[0], p[1], p[2], p[3]);
 
      if (strlen(temp) >= len)
	{
	  errno = ENOSPC;
	  return NULL;
	}
      strcpy(strptr, temp);
      return strptr;
    } 
  errno = EAFNOSUPPORT;
  return NULL;
} 
#endif /* ! HAVE_INET_NTOP */
 
const char *
Bgp::inet_sutop (union sockunion *su, char *str)
{
    switch (su->sa.sa_family)
    {
    case AF_INET:
      Bgp::inet_ntop (AF_INET, &su->sin.sin_addr, str, INET_ADDRSTRLEN);
        break;
    }
    return str;
}

int
Bgp::str2sockunion (char *str, union sockunion *su)
{
    int ret;

    memset (su, 0, sizeof (union sockunion));

    ret = inet_pton (AF_INET, str, &su->sin.sin_addr);
    if (ret > 0)          /* Valid IPv4 address format. */
    {
        su->sin.sin_family = AF_INET;
#ifdef HAVE_SIN_LEN
        su->sin.sin_len = sizeof(struct sockaddr_in);
#endif /* HAVE_SIN_LEN */
        return 0;
    }
    return -1;
}

const char *
Bgp::sockunion2str (union sockunion *su, char *buf, size_t len)
{
    if (su->sa.sa_family == AF_INET)
        return Bgp::inet_ntop (AF_INET, &su->sin.sin_addr, buf, len);
    return NULL;
}

union sockunion *
Bgp::sockunion_str2su (char *str)
{
    int ret;
    union sockunion *su;

    su = (union sockunion *) XMALLOC (MTYPE_SOCKUNION, sizeof (union sockunion));
    memset (su, 0, sizeof (union sockunion));

    ret = inet_pton (AF_INET, str, &su->sin.sin_addr);
    if (ret > 0)          /* Valid IPv4 address format. */
    {
        su->sin.sin_family = AF_INET;
#ifdef HAVE_SIN_LEN
        su->sin.sin_len = sizeof(struct sockaddr_in);
#endif /* HAVE_SIN_LEN */
        return su;
    }
    XFREE (MTYPE_SOCKUNION, su);
    return NULL;
}

char *
Bgp::sockunion_su2str (union sockunion *su)
{
    char str[INET6_ADDRSTRLEN];

    switch (su->sa.sa_family)
    {
    case AF_INET:
        Bgp::inet_ntop (AF_INET, &su->sin.sin_addr, str, sizeof (str));
        break;
    }
    return strdup (str);
}

/* If same family and same prefix return 1. */
int
Bgp::sockunion_same (union sockunion *su1, union sockunion *su2)
{
    int ret = 0;

    if (su1->sa.sa_family != su2->sa.sa_family)
        return 0;

    switch (su1->sa.sa_family)
    {
    case AF_INET:
        ret = memcmp (&su1->sin.sin_addr, &su2->sin.sin_addr,
                      sizeof (struct in_addr));
        break;
    }
    if (ret == 0)
        return 1;
    else
        return 0;
}

int
Bgp::sockunion_cmp (union sockunion *su1, union sockunion *su2)
{
    if (su1->sa.sa_family > su2->sa.sa_family)
        return 1;
    if (su1->sa.sa_family < su2->sa.sa_family)
        return -1;

    if (su1->sa.sa_family == AF_INET)
    {
        if (ntohl (su1->sin.sin_addr.s_addr) == ntohl (su2->sin.sin_addr.s_addr))
            return 0;
        if (ntohl (su1->sin.sin_addr.s_addr) > ntohl (su2->sin.sin_addr.s_addr))
            return 1;
        else
            return -1;
    }

    return 0;
}
 
////////////////////////////////////////////////
////////////////////////////////////////////////
///str.c////////////////////////////////////////
//////////////////////////////////////////////// 

#ifndef HAVE_STRLCPY
/*
 * strlcpy is a safer version of strncpy(), checking the total
 * size of the buffer
 */
size_t
Bgp::strlcpy(char *dst, const char *src, size_t size)
{
  strncpy(dst, src, size);
 
  return(strlen(dst));
}
#endif
 
#ifndef HAVE_STRLCAT
/*
 * strlcat is a safer version of strncat(), checking the total
 * size of the buffer
 */
size_t
Bgp::strlcat(char *dst, const char *src, size_t size)
{
  /* strncpy(dst, src, size - strlen(dst)); */
 
  /* I've just added below code only for workable under Linux.  So
     need rewrite -- Kunihiro. */
  if (strlen (dst) + strlen (src) >= size)
    return 0;
  strcat (dst, src);
 
  return(strlen(dst));
}
#endif
 
////////////////////////////////////////////////
////////////////////////////////////////////////
//stream.c//////////////////////////////////////
////////////////////////////////////////////////

/* Stream is fixed length buffer for network output/input. */

/* Make stream buffer. */
struct stream *
Bgp::stream_new (size_t size)
{
    struct stream *s;

    s = (struct stream * ) XMALLOC (MTYPE_STREAM, sizeof (struct stream));
    bzero (s, sizeof (struct stream));

    s->data = ( unsigned char * ) XMALLOC (MTYPE_STREAM_DATA, size);
    s->size = size;
    return s;
}

/* Free it now. */
void
Bgp::stream_free (struct stream *s)
{
    XFREE (MTYPE_STREAM_DATA, s->data);
    XFREE (MTYPE_STREAM, s);
}

unsigned long
Bgp::stream_get_getp (struct stream *s)
{
    return s->getp;
}

unsigned long
Bgp::stream_get_putp (struct stream *s)
{
    return s->putp;
}

unsigned long
Bgp::stream_get_endp (struct stream *s)
{
    return s->endp;
}

unsigned long
Bgp::stream_get_size (struct stream *s)
{
    return s->size;
}

/* Stream structre' stream pointer related functions.  */
void
Bgp::stream_set_getp (struct stream *s, unsigned long pos)
{
    s->getp = pos;
}

void
Bgp::stream_set_putp (struct stream *s, unsigned long pos)
{
    s->putp = pos;
}

/* Forward pointer. */
void
Bgp::stream_forward (struct stream *s, int size)
{
    s->getp += size;
}

/* Copy from stream to destination. */
void
Bgp::stream_get (void *dst, struct stream *s, size_t size)
{
    memcpy (dst, s->data + s->getp, size);
    s->getp += size;
}

/* Get next character from the stream. */
u_char
Bgp::stream_getc (struct stream *s)
{
    u_char c;

    c = s->data[s->getp];
    s->getp++;
    return c;
}

/* Get next character from the stream. */
u_char
Bgp::stream_getc_from (struct stream *s, unsigned long from)
{
    u_char c;

    c = s->data[from];
    return c;
}

/* Get next word from the stream. */
u_int16_t
Bgp::stream_getw (struct stream *s)
{
    u_int16_t w;

    w = s->data[s->getp++] << 8;
    w |= s->data[s->getp++];
    return w;
}

/* Get next word from the stream. */
u_int16_t
Bgp::stream_getw_from (struct stream *s, unsigned long from)
{
    u_int16_t w;

    w = s->data[from++] << 8;
    w |= s->data[from];
    return w;
}

/* Get next long word from the stream. */
u_int32_t
Bgp::stream_getl (struct stream *s)
{
    u_int32_t l;

    l  = s->data[s->getp++] << 24;
    l |= s->data[s->getp++] << 16;
    l |= s->data[s->getp++] << 8;
    l |= s->data[s->getp++];
    return l;
}

/* Get next long word from the stream. */
u_int32_t
Bgp::stream_get_ipv4 (struct stream *s)
{
    u_int32_t l;

    memcpy (&l, s->data + s->getp, 4);
    s->getp += 4;

    return l;
}

/* Copy to source to stream. */
void
Bgp::stream_put (struct stream *s, void *src, size_t size)
{

    CHECK_SIZE(s, size);

    if (src)
        memcpy (s->data + s->putp, src, size);
    else
        memset (s->data + s->putp, 0, size);

    s->putp += size;
    if (s->putp > s->endp)
        s->endp = s->putp;
}

/* Put character to the stream. */
int
Bgp::stream_putc (struct stream *s, u_char c)
{
    if (s->putp >= s->size) return 0;

    s->data[s->putp] = c;
    s->putp++;
    if (s->putp > s->endp)
        s->endp = s->putp;
    return 1;
}

/* Put word to the stream. */
int
Bgp::stream_putw (struct stream *s, u_int16_t w)
{
    if ((s->size - s->putp) < 2) return 0;

    s->data[s->putp++] = (u_char)(w >>  8);
    s->data[s->putp++] = (u_char) w;

    if (s->putp > s->endp)
        s->endp = s->putp;
    return 2;
}

/* Put long word to the stream. */
int
Bgp::stream_putl (struct stream *s, u_int32_t l)
{
    if ((s->size - s->putp) < 4) return 0;

    s->data[s->putp++] = (u_char)(l >> 24);
    s->data[s->putp++] = (u_char)(l >> 16);
    s->data[s->putp++] = (u_char)(l >>  8);
    s->data[s->putp++] = (u_char)l;

    if (s->putp > s->endp)
        s->endp = s->putp;
    return 4;
}

int
Bgp::stream_putc_at (struct stream *s, unsigned long putp, u_char c)
{
    s->data[putp] = c;
    return 1;
}

int
Bgp::stream_putw_at (struct stream *s, unsigned long putp, u_int16_t w)
{
    s->data[putp] = (u_char)(w >>  8);
    s->data[putp + 1] = (u_char) w;
    return 2;
}

int
Bgp::stream_putl_at (struct stream *s, unsigned long putp, u_int32_t l)
{
    s->data[putp] = (u_char)(l >> 24);
    s->data[putp + 1] = (u_char)(l >> 16);
    s->data[putp + 2] = (u_char)(l >>  8);
    s->data[putp + 3] = (u_char)l;
    return 4;
}

/* Put long word to the stream. */
int
Bgp::stream_put_ipv4 (struct stream *s, u_int32_t l)
{
    if ((s->size - s->putp) < 4)
        return 0;

    memcpy (s->data + s->putp, &l, 4);
    s->putp += 4;

    if (s->putp > s->endp)
        s->endp = s->putp;
    return 4;
}

/* Put long word to the stream. */
int
Bgp::stream_put_in_addr (struct stream *s, struct in_addr *addr)
{
    if ((s->size - s->putp) < 4)
        return 0;

    memcpy (s->data + s->putp, addr, 4);
    s->putp += 4;

    if (s->putp > s->endp)
        s->endp = s->putp;
    return 4;
}

/* Put prefix by nlri type format. */
int
Bgp::stream_put_prefix (struct stream *s, struct prefix *p)
{
    u_char psize;

    psize = PSIZE (p->prefixlen);

    if ((s->size - s->putp) < psize) return 0;

    stream_putc (s, p->prefixlen);
    memcpy (s->data + s->putp, &p->u.prefix, psize);
    s->putp += psize;

    if (s->putp > s->endp)
        s->endp = s->putp;

    return psize;
}

/* Read size from fd. */
int
Bgp::stream_read (struct stream *s, int fd, size_t size)
{
    int nbytes;

    nbytes = readn (fd,( char * )(s->data + s->putp), size);

    if (nbytes > 0)
    {
        s->putp += nbytes;
        s->endp += nbytes;
    }
    return nbytes;
}

/* Read size from fd. */
int
Bgp::stream_read_unblock (struct stream *s, size_t size)
{
    int nbytes;
    int val;

    nbytes = ReceivedMsg.Get((int)size,(char*) s->data + s->putp);

    if (nbytes > 0)
    {
        s->putp += nbytes;
        s->endp += nbytes;
    }
    return nbytes;
}

/* Write data to buffer. */
int
Bgp::stream_write (struct stream *s, u_char *ptr, size_t size)
{

    CHECK_SIZE(s, size);

    memcpy (s->data + s->putp, ptr, size);
    s->putp += size;
    if (s->putp > s->endp)
        s->endp = s->putp;
    return size;
}

/* Return current read pointer. */
u_char *
Bgp::stream_pnt (struct stream *s)
{
    return s->data + s->getp;
}

/* Check does this stream empty? */
int
Bgp::stream_empty (struct stream *s)
{
    if (s->putp == 0 && s->endp == 0 && s->getp == 0)
        return 1;
    else
        return 0;
}

/* Reset stream. */
void
Bgp::stream_reset (struct stream *s)
{
    s->putp = 0;
    s->endp = 0;
    s->getp = 0;
}

/* Write stream contens to the file discriptor. */
int
Bgp::stream_flush (struct stream *s, int fd)
{
    int nbytes;

    nbytes = write (fd, s->data + s->getp, s->endp - s->getp);

    return nbytes;
}

/* Stream first in first out queue. */

struct stream_fifo *
Bgp::stream_fifo_new ()
{
    struct stream_fifo *New;

    New = ( struct stream_fifo * )  XMALLOC (MTYPE_STREAM_FIFO, sizeof (struct stream_fifo));
    bzero (New, sizeof (struct stream_fifo)); 
    return New;
}

/* Add New stream to fifo. */
void
Bgp::stream_fifo_push (struct stream_fifo *fifo, struct stream *s)
{
    if (fifo->tail)
        fifo->tail->next = s;
    else
        fifo->head = s;

    fifo->tail = s;

    fifo->count++;
}

/* Delete first stream from fifo. */
struct stream *
Bgp::stream_fifo_pop (struct stream_fifo *fifo)
{
    struct stream *s;

    s = fifo->head; 

    if (s)
    {
        fifo->head = s->next;

        if (fifo->head == NULL)
            fifo->tail = NULL;
    }

    fifo->count--;

    return s; 
}

/* Return first fifo entry. */
struct stream *
Bgp::stream_fifo_head (struct stream_fifo *fifo)
{
    return fifo->head;
}

void
Bgp::stream_fifo_free (struct stream_fifo *fifo)
{
    struct stream *s;
    struct stream *next;

    for (s = fifo->head; s; s = next)
    {
        next = s->next;
        stream_free (s);
    }
    fifo->head = fifo->tail = NULL;
    fifo->count = 0;
}



////////////////////////////////////////////////
////////////////////////////////////////////////
/////table.c////////////////////////////////////
////////////////////////////////////////////////

struct bgp_table *
Bgp::route_table_init (void)
{
    struct bgp_table *rt;

    rt =(struct bgp_table* )  XMALLOC (MTYPE_ROUTE_TABLE, sizeof (struct bgp_table));
    bzero (rt, sizeof (struct bgp_table));
    return rt;
}

void
Bgp::route_table_finish (struct bgp_table *rt)
{
    route_table_free (rt);
}

/* Allocate New route node. */
struct bgp_node *
Bgp::route_node_new ()
{
    struct bgp_node *node;

    node = ( struct bgp_node * ) XMALLOC (MTYPE_ROUTE_NODE, sizeof (struct bgp_node));
    bzero (node, sizeof (struct bgp_node));

    return node;
}

/* Allocate New route node with prefix set. */
struct bgp_node *
Bgp::route_node_set (struct bgp_table *table, struct prefix *prefix)
{
    struct bgp_node *node;

    node = ( struct bgp_node * ) XMALLOC (MTYPE_ROUTE_NODE, sizeof (struct bgp_node));
    bzero (node, sizeof (struct bgp_node));

    prefix_copy (&node->p, prefix);
    node->table = table;

    return node;
}

/* Free route node. */
void
Bgp::route_node_free (struct bgp_node *node)
{
    XFREE (MTYPE_ROUTE_NODE, node);
}

/* Free route table. */
void
Bgp::route_table_free (struct bgp_table *rt)
{
    struct bgp_node *tmp_node;
    struct bgp_node *node;

    if (rt == NULL)
        return;

    node = rt->top;

    while (node)
    {
        if (node->l_left)
        {
            node = node->l_left;
            continue;
        }

        if (node->l_right)
        {
            node = node->l_right;
            continue;
        }

        tmp_node = node;
        node = node->parent;

        if (node != NULL)
        {
            if (node->l_left == tmp_node)
                node->l_left = NULL;
            else
                node->l_right = NULL;

            route_node_free (tmp_node);
        } else
        {
            route_node_free (tmp_node);
            break;
        }
    }

    XFREE (MTYPE_ROUTE_TABLE, rt);
    return;
}

/* Common prefix route genaration. */
void
Bgp::route_common (struct prefix *n, struct prefix *p, struct prefix *New)
{
    int i;
    u_char diff;
    u_char mask;

    u_char *np = (u_char *)&n->u.prefix;
    u_char *pp = (u_char *)&p->u.prefix;
    u_char *newp = (u_char *)&New->u.prefix;

    for (i = 0; i < p->prefixlen / 8; i++)
    {
        if (np[i] == pp[i])
            newp[i] = np[i];
        else
            break;
    }

    New->prefixlen = i * 8;

    if (New->prefixlen != p->prefixlen)
    {
        diff = np[i] ^ pp[i];
        mask = 0x80;
        while (New->prefixlen < p->prefixlen && !(mask & diff))
        {
            mask >>= 1;
            New->prefixlen++;
        }
        newp[i] = np[i] & maskbit[New->prefixlen % 8];
    }
}

/* Check bit of the prefix. */
int
Bgp::check_bit (u_char *prefix, u_char prefixlen)
{
    int offset;
    int shift;
    u_char *p = (u_char *)prefix;

    assert (prefixlen <= 128);

    offset = prefixlen / 8;
    shift = 7 - (prefixlen % 8);

    return(p[offset] >> shift & 1);
}


void
Bgp::set_link (struct bgp_node *node, struct bgp_node *New)
{
    int bit;

    bit = check_bit (&New->p.u.prefix, node->p.prefixlen);

    assert (bit == 0 || bit == 1);

    node->link[bit] = New;
    New->parent = node;
}

/* Lock node. */
struct bgp_node *
Bgp::route_lock_node (struct bgp_node *node)
{
    node->lock++;
    return node;
}

/* Unlock node. */
void
Bgp::route_unlock_node (struct bgp_node *node)
{
    node->lock--;

    if (node->lock == 0)
        route_node_delete (node);
}

/* Dump routing table. */
void
Bgp::route_dump_node (struct bgp_table *t)
{
    struct bgp_node *node;
    char buf[46];

    for (node = route_top (t); node != NULL; node = route_next (node))
    {
        printf ("[%d] %p %s/%d\n", 
                node->lock,
                node->info,
                Bgp::inet_ntop (node->p.family, &node->p.u.prefix, buf, 46),
                node->p.prefixlen);
    }
}

/* Find matched prefix. */
struct bgp_node *
Bgp::route_node_match (struct bgp_table *table, struct prefix *p)
{
    struct bgp_node *node;
    struct bgp_node *matched;

    matched = NULL;
    node = table->top;

    /* Walk down tree.  If there is matched route then store it to
       matched. */
    while (node && node->p.prefixlen <= p->prefixlen && 
           prefix_match (&node->p, p))
    {
        if (node->info)
            matched = node;
        node = node->link[check_bit(&p->u.prefix, node->p.prefixlen)];
    }

    /* If matched route found, return it. */
    if (matched)
        return route_lock_node (matched);

    return NULL;
}

struct bgp_node *
Bgp::route_node_match_ipv4 (struct bgp_table *table, struct in_addr *addr)
{
    struct prefix_ipv4 p;

    memset (&p, 0, sizeof (struct prefix_ipv4));
    p.family = AF_INET;
    p.prefixlen = IPV4_MAX_PREFIXLEN;
    p.prefix = *addr;

    return route_node_match (table, (struct prefix *) &p);
}


/* Lookup same prefix node.  Return NULL when we can't find route. */
struct bgp_node *
Bgp::route_node_lookup (struct bgp_table *table, struct prefix *p)
{
    struct bgp_node *node;

    node = table->top;

    while (node && node->p.prefixlen <= p->prefixlen && 
           prefix_match (&node->p, p))
    {
        if (node->p.prefixlen == p->prefixlen && node->info)
            return route_lock_node (node);

        node = node->link[check_bit(&p->u.prefix, node->p.prefixlen)];
    }

    return NULL;
}

/* Add node to routing table. */
struct bgp_node *
Bgp::route_node_get (struct bgp_table *table, struct prefix *p)
{
    struct bgp_node *New;
    struct bgp_node *node;
    struct bgp_node *match;

    match = NULL;
    node = table->top;
    while (node && node->p.prefixlen <= p->prefixlen && 
           prefix_match (&node->p, p))
    {
        if (node->p.prefixlen == p->prefixlen)
        {
            route_lock_node (node);
            return node;
        }
        match = node;
        node = node->link[check_bit(&p->u.prefix, node->p.prefixlen)];
    }

    if (node == NULL)
    {
        New = route_node_set (table, p);
        if (match)
            set_link (match, New);
        else
            table->top = New;
    } else
    {
        New = route_node_new ();
        route_common (&node->p, p, &New->p);
        New->p.family = p->family;
        New->table = table;
        set_link (New, node);

        if (match)
            set_link (match, New);
        else
            table->top = New;

        if (New->p.prefixlen != p->prefixlen)
        {
            match = New;
            New = route_node_set (table, p);
            set_link (match, New);
        }
    }
    route_lock_node (New);

    return New;
}

/* Delete node from the routing table. */
void
Bgp::route_node_delete (struct bgp_node *node)
{
    struct bgp_node *child;
    struct bgp_node *parent;

    assert (node->lock == 0);
    assert (node->info == NULL);

    if (node->l_left && node->l_right)
        return;

    if (node->l_left)
        child = node->l_left;
    else
        child = node->l_right;

    parent = node->parent;

    if (child)
        child->parent = parent;

    if (parent)
    {
        if (parent->l_left == node)
            parent->l_left = child;
        else
            parent->l_right = child;
    } else
        node->table->top = child;

    route_node_free (node);

    /* If parent node is stub then delete it also. */
    if (parent && parent->lock == 0)
        route_node_delete (parent);
}

/* Get fist node and lock it.  This function is useful when one want
   to lookup all the node exist in the routing table. */
struct bgp_node *
Bgp::route_top (struct bgp_table *table)
{
    /* If there is no node in the routing table return NULL. */
    if (table->top == NULL)
        return NULL;

    /* Lock the top node and return it. */
    route_lock_node (table->top);
    return table->top;
}

/* Unlock current node and lock next node then return it. */
struct bgp_node *
Bgp::route_next (struct bgp_node *node)
{
    struct bgp_node *next;
    struct bgp_node *start;

    /* Node may be deleted from route_unlock_node so we have to preserve
       next node's pointer. */

    if (node->l_left)
    {
        next = node->l_left;
        route_lock_node (next);
        route_unlock_node (node);
        return next;
    }
    if (node->l_right)
    {
        next = node->l_right;
        route_lock_node (next);
        route_unlock_node (node);
        return next;
    }

    start = node;
    while (node->parent)
    {
        if (node->parent->l_left == node && node->parent->l_right)
        {
            next = node->parent->l_right;
            route_lock_node (next);
            route_unlock_node (start);
            return next;
        }
        node = node->parent;
    }
    route_unlock_node (start);
    return NULL;
}

/* Unlock current node and lock next node until limit. */
struct bgp_node *
Bgp::route_next_until (struct bgp_node *node, struct bgp_node *limit)
{
    struct bgp_node *next;
    struct bgp_node *start;

    /* Node may be deleted from route_unlock_node so we have to preserve
       next node's pointer. */

    if (node->l_left)
    {
        next = node->l_left;
        route_lock_node (next);
        route_unlock_node (node);
        return next;
    }
    if (node->l_right)
    {
        next = node->l_right;
        route_lock_node (next);
        route_unlock_node (node);
        return next;
    }

    start = node;
    while (node->parent && node != limit)
    {
        if (node->parent->l_left == node && node->parent->l_right)
        {
            next = node->parent->l_right;
            route_lock_node (next);
            route_unlock_node (start);
            return next;
        }
        node = node->parent;
    }
    route_unlock_node (start);
    return NULL;
}



////////////////////////////////////////////////
////////////////////////////////////////////////
//thread.c//////////////////////////////////////
////////////////////////////////////////////////


/* Make thread master. */
struct thread_master *
Bgp::thread_make_master ()
{
    struct thread_master *New;

    New = ( struct thread_master * ) XMALLOC (MTYPE_THREAD_MASTER, sizeof (struct thread_master));
    bzero (New, sizeof (struct thread_master));

    return New;
}

/* Add a New thread to the list. */
void
Bgp::thread_list_add (struct thread_list *list, struct thread *thread)
{
    thread->next = NULL;
    thread->prev = list->tail;
    if (list->tail)
        list->tail->next = thread;
    else
        list->head = thread;
    list->tail = thread;
    list->count++;
}

/* Add a New thread to the list. */
void
Bgp::thread_list_add_before (struct thread_list *list, 
                             struct thread *point, 
                             struct thread *thread)
{
    thread->next = point;
    thread->prev = point->prev;
    if (point->prev)
        point->prev->next = thread;
    else
        list->head = thread;
    point->prev = thread;
    list->count++;
}

/* Delete a thread from the list. */
struct thread *
Bgp::thread_list_delete (struct thread_list *list, struct thread *thread)
{
    if (thread->next)
        thread->next->prev = thread->prev;
    else
        list->tail = thread->prev;
    if (thread->prev)
        thread->prev->next = thread->next;
    else
        list->head = thread->next;
    thread->next = thread->prev = NULL;
    list->count--;
    return thread;
}

/* Free all unused thread. */
void
Bgp::thread_clean_unuse (struct thread_master *m)
{
    struct thread *thread;

    thread = m->unuse.head;
    while (thread)
    {
        struct thread *t;

        t = thread;
        thread = t->next;

        thread_list_delete (&m->unuse, t);
        XFREE (MTYPE_THREAD, t);
        m->alloc--;
    }
}

/* Move thread to unuse list. */
void
Bgp::thread_add_unuse (struct thread_master *m, struct thread *thread)
{
    assert (m != NULL);
    assert (thread->next == NULL);
    assert (thread->prev == NULL);
    assert (thread->type == THREAD_UNUSED);
    thread_list_add (&m->unuse, thread);
}

/* Stop thread scheduler. */
void
Bgp::thread_destroy_master (struct thread_master *m)
{
    struct thread *thread;

    thread = m->read.head;
    while (thread)
    {
        struct thread *t;

        t = thread;
        thread = t->next;

        thread_list_delete (&m->read, t);
        t->type = THREAD_UNUSED;
	XFREE (MTYPE_THREAD,t);
    }

    thread = m->write.head;
    while (thread)
    {
        struct thread *t;

        t = thread;
        thread = t->next;

        thread_list_delete (&m->write, t);
        t->type = THREAD_UNUSED;
	XFREE (MTYPE_THREAD,t);
    }

    thread = m->timer.head;
    while (thread)
    {
        struct thread *t;

        t = thread;
        thread = t->next;

        thread_list_delete (&m->timer, t);
        t->type = THREAD_UNUSED;
	XFREE (MTYPE_THREAD,t);
    }
    
    thread = m->event.head;
    while (thread)
    {
        struct thread *t;

        t = thread;
        thread = t->next;

        thread_list_delete (&m->event, t);
        t->type = THREAD_UNUSED;
	XFREE (MTYPE_THREAD,t);
    }

    thread = m->ready.head;
    while (thread)
    {
        struct thread *t;

        t = thread;
        thread = t->next;

        thread_list_delete (&m->ready, t);
        t->type = THREAD_UNUSED;
	XFREE (MTYPE_THREAD,t);
    }

    thread_clean_unuse (m);
    XFREE (MTYPE_THREAD_MASTER, m);
}

/* Delete top of the list and return it. */
struct thread *
Bgp::thread_trim_head (struct thread_list *list)
{
    if (list->head)
        return thread_list_delete (list, list->head);
    return NULL;
}

/* Make New thread. */
struct thread *
Bgp::thread_new (struct thread_master *m)
{
    struct thread *New;

    New = ( struct thread* ) XMALLOC (MTYPE_THREAD, sizeof (struct thread));
    bzero (New, sizeof (struct thread));
    m->alloc++;
    return New;
}

/* Add New read thread. */
struct thread *
Bgp::thread_add_read (struct thread_master *m, 
                      int (Bgp::*func)(struct thread *),
                      void *arg,
                      Agent* ListenAgent)
{
    struct thread *thread;

    assert (m != NULL);

    thread = thread_new (m);
    thread->type = THREAD_READ;
    thread->master = m;
    thread->func = func;
    thread->arg = arg;
    thread->u.ListenAgent = ListenAgent; 
    thread_list_add (&m->read, thread);

    return thread;
}

/* Add New write thread. */
struct thread *
Bgp::thread_add_ready (struct thread_master *m,
                       int (Bgp::*func)(struct thread *),
                       void *arg)
{
    struct thread *thread;

    assert (m != NULL);

    thread = thread_new (m);
    thread->type = THREAD_READY;
    thread->master = m;
    thread->func = func;
    thread->arg = arg;
    thread->u.ListenAgent = NULL;
    
    thread_list_add (&m->ready, thread);

    return thread;
}

/* timer compare */
int
Bgp::thread_timer_cmp (double a, double b)
{
    if (a > b)
        return 1;
    if (a < b)
        return -1;
    return 0;
}

/* Add timer event thread. */
struct thread *
Bgp::thread_add_timer (struct thread_master *m,
                       int (Bgp::*func)(struct thread *),
                       void *arg,
                       double timer)
{
    double timer_now;
    struct thread *thread;
    struct thread *tt;

    assert (m != NULL);

    thread = thread_new (m);
    thread->type = THREAD_TIMER;
    thread->master = m;
    thread->func = func;
    thread->arg = arg;
    
    /* Do we need jitter here? */

    timer_now = Scheduler::instance().clock();  
    timer_now += timer;
    thread->u.time = timer_now;

    /* Sort by timeval. */
    for (tt = m->timer.head; tt; tt = tt->next)
        if (thread_timer_cmp (thread->u.time, tt->u.time) <= 0)
            break;

    if (tt)
        thread_list_add_before (&m->timer, tt, thread);
    else
        thread_list_add (&m->timer, thread);

    return thread;
}

/* Add simple event thread. */
struct thread *
Bgp::thread_add_event (struct thread_master *m,
                       int (Bgp::*func)(struct thread *), 
                       void *arg,
                       int val)
{
    struct thread *thread;

    assert (m != NULL);

    thread = thread_new (m);
    thread->type = THREAD_EVENT;
    thread->master = m;
    thread->func = func;
    thread->arg = arg;
    thread->u.val = val;
    thread_list_add (&m->event, thread);

    return thread;
}

/* Cancel thread from scheduler. */
void
Bgp::thread_cancel (struct thread *thread)
{
    /**/
    switch (thread->type)
    {
    case THREAD_READ:
        thread_list_delete (&thread->master->read, thread);
        break;
    case THREAD_WRITE:
        thread_list_delete (&thread->master->write, thread);
        break;
    case THREAD_TIMER:
        thread_list_delete (&thread->master->timer, thread);
        break;
    case THREAD_EVENT:
        thread_list_delete (&thread->master->event, thread);
        break;
    case THREAD_READY:
        thread_list_delete (&thread->master->ready, thread);
        break;
    default:
        break;
    }
    thread->type = THREAD_UNUSED;
    thread->master->alloc--;
    XFREE (MTYPE_THREAD,thread);
}

/* Delete all events which has argument value arg. */
void
Bgp::thread_cancel_event (struct thread_master *m, void *arg)
{
    struct thread *thread;

    thread = m->event.head;
    while (thread)
    {
        struct thread *t;

        t = thread;
        thread = t->next;

        if (t->arg == arg)
        {
            thread_list_delete (&m->event, t);
            t->type = THREAD_UNUSED;
	    XFREE (MTYPE_THREAD,t);
	    m->alloc--;
        }
    }
}

/* timer sub */
double
Bgp::thread_timer_sub (double a, double b)
{
    double ret;

    ret = a - b;
    return ret;
}

/* For debug use. */
void
Bgp::thread_timer_dump (double tv)
{
    printf ("Timer : %lf \n",  tv);
}

/* Fetch next ready thread. */
void
Bgp::thread_fetch_part1 (struct thread_master *m)
{
    struct thread *thread;
    double timer_now;
    double timer_min;
    double timer_wait ;

    assert (m != NULL);

    if (0) thread_master_debug(m);

    /* If there are events process them first. */
    while ((thread = thread_trim_head (&m->event)))
    {
        thread->type = THREAD_UNUSED;
        thread_add_unuse (m, thread);
        SET_TIMEOUT_TYPE_EXECUTE;
        timer->Bgpresched(0);
        thread_to_be_fetched = thread ;
        return ;
    }
    
    /* If there are ready threads process them */
    while ((thread = thread_trim_head (&m->ready)))
    {

        thread->type = THREAD_UNUSED;
        thread_add_unuse (m, thread);
        SET_TIMEOUT_TYPE_EXECUTE;
        timer->Bgpresched(0);
        thread_to_be_fetched = thread ;
        return ;
    }

    /* Calculate wait timer. */

    if (m->timer.head)
    {
      timer_now = Scheduler::instance().clock();
      timer_min = m->timer.head->u.time;
      timer_min = thread_timer_sub (timer_min, timer_now);
      
      if (timer_min < 0)
        {
	  timer_min = 0;
        }
      timer_wait = timer_min;
    
    } else {
      timer_wait = DBL_MAX;
      //In original zebra in this case select would be called with null
      //timeout argument, meaning block until an external event 
      //(e.g. read event) unblocks us. We replace this by giving
      //a very large timeout value (largest possible).      
    }
    
    SET_TIMEOUT_TYPE_FETCH2;
    // Here, in the original Zebra code there was a select() call,
    // the select would block for timer_wait. The simulated 
    // bgp instance schedules a timeout for "timer_wait",
    // if a msg arrives before the 
    // timer_wait expires the reception of the message 
    // will cancel the "timer_wait" timeout and the bgp instance will
    // process the received msg.
    // What if a msg is received when the bgp instance  is not waiting 
    // for the "time_wait" to expire but instead it is doing sth 
    // else ( such as processing an other msg, sending a msg,etc )?
    // In this case the bgp_interrupt function will insert an entry 
    // in the InterruptQueue. After the bgp instance finishes the work in 
    // progress, it will check the InterruptQueue to see if there was 
    // any interrupt. If so, it will process the interrupt(s),
    // otherwise it will issue a timeout for "timer_wait" and it will  
    // return control to ns Scheduler.
    
    if (InterruptQueue.size()==0)
      {
        timer->Bgpresched(timer_wait);
      } 
    else
      { 
	//  The InterruptAgent is the local Tcp Listenning Agent 
	//  that received the msg
	
        InterruptAgent = InterruptQueue.front().IntAgent;
	ReceivedMsg =InterruptQueue.front().intmsg;
        
	if (0) printf("\n%s: Pending interrupts found proceeding them",name());
        InterruptQueue.pop_front();
        timer->Bgpresched(0);
      }

}


void
Bgp::thread_fetch_part2 (struct thread_master *m,Agent * AgentCausedTimeout)
{
    struct thread *thread;
    double timer_now;
    double timer_min;
    double timer_wait;

    if(0) thread_master_debug(m);

    /* Read thead. */
    thread = m->read.head;
    while (thread)
    {
        struct thread *t;

        t = thread;
        thread = t->next;
        if (t->u.ListenAgent == AgentCausedTimeout)
        {
            thread_list_delete (&m->read, t);
            thread_list_add (&m->ready, t);
            t->type = THREAD_READY;
        }
    }


    /* Timer update. */
    timer_now = Scheduler::instance().clock();

    thread = m->timer.head;
    while (thread)
    {
        struct thread *t;
        t = thread;
        thread = t->next;

        if (thread_timer_cmp (timer_now, t->u.time) >= 0)
        {
            thread_list_delete (&m->timer, t);
            thread_list_add (&m->ready, t);
            t->type = THREAD_READY;
        }
    }
    /* Return one event. */
    thread = thread_trim_head (&m->ready);

    /* There is no ready thread. */
    if (!thread)
      {
	SET_TIMEOUT_TYPE_FETCH1;
	timer->Bgpresched(0);
	return ; 
      } 
    thread->type = THREAD_UNUSED;
    thread_add_unuse (m, thread);

    SET_TIMEOUT_TYPE_EXECUTE;
    timer->Bgpresched(0);
    thread_to_be_fetched = thread ;
}

/* List allocation and head/tail print out. */
void
Bgp::thread_list_debug (struct thread_list *list)
{
    printf ("count [%d] head [%p] tail [%p]\n",
            list->count, list->head, list->tail);
}

/* Debug print for thread_master. */
void
Bgp::thread_master_debug (struct thread_master *m)
{
    if (1)
    {
        printf("\n");
        struct thread *t;
        if (m->read.head!=NULL)
        {
            printf ("\n%s: read: ",name());
            for (t = m->read.head; t; t = t->next)
                printf ("[%d] ", t->type);
        }
        if (m->write.head!=NULL)
        {
            printf ("| write:");
            for (t = m->write.head; t; t = t->next)
                printf ("[%d] ", t->type);
        }
        if (m->event.head!=NULL)
        {
            printf ("| event: ");
            for (t = m->event.head; t; t = t->next)
                printf ("[%d] ", t->type);
        }
        if (m->ready.head!=NULL)
        {
            printf ("| ready: ");
            for (t = m->ready.head; t; t = t->next)
                printf ("[%d] ", t->type);
        }
        if (m->timer.head!=NULL)
        {
            printf ("| timer: ");
            for (t = m->timer.head; t; t = t->next)
                printf ("[%d,%lf] ", t->type,t->u.time);
        }
        if (m->unuse.head!=NULL)
        {
            printf ("| unuse: ");
            for (t = m->unuse.head; t; t = t->next)
                printf ("[%d] ", t->type);
        }

    }

}

/* Debug print for thread. */
void
Bgp::thread_debug (struct thread *thread)
{
      printf ("Type [%d] Next [%p]"
           "Prev [%p] Func [%p] arg [%p] \n", 
           thread->type, thread->next,
           thread->prev, thread->func, thread->arg);
}

/* Call thread ! */
void
Bgp::thread_call (struct thread *thread)
{
#ifdef HAVE_PERFCTR  
  struct perfctr_sum_ctrs before;
  if (workload_model == TIME_SAMPLE_WORKLOAD_MODEL) do_read(&before);
#endif /*  HAVE_PERFCTR */
  (this->*thread->func) (thread);
  thread_list_delete (&thread->master->unuse, thread);
  thread->master->alloc--;
  XFREE (MTYPE_THREAD,thread);
  SET_TIMEOUT_TYPE_FETCH1;

  /* after executing the fetched thread, we "pause" execution for 
     workload(), before resuming execution. This approach tries to 
     simualate the execution time of the bgpd daemon. During the 
     "pause" interval all bgp_interrupts are queued instead of being 
     executes.
  */
#ifdef HAVE_PERFCTR
  timer->Bgpresched(workload(&before));
#else 
  timer->Bgpresched(workload());
#endif /* HAVE_PERFCTR */

}

/* Execute thread */
struct thread *
Bgp::thread_execute (struct thread_master *m,
                     int (Bgp::*func)(struct thread *), 
                     void *arg,
                     int val)
{
    struct thread dummy; 

    memset (&dummy, 0, sizeof (struct thread));

    dummy.type = THREAD_EVENT;
    dummy.master = (struct thread_master *)NULL;
    dummy.func = func;
    dummy.arg = arg;
    dummy.u.val = val;
    thread_call (&dummy);     /* execute immediately */

    return(struct thread *)NULL;
}



////////////////////////////////////////////////
////////////////////////////////////////////////
///vector.c/////////////////////////////////////
////////////////////////////////////////////////


/* Initialize vector : allocate memory and return vector. */
struct _vector*
Bgp::vector_init (unsigned int size)
{
    struct _vector* v = ( struct _vector* )XMALLOC (MTYPE_VECTOR, sizeof (struct _vector));

    /* allocate at least one slot */
    if (size == 0)
        size = 1;

    v->alloced = size;
    v->max = 0;
    v->index = (void **) XMALLOC (MTYPE_VECTOR_INDEX, sizeof (void *) * size);
    memset (v->index, 0, sizeof (void *) * size);
    return v;
}

void
Bgp::vector_only_wrapper_free (struct _vector* v)
{
    XFREE (MTYPE_VECTOR, v);
}

void
Bgp::vector_only_index_free (void *index)
{
    XFREE (MTYPE_VECTOR_INDEX, index);
}

void
Bgp::vector_free (struct _vector* v)
{
    XFREE (MTYPE_VECTOR_INDEX, v->index);
    XFREE (MTYPE_VECTOR, v);
}

struct _vector*
Bgp::vector_copy (struct _vector* v)
{
    unsigned int size;
    struct _vector* New = ( struct _vector * ) XMALLOC (MTYPE_VECTOR, sizeof (struct _vector));

    New->max = v->max;
    New->alloced = v->alloced;

    size = sizeof (void *) * (v->alloced);
    New->index = (void **) XMALLOC (MTYPE_VECTOR_INDEX, size);
    memcpy (New->index, v->index, size);

    return New;
}

/* Check assigned index, and if it runs short double index pointer */
void
Bgp::vector_ensure (struct _vector* v, unsigned int num)
{
    if (v->alloced > num)
        return;

    v->index = ( void**) XREALLOC (MTYPE_VECTOR_INDEX, 
                                   v->index, sizeof (void *) * (v->alloced * 2));

    memset (&v->index[v->alloced], 0, sizeof (void *) * v->alloced);
    v->alloced *= 2;

    if (v->alloced <= num)
        vector_ensure (v, num);

}

/* This function only returns next empty slot index.  It dose not mean
   the slot's index memory is assigned, please call vector_ensure()
   after calling this function. */
int
Bgp::vector_empty_slot (struct _vector* v)
{
    unsigned int i;

    if (v->max == 0)
        return 0;

    for (i = 0; i < v->max; i++)
        if (v->index[i] == 0)
            return i;

    return i;
}

/* Set value to the smallest empty slot. */
int
Bgp::vector_set (struct _vector* v, void *val)
{
    unsigned int i;

    i = vector_empty_slot (v);
    vector_ensure (v, i);

    v->index[i] = val;

    if (v->max <= i)
        v->max = i + 1;

    return i;
}

/* Set value to specified index slot. */
int
Bgp::vector_set_index (struct _vector* v, unsigned int i, void *val)
{

    vector_ensure (v, i);

    v->index[i] = val;

    if (v->max <= i)
        v->max = i + 1;

    return i;
}

/* Lookup vector, ensure it. */
void *
Bgp::vector_lookup_index (struct _vector* v, unsigned int i)
{
    vector_ensure (v, i);
    return v->index[i];
}

/* Unset value at specified index slot. */
void
Bgp::vector_unset (struct _vector* v, unsigned int i)
{
    if (i >= v->alloced)
        return;

    v->index[i] = NULL;

    if (i + 1 == v->max)
    {
        v->max--;
        while (i && v->index[--i] == NULL && v->max--)
            ;               /* Is this ugly ? */
    }
}

/* Count the number of not emplty slot. */
unsigned int
Bgp::vector_count (struct _vector* v)
{
    unsigned int i;
    unsigned count = 0;

    for (i = 0; i < v->max; i++)
        if (v->index[i] != NULL)
            count++;

    return count;
}

/* For debug, display  contents of vector */
void
Bgp::vector_describe (FILE *fp, struct _vector* v)
{
    int i;

    fprintf (fp, "vecotor max : %d\n", v->max);
    fprintf (fp, "vecotor alloced : %d\n", v->alloced);

    for (i = 0; i < v->max; i++)
        if (v->index[i] != NULL)
            fprintf (fp, "vector [%d]: %p\n", i, vector_slot (v, i));
}



////////////////////////////////////////////////
////////////////////////////////////////////////
//////vty.c/////////////////////////////////////
////////////////////////////////////////////////

int
Bgp::vty_out ( struct zlog *zl, int priority,const char *format, ...)
{ 
  int ret ; 
  va_list args[ZLOG_MAX_INDEX];
  int index;

  for (index = 0; index < ZLOG_MAX_INDEX; index++)
    va_start(args[index], format);

  ret = vty_log (zl, priority, format, args);

  for (index = 0; index < ZLOG_MAX_INDEX; index++)
    va_end (args[index]);

  return ret;
}

int
Bgp::vty_log (struct zlog *zl, int priority, const char *format, va_list *args)
{
  int ret ;
  /* If zlog is not specified, use default one. */
  if (zl == NULL)
    zl = zlog_default;
  
  /* When zlog_default is also NULL, use stderr for logging. */
  if (zl == NULL)
    {
      ret = vfprintf (stderr, format, args[ZLOG_NOLOG_INDEX]);
      fflush (stderr);
      
      /* In this case we return at here. */
      return ret;
    }
  
  /* only log this information if it has not been masked out */
  if (priority > zl->maskpri)
    return 0;
  
  /* Syslog output */
  /*Removed */
  
  /* File output. */
  if (zl->flags & ZLOG_FILE)
    {
      ret = vfprintf (zl->fp, format, args[ZLOG_FILE_INDEX]);
      fflush (zl->fp);
    }
  
  /* stdout output. */
  if (zl->flags & ZLOG_STDOUT)
    {
      ret = vfprintf (stdout, format, args[ZLOG_STDOUT_INDEX]);
      fflush (stdout);
    }
  /* stderr output. */
  
  if (zl->flags & ZLOG_STDERR)
    {
      ret = vfprintf (stderr, format, args[ZLOG_STDERR_INDEX]);
      fflush (stderr);
    }
  return ret ; 
}

/* Allocate New vty struct. */
struct vty *
Bgp::vty_new ()
{
    struct vty *New = ( struct vty* )  XMALLOC (MTYPE_VTY, sizeof (struct vty));
    bzero (New, sizeof (struct vty));

    New->buf = ( char * ) XMALLOC (MTYPE_VTY, VTY_BUFSIZ);
    
    return New;
}

/* Close vty interface. */
void
Bgp::vty_close (struct vty *vty)
{
    /* Cancel threads.*/
    if (vty->buf)
        XFREE (MTYPE_VTY, vty->buf);

    /* OK free vty. */
    XFREE (MTYPE_VTY, vty);
}


/* Read up configuration file from file_name. */
void
Bgp::vty_read_file (FILE *confp)
{
    int ret;
    struct vty *vty;

    vty = vty_new ();
    vty->node = CONFIG_NODE;

    /* Execute configuration file */

    ret = config_from_file (vty, confp); 


    if (ret != CMD_SUCCESS)
    {
        switch (ret)
        {
        case CMD_ERR_AMBIGUOUS:
            fprintf (stderr, "Ambiguous command.\n");
            break;
        case CMD_ERR_NO_MATCH:
            fprintf (stderr, "There is no such command.\n");
            break;
        }
        fprintf (stderr, "Error occured during reading below line.\n%s\nfrom file %s\n", 
                 vty->buf,bgp_config_file);
        vty_close (vty);
        exit (1);
    }

    vty_close (vty);
}

/* Read up configuration file from file_name. */
void
Bgp::vty_read_config ()
{

    FILE *confp = NULL;
    char *fullpath=  bgp_config_file; 

    confp = fopen (fullpath, "r");

    if (confp == NULL)
    {
        printf("Fatal Error: No such configuration file or directory %s",bgp_config_file);
	exit(1);
    }

    vty_read_file (confp);

    fclose (confp);

    host_config_set (fullpath);

}

/* inserts supressed advertisement info in peer's
   supressed advertisement list. If there is another 
   entry for supressed prefix it overwites the entry 
   and returns 1; otherwise it returns 0.
*/

#ifndef HAVE_ZEBRA_93b

int
Bgp::bgp_advertise_insert(struct peer *peer,struct bgp_advertise *adv) 
{ 
  struct bgp_advertise *current;
  int ret = 0 ;
  

  if(!peer->top_adv)
    peer->top_adv = adv;
  else {
    for ( current = peer->top_adv; current; current = current->next ) 
      if (prefix_same(current->p,adv->p)) { 
	
	/*
	  cancel previous supressed advertisement for this prefix
	*/
	bgp_advertise_remove(peer,current);
	ret = 1;
	break;
      }

    if(!peer->top_adv) {
      peer->top_adv = adv;
      return ret;
    }
    
    for ( current = peer->top_adv; current; current = current->next )
      if( current->next == NULL) {
	current->next = adv;
	adv->prev = current;
	break;
      }
  }
  return ret;
} 
	  

void 
Bgp::bgp_advertise_remove( struct peer *peer,struct bgp_advertise *rmv) 
{ 
  

  if (!peer->top_adv) return ;
  
  if (rmv->next)
    rmv->next->prev = rmv->prev;
  
  if (rmv->prev)
    rmv->prev->next = rmv->next;
  else 
    peer->top_adv = rmv->next;
  
  XFREE(MTYPE_BGP_ADVERTISE,rmv);
}

void
Bgp::bgp_advertise_remove_by_prefix (struct peer *peer,struct prefix *p)
{
  struct bgp_advertise *tmp;
  
  for(tmp = peer->top_adv; tmp;tmp = tmp->next) 
    if(prefix_same(p,tmp->p)) bgp_advertise_remove(peer,tmp);
       
}


void
Bgp::routeadv_list_add(struct peer *peer, struct thread *t) {
  struct bgp_routeadv_list  *New;

  New = (struct bgp_routeadv_list*) XMALLOC(MTYPE_BGP_ROUTEADV_LIST,
					    sizeof(struct bgp_routeadv_list));
  New->t = t;	
  New->prev = NULL;
  New->next = NULL;
  
  if(!peer->t_routeadv_list) peer->t_routeadv_list = New;
  else { 
    peer->t_routeadv_list->prev = New ;
    New->next = peer->t_routeadv_list;
    peer->t_routeadv_list = New;
  }
}

void
Bgp::routeadv_list_remove(struct peer *peer, struct thread *t) {
  struct bgp_routeadv_list *tmp;
  for (tmp = peer->t_routeadv_list;tmp;tmp = tmp->next) 
    if(memcmp(tmp->t,t,sizeof(struct thread))==0) { 
      if(tmp->next)
	tmp->next->prev = tmp->prev;
      if(tmp->prev)
	tmp->prev->next = tmp->next;
      if(tmp == peer->t_routeadv_list) peer->t_routeadv_list = NULL;
      XFREE(MTYPE_BGP_ROUTEADV_LIST,tmp);
      break;
    }
}

bool
Bgp::routeadv_list_search(struct peer *peer, struct prefix *p) {
  struct thread *thread;
  struct bgp_mrai_info *bmi;
  struct bgp_routeadv_list *tmp=NULL;  

  char buf[BUFSIZ];
  
  // scann across pending timers
  for (tmp = peer->t_routeadv_list;tmp;tmp = tmp->next) {
    thread = tmp->t;
    bmi = (struct bgp_mrai_info*) THREAD_ARG(thread); 
    if(0)zlog (peer->log, LOG_INFO, 
	  "%s TIMER SEARCH prefix %s/%d, UT: %s/%d\n",
 	  peer->host,
 	  Bgp::inet_ntop (p->family, &p->u.prefix, buf, SU_ADDRSTRLEN),
 	  p->prefixlen,
 	  Bgp::inet_ntop (bmi->p->family, &bmi->p->u.prefix, buf, SU_ADDRSTRLEN),
 	  bmi->p->prefixlen);
    
    if (prefix_same(bmi->p,p)) {
      if(0)zlog (peer->log, LOG_INFO, 
	    "%s TIMER SEARCH prefix %s/%d timer exists\n",
	    peer->host,
	    Bgp::inet_ntop (p->family, &p->u.prefix, buf, SU_ADDRSTRLEN),
	    p->prefixlen);
      return 1;
    }
  }
  if(0)zlog (peer->log, LOG_INFO, 
	"%s TIMER SEARCH prefix %s/%d, timer dsnt exists\n",
	peer->host,
	Bgp::inet_ntop (p->family, &p->u.prefix, buf, SU_ADDRSTRLEN),
	p->prefixlen);
  return 0;
}

struct bgp_advertise*
Bgp::bgp_advertise_new() 
{ 
  struct bgp_advertise* New;
  New =(struct bgp_advertise*)  XMALLOC(MTYPE_BGP_ADVERTISE, sizeof (struct bgp_advertise));
  New->next = NULL;
  New->prev = NULL;
  memset(&New->attribute,0,sizeof(struct attr)); 
  return New;
}

/* checks if there is a running MRAI timer and depending on the
   case (per prefix or per peer) it decides to supress the update or not
*/

int 
Bgp::bgp_update_send_check (struct bgp_info *ri, struct peer_conf *conf, struct peer *peer,
			    struct prefix *p, struct attr *attr, afi_t afi, safi_t safi,
			    struct peer *from, struct prefix_rd *prd, u_char *tag)
{
  struct bgp_advertise *adv; 
  double now;
  struct thread *t;
  struct bgp_mrai_info *bmi;
  Prefix2Timestamp_t::iterator iter;
  char buf[SU_ADDRSTRLEN];

  if (mrai_type==MRAI_DISABLE) return 1;
  if (mrai_type==MRAI_PER_PREFIX) {
    /* 
       Check when was the last update for this prefix send 
    */
    now = Scheduler::instance().clock();
    pair<struct prefix,double> temp;
    
    for( iter = peer->update_stamps.begin(); iter != peer->update_stamps.end();++iter ) 
      if( prefix_same(&iter->first,p))
	if((now - iter->second) < peer->v_routeadv)
	  goto supress;  
     
    return 1;  
    
  supress:
    zlog (peer->log, LOG_INFO, 
	  "%s UPDATE  %s/%d -- SUPRESS due to: MRAI per prefix timer\n",
	  peer->host,
	  Bgp::inet_ntop (p->family, &p->u.prefix, buf, SU_ADDRSTRLEN),
	  p->prefixlen);

    /* Mark the supression in a map*/
    string ip_prefix = inet_ntoa(p->u.prefix4);
    mrai_map[make_pair(ip_prefix,peer->local_as)] = 1; 
    /*
      Update supressed, create new advertise info
      
    */
     adv = bgp_advertise_new();
     adv->conf = conf;
     adv->p = p;
     
     adv->attribute = *attr;
     adv->attribute.aspath = aspath_dup(attr->aspath);
     adv->attribute.aspath->str = aspath_make_str_count (attr->aspath);
     if(attr->cluster) adv->attribute.cluster = cluster_dup(attr->cluster);
     if(attr->community)  adv->attribute.community = community_dup(attr->community);
     if(attr->ecommunity) adv->attribute.ecommunity = ecommunity_dup(attr->ecommunity);

     adv->afi = afi;
     adv->safi = safi;
     adv->from = from;
     adv->prd = prd;
     adv->tag = tag;
     
     bgp_advertise_insert(peer,adv);
     /*
       if there is no pending timer for this prefix, we add one 
     */	
     if (!routeadv_list_search(peer,p)) {

       bmi = (struct bgp_mrai_info*) XMALLOC(MTYPE_BGP_MRAI_INFO,sizeof(struct bgp_mrai_info));
       bmi->peer = peer;
       bmi->p = p;
       bmi->bi = ri; 
	 
       t = thread_add_timer(master,&Bgp::bgp_routeadv_timer,bmi,peer->v_routeadv - (now - iter->second));

       /* Add timer to peer's list of pending timers*/
       routeadv_list_add(peer,t);
     }
       
     return 0;
  }
  else {
    
    /* If MRAI timer is on supress advertisement */
    if(peer->t_routeadv) { 
      
      zlog (peer->log, LOG_INFO, 
	    "%s UPDATE  %s/%d -- SUPRESS due to: MRAI per peer timer\n",
	    peer->host,
	    Bgp::inet_ntop (p->family, &p->u.prefix, buf, SU_ADDRSTRLEN),
	    p->prefixlen);

      /* Mark the supression in a map*/
      string ip_prefix = inet_ntoa(p->u.prefix4);
      mrai_map[make_pair(ip_prefix,peer->local_as)] = 1; 
      
      adv = bgp_advertise_new();
      adv->conf = conf;
      adv->p = p;
 
      adv->attribute = *attr;
      adv->attribute.aspath = aspath_dup(attr->aspath);
      adv->attribute.aspath->str = aspath_make_str_count (attr->aspath);
      if(attr->cluster) adv->attribute.cluster = cluster_dup(attr->cluster);
      if(attr->community)  adv->attribute.community = community_dup(attr->community);
      if(attr->ecommunity) adv->attribute.ecommunity = ecommunity_dup(attr->ecommunity);
           
      adv->afi = afi;
      adv->safi = safi;
      adv->from = from;
      adv->prd = prd;
      adv->tag = tag;
      
      bgp_advertise_insert(peer,adv);
            
      return 0;
    }

    BGP_TIMER_ON (peer->t_routeadv, &Bgp::bgp_routeadv_timer,
		  peer, peer->v_routeadv);
    return 1;
  }
}

int 
Bgp::bgp_withdraw_send_check(struct peer* peer,struct prefix *p)
{
  struct bgp_advertise *adv;

  /*
    Check if there is a supressed update 
    for the withdrawn prefix, rm it if so. 
  */
  
  if(peer->top_adv) 
    for(adv = peer->top_adv; adv; adv = adv->next) { 
      if(prefix_same(adv->p,p)){
	bgp_advertise_remove(peer,adv);
	if(mrai_type==MRAI_PER_PREFIX) bgp_cancel_timer_by_prefix(peer,p);
	break;
      }
    }  

  //Rm timestamps
  //Prefix2Timestamp_t::iterator iter;
  //if(mrai_type==MRAI_PER_PREFIX)
  // for (iter = peer->update_stamps.begin(); iter != peer->update_stamps.end();++iter)
  //  if (prefix_same(&iter->first,p)) {
  //peer->update_stamps.erase(iter);
  //break;
  //}

  return 1;
}


/* function called when a MRAI timer expires */
int 
Bgp::bgp_routeadv_timer (struct thread *thread){ 
  struct peer *peer;
  struct bgp_advertise *top;
  struct bgp_mrai_info *bmi;
  struct bgp_advertise *tmp;
  struct prefix *p;
  struct bgp_info *bi;

  double simulation_time = NOW;

  if(mrai_type == MRAI_PER_PEER) {

    /* If supressed advertisements exist and we are doing per peer mrai */
    peer = (struct peer* ) THREAD_ARG(thread);
    peer->t_routeadv = NULL;            /* reset the timer pointer */
    top = peer->top_adv;                
    
    if (BGP_DEBUG (fsm, FSM))
      zlog (peer->log, LOG_DEBUG,
	    "%s [FSM] Timer (routeadv timer expire)\n",
	    peer->host);

    if(top) {
      
      bgp_update_send(top->conf,peer,top->p,&top->attribute,top->afi,
		      top->safi,top->from,top->prd,top->tag);

      /* Unmark the supression and decrement the processing queue */
      string ip_prefix = inet_ntoa(top->p->u.prefix4);
      mrai_map[make_pair(ip_prefix,peer->local_as)] = 0;
      for (int i = 0; i < total_events; i++)
      {
     	if (event_prefix[i] == ip_prefix)
	{		
      		ls_array[i]->process_queue[peer->local_as] -= 1; 
		#if CONV_DET_DEBUG
      		printf("\n DEBUG: OnSend process queue of AS %d decremented to %d",peer->local_as, ls_array[i]->process_queue[peer->local_as]);
		#endif
		break;
     	}
      }
      
      bgp_adj_set (peer->adj_out[top->afi][top->safi], top->p, &top->attribute,
		   top->prd, top->safi);
		    
      bgp_advertise_remove(peer,top);

      
    }
  } else if (mrai_type == MRAI_PER_PREFIX) { 

    /*  If we are doing per prefix MRAI */
    bmi = (struct bgp_mrai_info*) THREAD_ARG(thread);

    /* prefix for the which the timer was */
    p = bmi->p;
    peer = bmi->peer;
    bi = bmi->bi;
    
    if (BGP_DEBUG (fsm, FSM))
      zlog (peer->log, LOG_DEBUG,
	    "%s [FSM] Timer (routeadv timer expire)\n",
	    peer->host);

    XFREE(MTYPE_BGP_MRAI_INFO,bmi);
    
    top = peer->top_adv;
    
    /* rm timer from  MRAI timers list */
    routeadv_list_remove(peer,thread);

    /*Scan the supressed advertisements list to find if there was
      any advertisement for this prefix */
    string ip_prefix = "";

    for ( tmp = top; tmp; tmp = tmp->next ) 
      if (prefix_same(tmp->p,p)) {
	
	/* if found, send the update now*/
	bgp_update_send(tmp->conf,peer,tmp->p,&tmp->attribute,tmp->afi,
			tmp->safi,tmp->from,tmp->prd,tmp->tag);

        /* Unmark the supression */
        ip_prefix = inet_ntoa(tmp->p->u.prefix4);
        mrai_map[make_pair(ip_prefix,peer->local_as)] = 0;

	bgp_adj_set (peer->adj_out[tmp->afi][tmp->safi], tmp->p, &tmp->attribute,
		     tmp->prd, tmp->safi);
      
	/* add timestap for this prefix */
	bgp_update_add_timestamp(peer,tmp->p);
	  
	/* rm entry from supressed updates list*/
	bgp_advertise_remove(peer,tmp);
	
	/*there cannot be more than one supressed advertisement 
	  for each prefix, since a second supressed advertisement 
	  would overwrite the entry for the first supressed advertisement.
	  thus we break.
	*/
	break;
      }
      
      /* Decrement the processing queue */
      for (int i = 0; i < total_events; i++)
      {
        if (event_prefix[i] == ip_prefix)
	{		
      	    ls_array[i]->process_queue[peer->local_as] = 0; 
	    #if CONV_DET_DEBUG
      	    printf("\n DEBUG: OnSend process queue of AS %d decremented to %d",peer->local_as, ls_array[i]->process_queue[peer->local_as]);
	    #endif
	    break;
     	}
      }

  }
  return 0;
}

#else 

int
Bgp::bgp_routeadv_timer (struct thread *thread)
{
  struct peer *peer;

  peer = (struct peer*)THREAD_ARG (thread);
  peer->t_routeadv = NULL;

  if (BGP_DEBUG (fsm, FSM))
    zlog (peer->log, LOG_DEBUG,
	  "%s [FSM] Timer (routeadv timer expire)\n",
	  peer->host);

  peer->synctime = (int) NOW + start_time;

  BGP_WRITE_ON (peer->t_write, &Bgp::bgp_write);

  BGP_TIMER_ON (peer->t_routeadv, &Bgp::bgp_routeadv_timer,
		peer, peer->v_routeadv);

  return 0;
}

#endif

int
Bgp::peer_advertise_interval_set (struct peer *peer, u_int32_t routeadv)
{
#define MAX_ADVERTISE_INTERVAL 600  
  if (routeadv > MAX_ADVERTISE_INTERVAL)
    return 1;

  SET_FLAG (peer->config, PEER_CONFIG_ROUTEADV);
  peer->routeadv = routeadv;
  peer->v_routeadv = routeadv;

  return 0;
}

int
Bgp::peer_advertise_interval_unset (struct peer *peer)
{

  UNSET_FLAG (peer->config, PEER_CONFIG_ROUTEADV);
  peer->routeadv = 0;

  if (peer_sort (peer) == BGP_PEER_IBGP)
    peer->v_routeadv = BGP_DEFAULT_IBGP_ROUTEADV;
  else
    peer->v_routeadv = BGP_DEFAULT_EBGP_ROUTEADV;
  
  return 0;
}

DEFUN (neighbor_advertise_interval,
       neighbor_advertise_interval_cmd,
       NEIGHBOR_CMD "advertisement-interval <0-600>",
       NEIGHBOR_STR
       NEIGHBOR_ADDR_STR
       "Minimum interval between sending BGP routing updates\n"
       "time in seconds\n")
{
  return peer_advertise_interval_vty (vty, argv[0], argv[1], 1);
}

DEFUN (no_neighbor_advertise_interval,
       no_neighbor_advertise_interval_cmd,
       NO_NEIGHBOR_CMD "advertisement-interval",
       NO_STR
       NEIGHBOR_STR
       NEIGHBOR_ADDR_STR
       "Minimum interval between sending BGP routing updates\n")
{
  return peer_advertise_interval_vty (vty, argv[0], NULL, 0);
}

int
Bgp::peer_advertise_interval_vty (struct vty *vty, char *ip_str, char *time_str,
			     int set)  
{
  int ret;
  struct peer *peer;
  u_int32_t routeadv = 0;
  union sockunion su;

  ret = str2sockunion(ip_str,&su);
  
  if (ret < 0)
    {
      vty_out (zlog_default,LOG_DEBUG, "Malformed address: %s%s", ip_str, VTY_NEWLINE);
      return CMD_WARNING;
    }
  
  peer = peer_lookup_by_su (&su);

  if (! peer)
    return CMD_WARNING;
  
  if (time_str)
    VTY_GET_INTEGER_RANGE ("advertise interval", routeadv, time_str, 0, MAX_ADVERTISE_INTERVAL);

  if (set)
    ret = peer_advertise_interval_set (peer, routeadv);
  else
    ret = peer_advertise_interval_unset (peer);

  return CMD_SUCCESS;
}

#ifndef HAVE_ZEBRA_93b
void
Bgp::bgp_update_add_timestamp( struct peer* peer, struct prefix *p) {
  double now = Scheduler::instance().clock();
  Prefix2Timestamp_t::iterator iter;
  
  //First erase any previous timestamp for this prefix
  for (iter = peer->update_stamps.begin() ; iter !=  peer->update_stamps.end(); ++iter) 
    if (prefix_same(&iter->first,p)) {
      peer->update_stamps.erase(iter);
      break;
    }

  
  /* Create new entry */
  pair<struct prefix,double> new_entry;
  new_entry.first = *p;
  new_entry.second = now;
  
  /* Add new entry in peer's timestamp list */
  peer->update_stamps.push_front(new_entry);
  
  /* For Debugging */
  /*
  for (iter = peer->update_stamps.begin() ; iter !=  peer->update_stamps.end(); ++iter) 
    if (prefix_same(&iter->first,p)) 
      printf("\nFound timestamp %f for this prefix ",iter->second); 
  */
}

/* cancels all pending timers,
   clears supressed advertisements &
   clears timestamps   
*/ 

void
Bgp::bgp_mrai_timers_off(struct peer *peer){ 
  struct thread *t;
  struct bgp_routeadv_list *tmp, *tmp_next;
  struct bgp_mrai_info *bmi;
  struct bgp_advertise *ba,*ba_next;
  
  if (mrai_type == MRAI_PER_PREFIX) {     
    for(tmp = peer->t_routeadv_list; tmp ; tmp = tmp->next) {
      t = tmp->t;
      bmi = (struct bgp_mrai_info*) THREAD_ARG(t);
      XFREE(MTYPE_BGP_MRAI_INFO,bmi);
      thread_cancel(t);
    }
    tmp = peer->t_routeadv_list;
    while(tmp) {
      tmp_next = tmp->next;
      XFREE(MTYPE_BGP_ROUTEADV_LIST,tmp);
      tmp = tmp_next;
    }      
    peer->t_routeadv_list = NULL;
  }
  if (mrai_type == MRAI_PER_PEER) {
    if(peer->t_routeadv) thread_cancel(peer->t_routeadv);
    peer->t_routeadv = NULL;
  }
  if (mrai_type == MRAI_PER_PEER || mrai_type == MRAI_PER_PREFIX) {

    /* Also delete all advertise information */
    ba = peer->top_adv;
    while (ba) { 
      /*store the next in the list */
      ba_next = ba->next;	
      /* free the current */
      bgp_advertise_remove(peer,ba);
      ba = ba_next;
    }
  }    
  /* clear timestamps      */
  peer->update_stamps.clear();

}

/* It cancels any suppressed update for the given 
   prefix.
*/
void  
Bgp::bgp_cancel_supressed_update_by_prefix(struct peer *peer,struct prefix* p){ 

  char buf[SU_ADDRSTRLEN];
  Prefix2Timestamp_t::iterator iter;

  if(mrai_type == MRAI_PER_PREFIX) {
    /* For per prefix MRAI */ 

    //  rm pending timers for this prefix 
    //  update peer pending timers 
    bgp_cancel_timer_by_prefix(peer,p);
    
    //  Rm  supressed updates for this prefix
    bgp_advertise_remove_by_prefix(peer,p);
    
    //Rm timestamps
    for (iter = peer->update_stamps.begin(); iter != peer->update_stamps.end();++iter)
      if (prefix_same(&iter->first,p)) { 
	peer->update_stamps.erase(iter);
	break;
      }
  }    
}

/* Cancel timer for a given prefix,
   used with MRAI_PER_PREFIX */
void 
Bgp::bgp_cancel_timer_by_prefix(struct peer *peer,struct prefix* p) { 
  struct thread *thread;
  struct bgp_mrai_info *bmi;
  struct bgp_routeadv_list *tmp=NULL;  
  char buf[BUFSIZ];
  
  // scann across pending timers and cancel timers for prefix p
  for (tmp = peer->t_routeadv_list;tmp;tmp = tmp->next) {
    thread = tmp->t;
    bmi = (struct bgp_mrai_info*) THREAD_ARG(thread); 
    if (prefix_same(bmi->p,p)) {
      if(0)zlog (peer->log, LOG_INFO, 
	    "%s TIMER CANCELED prefix %s/%d\n",
	    peer->host,
	    Bgp::inet_ntop (p->family, &p->u.prefix, buf, SU_ADDRSTRLEN),
	    p->prefixlen);
      XFREE(MTYPE_BGP_MRAI_INFO,bmi);
      routeadv_list_remove(peer,thread);
      thread_cancel(thread);
      break;
    }
  }
}
#endif /* HAVE_ZEBRA_93b*/
 
void 
Bgp::aspath_delete(struct aspath *aspath) {

  if (aspath->str)
    XFREE (MTYPE_AS_STR, aspath->str);

  if(aspath->length) XFREE(MTYPE_AS_SEG, aspath->data);
  XFREE (MTYPE_AS_PATH,aspath); 
}

NsObject* 
Bgp::peer_2_target_link (Bgp* b) { 
  if (this==b) { 
    cout <<"Error target_link_2_peer()"<<endl<<flush;
    return NULL;
  }
  
  Tcl& tcl = Tcl::instance();
  tcl.evalf("set rl [[Simulator instance] get-routelogic];set nh_id [ $rl lookup [%s id] [%s id] ];"
            "[Simulator instance] get-link-head [%s id] $nh_id;",
	    pNode->name(),b->pNode->name(),pNode->name());

  
  return (NsObject*) TclObject::lookup(tcl.result());
} 

/* Lookup ip in RIB. Return NULL when we can't find route. 
   the ip argument should point to a network byte order ip address.
   Warning: if ip points to a local ip address it won't work
*/
NsObject*
Bgp::bgp_table_lookup (struct in_addr* ip)
{
    struct bgp_table *table;
    struct bgp_node *node;
    struct bgp_node *matched;
    struct bgp_info *info;
    struct prefix p;
    struct bgp *bgp;

    p.family = AF_INET;
    p.prefixlen = IPV4_MAX_PREFIXLEN;
    p.u.prefix4 = *ip;

    bgp = ( struct bgp * ) bgp_get_default();
	
    table = bgp->rib[AFI_IP][SAFI_UNICAST];
    
    matched = NULL;
    node = table->top;
    
    /* Walk down tree.  If there is matched route then store it to
       matched. */
    while (node && prefix_match (&node->p, &p))
    {
        if (node->info)
            matched = node;

        node = node->link[check_bit(&p.u.prefix, node->p.prefixlen)];
    }
    
    if (matched)
      for (info = ( bgp_info * ) matched->info; info; info = ( bgp_info *)  info->next) { 
 	if(CHECK_FLAG (info->flags, BGP_INFO_SELECTED)) 
 	  return  info->peer->target;
      }
    
    return NULL;
}

/* This function calls the bgp_timer_set()
   foreach BGP instance peer.
   
*/
void Bgp::bgp_randomize() {
  
  if (!Bgp::Ip2BgpMap) cout<<"Warning BGP Registry is not initialized"<<endl;
  
  BgpList_t* BgpList;
  BgpList_t::iterator iter;
  struct peer *peer;
  struct listnode *nn;
	
  BgpList = Ip2BgpMap->GetAllBgp();
  for (iter = BgpList->begin() ; iter != BgpList->end(); ++iter) 
    for (nn = (*iter)->peer_list->head; nn; nn  = nn->next)      /*Scan accross peer list*/
      if ((peer = ( struct peer * ) nn->data) != NULL) {
	/*Start timers*/
	if (! (peer->afc[AFI_IP][SAFI_UNICAST] - 1) && peer->afc[AFI_IP][SAFI_UNICAST])
	  (*iter)->bgp_timer_set (peer);
      }
  
  delete BgpList;
}
